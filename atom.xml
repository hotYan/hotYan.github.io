<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hotYan</title>
  
  <subtitle>程序媛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hotkang.cn/"/>
  <updated>2018-07-27T07:29:00.185Z</updated>
  <id>https://hotkang.cn/</id>
  
  <author>
    <name>hotYan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript面向对象编程三</title>
    <link href="https://hotkang.cn/2018/07/26/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89/"/>
    <id>https://hotkang.cn/2018/07/26/JavaScript面向对象编程三/</id>
    <published>2018-07-26T07:05:40.000Z</published>
    <updated>2018-07-27T07:29:00.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解继承-待完善"><a href="#理解继承-待完善" class="headerlink" title="理解继承 [待完善]"></a>理解继承 <span style="font-size:.5em">[待完善]</span></h2><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>JavaScript高级程序设计(第3版)P162-P174</p></blockquote><p><br><br><br></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><blockquote><p>接口继承</p></blockquote><p>只继承 <strong>方法签名</strong>。由于函数没有签名,在ECMAScript中无法实现接口继承。</p><blockquote><p>实现继承</p></blockquote><p>继承 <strong>实际的方法</strong>。ECMAScript只支持实现继承,主要依靠 <strong>原型链</strong>来实现。</p><p><br></p><h2 id="一、原型链"><a href="#一、原型链" class="headerlink" title="一、原型链"></a>一、原型链</h2><p>基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><blockquote><p>构造函数、原型、实例的关系:</p></blockquote><ol><li><p>每个 <strong><code>构造函数</code></strong> 都有一个 <strong><code>原型对象</code></strong> ,构造函数都包含一个指向其原型对象的指针(<code>prototype</code>)</p></li><li><p><strong><code>实例对象</code></strong> 都包含一个指向 <strong><code>原型对象</code></strong> 的内部指针(<code>[[Prototype]]</code>)</p></li><li><p><strong><code>原型对象</code></strong> 都包含一个指向 <strong><code>构造函数</code></strong> 的指针(<code>constructor</code>)</p></li></ol><hr><p>待完善…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解继承-待完善&quot;&gt;&lt;a href=&quot;#理解继承-待完善&quot; class=&quot;headerlink&quot; title=&quot;理解继承 [待完善]&quot;&gt;&lt;/a&gt;理解继承 &lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="面向对象编程" scheme="https://hotkang.cn/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="继承" scheme="https://hotkang.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象编程二</title>
    <link href="https://hotkang.cn/2018/07/26/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%BA%8C/"/>
    <id>https://hotkang.cn/2018/07/26/JavaScript面向对象编程二/</id>
    <published>2018-07-26T07:05:31.000Z</published>
    <updated>2018-07-27T03:31:00.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解并创建对象-待完善"><a href="#理解并创建对象-待完善" class="headerlink" title="理解并创建对象 [待完善]"></a>理解并创建对象 <span style="font-size:.5em">[待完善]</span></h2><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>JavaScript高级程序设计(第3版)P144-P162</p></blockquote><p><br><br><br></p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><hr><blockquote><p>Object构造函数</p></blockquote><pre><code>var hotyan = new Object();hotyan.name = hotyan;hotyan.age = 18;      //永远18...</code></pre><p><br></p><blockquote><p>对象字面量</p></blockquote><pre><code>var hotyan = {  name : &quot;hotyan&quot;,  age : 18};</code></pre><p>属性名也可以使用字符串</p><pre><code>var hotyan = {  &quot;name&quot; : &quot;hotyan&quot;,  &quot;age&quot; : 18,  5 : true       //数字属性名自动转换为字符串};</code></pre><p><br></p><blockquote><p>访问对象属性【点方法/方括号表示法】</p></blockquote><pre><code>alert(hotyan.name);       //&quot;hotyan&quot;alert(hotyan[&quot;name&quot;]);    //&quot;hotyan&quot;</code></pre><p>功能上没有区别,但<span id="inline-green">方括号表示法</span>可以通过变量来访问属性</p><pre><code>var propertyName = &quot;name&quot;;alert(hotyan[propertyName]);    //&quot;hotyan&quot;</code></pre><p>属性名使用的是<span id="inline-purple">关键字</span>、<span id="inline-blue">保留字</span>或包含会导致语法错误的字符、非字母非数字时可使用方括号表示法</p><pre><code>hotyan[&quot;first name&quot;] = &quot;hotyan&quot;;    //&quot;first name&quot;包含一个空格,不能使用点方法</code></pre><p>通常,除非必须使用变量来访问属性,否则建议用点方法。</p><p><br><br><br></p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><hr><h2 id="一、原始模式"><a href="#一、原始模式" class="headerlink" title="一、原始模式"></a>一、原始模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var hotyan1 = &#123;&#125;;    //与new Object() 相同</span><br><span class="line">hotyan1.name = &quot;hotyan1&quot;;</span><br><span class="line">hotyan1.age = 18;</span><br><span class="line"></span><br><span class="line">var hotyan2 =&#123;&#125;;</span><br><span class="line">hotyan2.name = &quot;hotyan2&quot;;</span><br><span class="line">hotyan2.age = 28;</span><br></pre></td></tr></table></figure><p>最 <strong>简单</strong>的封装,把两个属性封装在一个对象里面。<br>缺点:</p><ol><li>使用同一个接口创建很多对象(创建多个实例),会产生大量 <strong>重复代码</strong>。</li><li>实例与原型之间,看不出任何联系。</li></ol><p><br></p><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><p>工厂模式是广为人知的设计模式,抽象了创建具体对象的过程。</p><p>用函数来封装 <strong>以特定接口创建对象</strong>的细节:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o =new Object();    //显示的创建对象</span><br><span class="line">    o.name = name;          </span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = createPerson(&quot;hotyan1&quot;,18,&quot;Student&quot;);</span><br><span class="line">var hotyan2 = createPerson(&quot;hotyan2&quot;,28,&quot;Engineer&quot;);</span><br></pre></td></tr></table></figure><p></p><p>解决了创建多个相似对象的问题(即解决代码重复的问题)。<br>不足:</p><ol><li><p>没有解决对象识别问题(即不知道对象的类型)</p></li><li><p>实例之间没有内在的联系,不能反映出它们是同一个原型对象的实例</p></li></ol><p><br></p><h2 id="三、构造函数模式"><a href="#三、构造函数模式" class="headerlink" title="三、构造函数模式"></a>三、构造函数模式</h2><p>构造函数本身就是一个函数,出于 <strong>创建新对象</strong>的目的而定义的。</p><p>内部使用了 <strong><code>this</code></strong> 变量,使用 <strong><code>new</code></strong> 运算符就能生成实例,并且 <strong><code>this</code></strong> 变量会绑定在实例对象上。</p><p>构造函数的函数名始终都应该以一个大写字母开头,非构造函数则应该以一个小写字母开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;  </span><br><span class="line">    /*直接将属性和方法赋给this对象*/</span><br><span class="line">    this.name = name;       </span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line"></span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;,18,&quot;Student&quot;);</span><br><span class="line">var hotyan2 = new Person(&quot;hotyan2&quot;,28,&quot;Engineer&quot;);</span><br></pre></td></tr></table></figure><p><strong><code>hotyan1</code></strong> 和 <strong><code>hotyan2</code></strong> 都有一个 <strong><code>constructor</code>(构造函数)属性</strong>,该属性指向 <strong><code>Person</code></strong> :</p><pre><code>alert(hotyan1.constructor == Person);   //truealert(hotyan2.constructor == Person);   //true</code></pre><p>对象的 <strong><code>constructor</code></strong> 属性最初是用来标识对象类型的。</p><p>但是提到检测对象类型,还是 <strong><code>instanceof</code></strong> 操作符更可靠一些:</p><pre><code>alert(hotyan1 instanceof Object);   //truealert(hotyan2 instanceof Object);   //truealert(hotyan1 instanceof Person);   //truealert(hotyan2 instanceof Person);   //true</code></pre><p>创建的对象既是Object的实例,也是Person的实例。验证了实例与原型之间的关系(即反映出它们是同一个原型对象的实例)。</p><p><br></p><blockquote><p>将构造函数当作函数</p></blockquote><p>构造函数与其他函数的唯一区别就是调用它们的方式不同。前面定义的Person()函数可以通过下列任何一种方式来调用:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1.当作构造函数使用</span><br><span class="line">var hotyan = new Person(&quot;hotyan&quot;,18,&quot;Student&quot;);</span><br><span class="line">hotyan.sayName();   //&quot;hotyan&quot;</span><br><span class="line"></span><br><span class="line">//2.作为普通函数使用</span><br><span class="line">Person(&quot;hotyan&quot;,18,&quot;Student&quot;);  //添加到window</span><br><span class="line">window.sayName();   //&quot;hotyan&quot;</span><br><span class="line"></span><br><span class="line">//3.在另一个对象的作用域中调用</span><br><span class="line">var O = new Object();</span><br><span class="line">Person.call(O, &quot;hotyan&quot;, 18, &quot;Student&quot;);</span><br><span class="line">O.sayName();   //&quot;hotyan&quot;</span><br></pre></td></tr></table></figure><p></p><ol><li>构造函数的典型用法,用new操作符来创建一个新对象。</li><li>不使用new操作符调用Person(),属性和方法都被添加window</li><li>使用call()或者apply()在某个特殊对象的作用域中调用Person()函数,O就拥有了所有属性和方法。</li></ol><p><br></p><blockquote><p>构造函数的问题</p></blockquote><p>主要问题:</p><pre><code>每个方法都要在每个实例上重新创建一遍。  </code></pre><p>不同实例上的同名函数是不相等的:</p><pre><code>alert(hotyan1.sayName == hotyan2.sayName);  //false</code></pre><p>尝试通过把函数定义转移到构造函数外部来解决问题:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = sayName; //将sayName属性设置成等于全局的sayName函数 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayName()&#123;     </span><br><span class="line">    alert(this.name);   </span><br><span class="line">&#125;                       </span><br><span class="line"></span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;,18,&quot;Student&quot;);</span><br><span class="line">var hotyan2 = new Person(&quot;hotyan2&quot;,28,&quot;Engineer&quot;);</span><br></pre></td></tr></table></figure><p></p><p><strong><code>sayName</code></strong> 包含的是一个指向函数的指针,因此 <strong><code>hotyan1</code></strong> 和 <strong><code>hotyan2</code></strong> 对象就共享了在全局作用域中定义的同一个 <strong><code>sayName()</code></strong> 函数。确实解决了两个函数做同一件事情的问题,可是新问题又来了:</p><ol><li><p>在全局作用域中定义的函数实际上只能被某个对象调用,这让全局作用域有点名不副实。</p></li><li><p>如果对象需要定义很多方法,就将定义很多个全局函数,使得自定义的引用类型丝毫没有封装性可言。</p></li></ol><p>这些问题可以通过原型模式解决！</p><p><br></p><h2 id="四、原型模式"><a href="#四、原型模式" class="headerlink" title="四、原型模式"></a>四、原型模式</h2><p>我们创建的每一个构造函数都有一个 <strong><code>prototype</code></strong> 属性,这个属性是一个 <strong>指针</strong>,指向一个 <strong>原型对象</strong>。这个原型对象的所有属性和方法，都会被构造函数的实例继承。</p><p>不必在构造函数中定义对象实例的信息,直接将信息添加到原型对象中:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">////////////后面将用...代替这部分代码/////////</span><br><span class="line">    function Person()&#123;&#125;</span><br><span class="line">    Person.prototype.name = &quot;hotyan&quot;;</span><br><span class="line">    Person.prototype.age = 18;</span><br><span class="line">    Person.prototype.job = &quot;Student&quot;;</span><br><span class="line">    Person.prototype.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">///////////到此处结束///////////////////////</span><br></pre></td></tr></table></figure><p></p><p>仍然可以通过调用构造函数来创建新对象,新对象的属性和方法是由所有实例共享的。</p><p>即 <strong><code>hotyan1</code></strong> 和 <strong><code>hotyan2</code></strong> 访问的都是同一组属性和同一个 <strong><code>sayName()</code></strong> 函数:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">hotyan1.sayName();  //&quot;hotyan&quot;</span><br><span class="line"></span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line">hotyan1.sayName();  //&quot;hotyan&quot;</span><br><span class="line"></span><br><span class="line">alert(hotyan1.sayName == hotyan2.sayName);  //true</span><br></pre></td></tr></table></figure><p></p><p>要理解原型模式的工作原理必须先理解ECMAScript中原型对象的性质。</p><p><br></p><blockquote><p>理解原型对象</p></blockquote><p>默认情况下,所有原型对象都会自动获得一个 <strong><code>constructor</code>(构造函数)属性</strong>,这个属性是一个 <strong>指针</strong>,指向 <strong><code>prototype</code>属性所在函数</strong>。</p><p>当调用构造函数创建一个新实例,内部包含一个内部属性 <strong>[[<code>Prototype</code>]]</strong>,这个属性是一个 <strong>指针</strong>,指向 <strong>构造函数的原型对象</strong>。</p><p><img src="/img/YX.png" alt=""></p><p>虽然在所有现实中都无法访问到 <strong>[[<code>Prototype</code>]]</strong>,可以通过 <strong><code>isPrototypeOf()</code></strong> 来确定对象之间是否存在这种关系:</p><pre><code>alert(Person.prototype.isPrototypeOf(hotyan1));     //truealert(Person.prototype.isPrototypeOf(hotyan2));     //true</code></pre><p>ECMAScript 5新增<code>Object.getPrototypeOf()</code>,返回[[<code>Prototype</code>]]的值:</p><pre><code>alert(Object.getPrototypeOf(hotyan1) == Person.prototype);  //truealert(Object.getPrototypeOf(hotyan1).name);  //&quot;hotyan&quot;</code></pre><p><br></p><blockquote><p>属性屏蔽</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">hotyan1.name = &quot;hotyanhotyan&quot;;  //为对象实例添加name属性,将屏蔽原型对象中的同名属性。</span><br><span class="line">alert(hotyan1.name);    //&quot;hotyanhotyan&quot; --来自实例</span><br><span class="line">alert(hotyan2.name);    //&quot;hotyan&quot; --来自原型</span><br></pre></td></tr></table></figure><p>在实例中添加<code>name</code>属性只会 <strong>阻止</strong>我们访问原型中的同名属性,即使将<code>name</code>属性设置为<code>null</code>,也只会在实例中设置属性值为<code>null</code>,而不会恢复其指向原型的连接。必须使用 <strong><code>delete</code>操作符</strong>完全删除实例属性才能重新访问原型中的属性:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">hotyan1.name = &quot;hotyanhotyan&quot;;  //为对象实例添加name属性,将屏蔽原型对象中的同名属性。</span><br><span class="line">alert(hotyan1.name);    //&quot;hotyanhotyan&quot; --来自实例</span><br><span class="line">alert(hotyan2.name);    //&quot;hotyan&quot; --来自原型</span><br><span class="line"></span><br><span class="line">delete hotyan1.name;    //!!!!!!!!!!!</span><br><span class="line">alert(hotyan1.name);    //&quot;hotyan&quot; --来自原型</span><br></pre></td></tr></table></figure><p></p><p>使用 <strong><code>hasOwnPrototype()</code></strong> 方法可检测一个属性存在于实例还是原型。存在实例时返回true:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line"></span><br><span class="line">hotyan1.name = &quot;hotyanhotyan&quot;;  //重写name属性</span><br><span class="line">alert(hotyan1.name);            //&quot;hotyanhotyan&quot;--来自实例</span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //true</span><br><span class="line"></span><br><span class="line">alert(hotyan2.name);            //&quot;hotyan&quot;--来自原型</span><br><span class="line">alert(hotyan2.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line"></span><br><span class="line">delete hotyan1.name;</span><br><span class="line">alert(hotyan1.name);            //&quot;hotyan&quot;--来自原型</span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //false</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><p>原型与in操作符</p></blockquote><p>单独使用时, <strong>in操作符</strong>会在通过对象能够访问给定属性时返回true:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line">alert(&quot;name&quot; in hotyan1);       //true</span><br><span class="line"></span><br><span class="line">hotyan1.name = &quot;hotyanhotyan&quot;;  //重写name属性</span><br><span class="line">alert(hotyan1.name);            //&quot;hotyanhotyan&quot;--来自实例</span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //true</span><br><span class="line">alert(&quot;name&quot; in hotyan1);       //true</span><br><span class="line"></span><br><span class="line">alert(hotyan2.name);            //&quot;hotyan&quot;--来自原型</span><br><span class="line">alert(hotyan2.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line">alert(&quot;name&quot; in hotyan2);       //true</span><br><span class="line"></span><br><span class="line">delete hotyan1.name;</span><br><span class="line">alert(hotyan1.name);            //&quot;hotyan&quot;--来自原型</span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line">alert(&quot;name&quot; in hotyan1);       //true</span><br></pre></td></tr></table></figure><p></p><p>无论该属性存在于实例中还是存在于原型中,始终都返回true。</p><p>同时使用 <strong><code>hasOwnPrototype()</code></strong> 方法和 <strong>in操作符</strong>,就可以确定该属性是存在于对象中,还是存在于原型中:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hasPrototypePrototy(object,name)&#123;</span><br><span class="line">    return !object.hasOwnProperty(name) &amp;&amp; (name in object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>name in object</code>–通过对象能访问到属性时返回true;</p><p><code>hasOwnPrototype()</code>–属性存在于实例中时返回true;</p><p><code>!hasOwnPrototype()</code>–属性存在于原型中时返回true;</p><p>因此,只要 <strong><code>hasPrototypePrototy()</code></strong> 返回 <strong><code>true</code></strong> ,可以确定属性存在于 <strong>原型</strong>:</p><pre><code>...var hotyan1 = new Person();alert(hasPrototyprPrototy(hotyan1, &quot;name&quot;));    //truehotyan1.name = &quot;hotyanhotyan&quot;;//重写name属性alert(hasPrototyprPrototy(hotyan1, &quot;name&quot;));    //false</code></pre><p><br></p><blockquote><p>更简单的原型语法</p></blockquote><p>每添加一个属性或方法,就要重复一遍 <strong><code>Person.prototype</code></strong>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.name = &quot;hotyan&quot;;</span><br><span class="line">Person.prototype.age = 18;</span><br><span class="line">Person.prototype.job = &quot;Student&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>减少不必要输入的同时,从视觉上更好的封装整个原型,用对象字面量来 <strong>重写</strong>整个原型对象:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;hotyan&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Student&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><strong><code>Person.prototype</code></strong> 等于一个以对象字面量形式创建的新对象,结果相同。</p><p>但是 <strong><code>constructor</code>属性</strong>不再指向 <strong><code>Person</code></strong> (指向 <strong><code>Object</code>构造函数</strong>):</p><pre><code>...var hotyan1 = new Person();alert(hotyan1.constructor == Person);   //falsealert(hotyan1.constructor == Object);   //true</code></pre><p>如果 <strong><code>constructor</code>的值</strong> 真的非常重要,可以特意设置回适当的值:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,   //值设为Person</span><br><span class="line">    name : &quot;hotyan&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Student&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><p>原型的动态性</p></blockquote><p>对原型对象所做的任何修改都可以立即从实例对象上反映出来,即使是 <strong>先创建实例后修改原型对象</strong>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();     //新建Person实例保存在hotyan1中</span><br><span class="line">Person.prototype.sayHi = function()&#123;    //给原型对象新添sayHi()方法</span><br><span class="line">    alert(&quot;hi&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">hotyan1.sayHi();    //&quot;hi&quot;--仍然可以访问sayHi()方法</span><br></pre></td></tr></table></figure><p></p><p>其原因归结于 <strong>实例与原型之间的松散连接关系</strong>。</p><p>但是如果是重写整个原型对象,情况就不一样了:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">var hotyan1 = new Person();     //新建Person实例保存在hotyan1中</span><br><span class="line">Person.prototype = &#123;            //重写整个原型对象</span><br><span class="line">    constructor : Person,       //值设为Person</span><br><span class="line">    name : &quot;hotyan&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Student&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">hotyan1.sayName();      //error</span><br></pre></td></tr></table></figure><p></p><p>重写原型对象</p><p>切断了构造函数与最初原型之间的联系(即构造函数指向了重写的新原型),</p><p>切断了之前已经存在的实例与新原型之间的关系(即之前已经存在的实例仍然指向最初的原型)。</p><p><img src="/img/RWYX.png" alt=""></p><p><br></p><blockquote><p>原生对象的原型</p></blockquote><p>原型模式的重要性不仅体现在 <strong>创建自定义类型</strong>,所有原生的引用类型(<code>Object、Array、String...</code>)都采用原型模式创建。</p><p>通过原生对象的原型,不仅可以 <strong>取得所有默认方法的引用</strong>,而且可以 <strong>定义新方法</strong>。(但不推荐！)</p><p><br></p><blockquote><p>原型对象的问题</p></blockquote><ol><li><p>省略了为构造函数传递的初始化参数,导致所有实例在默认情况下拥有相同的属性值。(不是最大问题)</p></li><li><p>原型中的属性和方法是被所有实例共享的,对于函数非常适合,对于包含基本值得属性倒也说的过去(可以重写属性),对于包含引用类型值得属性来说,问题比较突出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;hotyan&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Student&quot;,</span><br><span class="line">    friends :[&quot;A&quot;, &quot;B&quot;],</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">hotyan1.friends.push(&quot;C&quot;);      //向hotyan1添加了好友C</span><br><span class="line">alert(hotyan1.friends);     //&quot;A,B,C&quot;</span><br><span class="line">alert(hotyan2.friends);     //&quot;A,B,C&quot;--结果hotyan2也一同被修改</span><br><span class="line">alert(hotyan1.friends === hotyan2.friends);//true</span><br></pre></td></tr></table></figure></li></ol><pre><code>这个问题也是我们很少看见有人 **单独使用原型模式**的原因所在！！</code></pre><p><br></p><h2 id="五、构造函数和原型混合模式"><a href="#五、构造函数和原型混合模式" class="headerlink" title="五、构造函数和原型混合模式"></a>五、构造函数和原型混合模式</h2><p>是创建自定义类型最常见的方式。构造函数模式:定义实例属性;原型模式:定义共享属性和方法。</p><p>还支持向构造函数传递参数,可谓集两种模式之长:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;A&quot;, &quot;B&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;, 18, &quot;Student&quot;);</span><br><span class="line">var hotyan2 = new Person(&quot;hotyan2&quot;, 28, &quot;Engineer&quot;);</span><br><span class="line"></span><br><span class="line">hotyan1.friends.push(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">alert(hotyan1.friends);     //&quot;A,B,C&quot;</span><br><span class="line">alert(hotyan2.friends);     //&quot;A,B&quot;</span><br><span class="line">alert(hotyan1.friends === hotyan2.friends);     //false</span><br><span class="line">alert(hotyan1.sayName === hotyan2.sayName);     //true</span><br></pre></td></tr></table></figure><p></p><p>这种构造函数与原型混成的模式,是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说是用来 <strong>定义引用类型的一种默认模式</strong>。</p><p><br></p><h2 id="六、动态原型模式"><a href="#六、动态原型模式" class="headerlink" title="六、动态原型模式"></a>六、动态原型模式</h2><p>把所有信息都封装到构造函数中,通过在构造函数中初始化原型(必要情况下)。</p><p>保存了同时使用构造函数和原型的优点:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line"></span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;, 18, &quot;Student&quot;);</span><br><span class="line">hotyan1.sayName();      //&quot;hotyan1&quot;</span><br></pre></td></tr></table></figure><p></p><p>使用动态原型模式时,不能使用对象字面量重写原型对象(重写原型会切断现有实例与新原型之间的联系,即现有实例仍然指向最初的原型)。</p><p><br></p><h2 id="七、寄生构造函数模式"><a href="#七、寄生构造函数模式" class="headerlink" title="七、寄生构造函数模式"></a>七、寄生构造函数模式</h2><p>基本思想是创建一个函数,函数作用仅仅是封装创建对象的代码,然后返回新创建的对象:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;, 18, &quot;Student&quot;);</span><br><span class="line">hotyan1.sayName();      //&quot;hotyan1&quot;</span><br></pre></td></tr></table></figure><p></p><p>除了使用 <strong><code>new</code>操作符</strong> 创建实例并把封装函数叫做构造函数外,这个模式跟工厂模式一模一样。</p><p>不能依赖 <strong><code>insatnceof</code>操作符</strong> 来确定对象类型(返回的对象与构造函数或者够着函数的原型属性之间没有关系,即返回的对象相对于在构造函数外部创建的对象),能使用其他模式的情况下,就不使用寄生构造函数模式。</p><p><br></p><h2 id="八、稳妥构造函数模式"><a href="#八、稳妥构造函数模式" class="headerlink" title="八、稳妥构造函数模式"></a>八、稳妥构造函数模式</h2><p>所谓稳妥对象,指没有公共属性,方法也不引用this对象。与寄生构造函数类似,但有两点不同:</p><ol><li><p>新创建对象的实例方法不引用this;</p></li><li><p>不使用new操作符调用构造函数(来创建实例)。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = Person(&quot;hotyan1&quot;, 18, &quot;Student&quot;);</span><br><span class="line">hotyan1.sayName();      //&quot;hotyan1&quot;</span><br></pre></td></tr></table></figure><p>不能依赖 <strong><code>insatnceof</code>操作符</strong>来确定对象类型(返回的对象与构造函数或者够着函数的原型属性之间没有关系,即返回的对象相对于在构造函数外部创建的对象),稳妥构造函数提供的安全性非常适合在某些安全执行环境(ADsafe、Caja)下使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解并创建对象-待完善&quot;&gt;&lt;a href=&quot;#理解并创建对象-待完善&quot; class=&quot;headerlink&quot; title=&quot;理解并创建对象 [待完善]&quot;&gt;&lt;/a&gt;理解并创建对象 &lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="面向对象编程" scheme="https://hotkang.cn/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="封装" scheme="https://hotkang.cn/tags/%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象编程一</title>
    <link href="https://hotkang.cn/2018/07/26/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%80/"/>
    <id>https://hotkang.cn/2018/07/26/JavaScript面向对象编程一/</id>
    <published>2018-07-26T07:04:41.000Z</published>
    <updated>2018-07-27T15:49:02.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解面向对象编程-待完善"><a href="#理解面向对象编程-待完善" class="headerlink" title="理解面向对象编程 [待完善]"></a>理解面向对象编程 <span style="font-size:.5em">[待完善]</span></h2><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><p><br><br><br></p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><hr><ol><li><h5 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h5><p>大概就是下面说的这样:</p><blockquote><p>面向对象是相对于面向过程的,比如你要充话费,你会想,下个支付宝,注册并登录,绑定银行卡,充值。这种种过程。但是对于你女朋友就不一样了,她是面向“对象”的,她会想,谁会充话费呢？当然是你了,她就给你电话,然后你把之前的做了一遍,然后她收到充值成功的短信,说了句,么么哒。这就是面向对象！女的思维大部分是面向“对象”的！她不关心处理的细节,只关心谁可以,和结果!</p></blockquote></li></ol><ol start="2"><li><h5 id="两个基本概念"><a href="#两个基本概念" class="headerlink" title="两个基本概念"></a>两个基本概念</h5><blockquote><p>类</p></blockquote><p><strong>类是对象的类型模板</strong>。例如:定义Student类来表示学生,类本身是一种类型,Student表示学生类型,但不表示任何具体的某个学生。</p><blockquote><p>实例</p></blockquote><p><strong>实例是根据类创建的对象</strong>。例如:根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例,每个实例表示一个具体的学生,他们全都属于Student类型。</p></li><li><h5 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h5><blockquote><p>封装</p></blockquote><p>把客观事物封装成抽象的类,并且类可以把自己的数据和方法只让可信的类或者对象操作,对不可信的进行信息隐藏。</p><blockquote><p>继承</p></blockquote><p>指这样一种能力:它可以使用现有类的所有功能,并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><blockquote><p>多态</p></blockquote><p>允许将子类类型的指针赋值给父类类型的指针。实现多态:覆盖、重载。</p><p><a href="https://www.jianshu.com/p/50999d81eeb5" target="_blank" rel="noopener">查看更多&gt;&gt;</a></p></li></ol><p><br><br><br></p><h3 id="JavaScript面向对象编程"><a href="#JavaScript面向对象编程" class="headerlink" title="JavaScript面向对象编程"></a>JavaScript面向对象编程</h3><hr><p>JS的面向对象编程和其它大多数语言如Java、C#的面向对象编程都不太一样。</p><p>JS不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p><p>JS的原型链和Java的Class区别在于JS没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p><p><br><br><br></p><h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><hr><p>每个函数都是Function类型的实例,都与其他引用类型一样具有属性和方法。</p><p>函数实际上是对象,函数名实际上是一个指向函数对象的指针,不会与某个函数绑定。</p><ol><li><h5 id="定义函数的三种方式"><a href="#定义函数的三种方式" class="headerlink" title="定义函数的三种方式"></a>定义函数的三种方式</h5><blockquote><p><strong>函数声明:</strong></p></blockquote><pre><code>function sum (num1, num2){    return num1 + num2;}</code></pre><blockquote><p><strong>函数表达式:</strong></p></blockquote><pre><code>var sum = function(num1, num2){    return num1 + num2;};  //注意此处有分号</code></pre></li></ol><pre><code>&gt;**Function构造函数:**        var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);不推荐!因为构造函数定义导致 **解析两次代码**影响性能:- 第一次是解析常规ECMAScript代码;- 第二次是解析传入构造函数中的字符串。</code></pre><p><br></p><ol start="2"><li><h5 id="一个函数可能有多个名字"><a href="#一个函数可能有多个名字" class="headerlink" title="一个函数可能有多个名字"></a>一个函数可能有多个名字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2)&#123;      //定义一个sum()函数用于求两盒个值得和</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(10,10));  //20</span><br><span class="line"></span><br><span class="line">var anotherSum = sum;       //声明变量anotherSum,设置其与sum相等(即他们都指向了同一个函数)。</span><br><span class="line">alert(anotherSum(10,10));   //20--正常调用anotherSum()</span><br><span class="line"></span><br><span class="line">sum = null;                 //将sum设置为null,让它与函&quot;数断绝关系&quot;</span><br><span class="line">alert(anotherSum(10,10));   //20--正常调用anotherSum()</span><br></pre></td></tr></table></figure><p><strong>函数名仅仅是指向函数的指针</strong>,函数名与 <strong>包含对象指针的</strong>其他变量没有什么不同。</p></li></ol><p><br></p><ol start="3"><li><h5 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h5><p>其他语言(如Java)可以为一个函数编写两个定义,只要两个定义的 <strong>签名(参数的类型和数量)</strong> 不同即可。</p><p>ECMAScript函数的参数是 <strong>0或多个值的数组</strong>,故没有函数签名。</p><p>没有函数签名,真正的重载是不可能做到的。</p><p>声明了两个同名函数,结果则是后面的函数覆盖了前面的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addSum(num)&#123;</span><br><span class="line">    return num + 100;</span><br><span class="line">&#125;</span><br><span class="line">function addSum(num)&#123;</span><br><span class="line">    return num + 200;</span><br><span class="line">&#125;</span><br><span class="line">var result = addSum(100);   //300</span><br></pre></td></tr></table></figure><p>将函数名想象为指针有助于理解为什么ECMAScript中没有函数重载概念。</p></li></ol><p><br></p><h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在执行环境中加载数据时,对函数声明和函数表达式并非一视同仁。</p><p>解析器会率先读取 <strong><code>函数声明</code></strong>,并使其在执行任何代码之前可用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(10, 10));     //20</span><br><span class="line">function sum(sum1, sum2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码开始执行前,解析器就通过 <strong>函数声明提升</strong>读取并将函数声明添加到执行环境中。对代码求值时,JS引擎在第一遍会声明函数并将它们放到源代码树的顶部。</p><p><strong><code>函数表达式</code></strong> 必须等到解析器执行到它所在的代码行才会真正被解释执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(10, 10));     //&quot;unexpected identifier&quot;(意外标识符)错误</span><br><span class="line">var sum = function(sum1, sum2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除了什么时候可以通过变量访问函数这一点区别外,函数声明和函数表达式的语法是等价的！</strong></p><p><br></p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>ECMAScript中函数名本身就是变量,所以函数也可以作为值来使用。即不仅可以像传递参数一样把一个函数传递给另一个函数,而且可以将函数作为另一个函数的结果返回。</p><p>要访问函数的指针而不执行函数的话,必须去掉函数名后面的那对大括号。</p><p><br></p><h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>函数内部有两个特殊的对象: <strong><code>arguments</code></strong> 和 <strong><code>this</code></strong>。</p><blockquote><p><strong><code>arguments</code>:</strong></p></blockquote><ul><li><p>类数组对象,保存函数参数。</p></li><li><p>可使用 <strong>方括号语法</strong>访问它的每个元素。</p></li><li>可用length属性来确定传递参数的个数。</li><li>可与命名参数一起使用。</li><li>值永远与对应命名参数的值保持同步。</li></ul><p><code>arguments</code>有一个<code>callee</code>指针属性,指向拥有这个<code>arguments</code>对象的函数。</p><p>经典的阶乘函数,在函数有名字且以后不会改变的情况下,这样定义没有问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1) </span><br><span class="line">        return 1;</span><br><span class="line">    else </span><br><span class="line">        return num * factorial(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个函数的执行与函数<code>factorial</code>紧紧耦合在了一起。可使用<code>arguments.callee</code>来消除紧密耦合现象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1) </span><br><span class="line">        return 1;</span><br><span class="line">    else </span><br><span class="line">        return num * arguments.callee(num-1);</span><br><span class="line">&#125;</span><br><span class="line">var trueFactorial = factorial;</span><br><span class="line"></span><br><span class="line">factorial = function()&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(trueFactorial(5));    //120</span><br><span class="line">alert(factorial(5));        //0</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>this</code>:</strong></p></blockquote><p><code>this</code>引用的是函数执行的环境对象(即<code>this</code>值)。当在网页的全局作用域中调用函数时,<code>this</code>对象引用的就是<code>window</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color : &quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();     //&quot;red&quot;--引用对象是window</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();       //&quot;blue&quot;--引用对象是o</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>caller</code>:</strong></p></blockquote><p>ECMAScript 5规范化了的一个函数对象属性。保存着 <strong>调用当前函数</strong> 的 <strong>函数的引用</strong>。如果是在全局作用域中调用当前函数,它的值为null。</p><blockquote><p>定义<code>arguments.callee</code>属性是为了分清<code>arguments.caller</code>和函数的<code>caller</code>属性。</p><p>严格模式下,访问<code>arguments.callee</code>会导致错误。访问<code>arguments.caller</code>(ECMAScript 5定义)也会导致错误,非严格模式下,<code>arguments.caller</code>属性始终是<code>undefined</code>。</p><p>严格模式还有一个限制:不能为函数<code>caller</code>属性赋值,否则会导致错误。</p></blockquote><p><br></p><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><blockquote><p>属性:<code>length</code></p></blockquote><p>每个函数都包含两个属性:<code>length</code>和<code>prototype</code>。<code>length</code>属性表示函数希望接收的命名参数的个数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayName(name)&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">alert(sayName.length);  //1</span><br><span class="line">alert(sum.length);  //2</span><br><span class="line">alert(sayHi.length);  //0</span><br></pre></td></tr></table></figure><blockquote><p>方法:<code>apply()</code></p></blockquote><p>每个函数都包含两个非继承而来的方法: <strong><code>apply()</code></strong> 和 <strong><code>call()</code></strong> 。可在特定的作用域中调用函数(即设置函数体内<code>this</code>对象的值)。</p><p>apply()方法接收两个参数:</p><ul><li><p>在其中运行函数的的作用域:<code>this</code>的引用对象</p></li><li><p>参数数组:<code>Array</code>实例、<code>arguments</code>对象</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function applySum1(num1, num2)&#123;</span><br><span class="line">    return sum.apply(this, arguments);      //传入arguments</span><br><span class="line">&#125;</span><br><span class="line">function applySum2(num1, num2)&#123;</span><br><span class="line">    return sum.apply(this, [num1, num2]);       //传入数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(applySum1(10, 10));        //20</span><br><span class="line">alert(applySum2(10, 15));        //25</span><br></pre></td></tr></table></figure><blockquote><p>方法:<code>call()</code></p></blockquote><p><code>call()</code>和<code>apply()</code>方法作用相同,区别在于接收参数方式不同。<code>call()</code>传递给函数的参数必须逐个列举出来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1, num2)&#123;</span><br><span class="line">    return sum.call(this, num1, num2);      </span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(10, 10));        //20</span><br></pre></td></tr></table></figure><p><br>传递参数并非<code>call</code>和<code>apply</code>的真正用武之地,真正强大的地方是能够扩充函数赖以运行的作用域:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color : &quot;blue&quot;&#125;;</span><br><span class="line"></span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();     //&quot;red&quot;--window.color</span><br><span class="line"></span><br><span class="line">sayColor().call(this);       //&quot;red&quot;</span><br><span class="line">sayColor().call(window);       //&quot;red&quot;</span><br><span class="line">sayColor().call(o);       //&quot;blue&quot;</span><br></pre></td></tr></table></figure><p>扩充作用域的最大好处:对象不需要与方法有任何耦合关系。可省去此步骤: <code>o.sayColor = sayColor;</code></p><blockquote><p>方法:<code>bind()</code></p></blockquote><p>调用<code>bind()</code>会创建一个函数实例,其this值会被绑定到 <strong>传给bind()函数</strong>的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color : &quot;blue&quot;&#125;;</span><br><span class="line"></span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();       //&quot;blue&quot;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h2><blockquote><p>创建一个类</p></blockquote><p>声明一个函数(类)保存在一个变量里,一般将这个代表类的变量名首字母大写。在函数(类)的内部通过this(函数内部自带的一个变量,用于指向当前这个对象)变量添加属性和方法来实现对函数(类)添加属性和方法:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Book = function(id,name,price)&#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.price = price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><p>属性与方法封装</p></blockquote><p><br></p><blockquote><p>闭包实现</p></blockquote><p><br></p><blockquote><p>创建对象的安全模式</p></blockquote><p>待完善…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解面向对象编程-待完善&quot;&gt;&lt;a href=&quot;#理解面向对象编程-待完善&quot; class=&quot;headerlink&quot; title=&quot;理解面向对象编程 [待完善]&quot;&gt;&lt;/a&gt;理解面向对象编程 &lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="面向对象编程" scheme="https://hotkang.cn/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="继承" scheme="https://hotkang.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="https://hotkang.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="封装" scheme="https://hotkang.cn/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="多态" scheme="https://hotkang.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Notes_CSS</title>
    <link href="https://hotkang.cn/2018/07/24/Notes-CSS/"/>
    <id>https://hotkang.cn/2018/07/24/Notes-CSS/</id>
    <published>2018-07-23T17:46:39.000Z</published>
    <updated>2018-07-23T19:29:26.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-CSS-持续更新"><a href="#关于-CSS-持续更新" class="headerlink" title="关于 CSS  [持续更新]"></a>关于 CSS <span style="font-size:.5em">[持续更新]</span></h2><p><img src="/img/CSS.jpg" alt=""></p><a id="more"></a><p></p><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><p><strong>content、padding、border、margin</strong><br>标准盒模型:</p><pre><code>content.width = content </code></pre><p>IE盒模型:</p><pre><code>content.width = content + padding + border </code></pre><p>设置盒模型：</p><pre><code>box-sizing:content-box | border-box</code></pre><p></p><h2 id="边距重叠"><a href="#边距重叠" class="headerlink" title="边距重叠"></a>边距重叠</h2><p>兄弟元素，外边距取绝对值大的<br></p><h2 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC - 块级格式化上下文"></a>BFC - 块级格式化上下文</h2><blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></blockquote><pre><code>页面上的一个独立容器，容器里面的子元素与外面的元素互不影响；BFC内部的盒子，会在垂直方向，一个接一个地放置。垂直方向上也会发生边距重叠。BFC的区域不会与float box重叠。计算BFC的高度时，浮动元素也被计算在内。</code></pre><blockquote><h3 id="如何产生"><a href="#如何产生" class="headerlink" title="如何产生"></a>如何产生</h3></blockquote><pre><code>1. overflow:auto | hidden 2. position: absolute | fixed3. float: left | right  4. display: inline-block | table-cell |table-caption | flex | inline-flex  5. clear: both</code></pre><blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3></blockquote><pre><code>1.自适应布局：两栏布局，左边固定，右边自适应2.清除浮动3.解决垂直边距重叠4.float 坍塌问题5.文字浮动问题</code></pre><h2 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h2><pre><code>内联样式: 1000ID: 100类、属性、伪类:10标签、伪元素: 1</code></pre><h2 id="引入CSS样式及优先级"><a href="#引入CSS样式及优先级" class="headerlink" title="引入CSS样式及优先级"></a>引入CSS样式及优先级</h2><pre><code>内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 导入样式  </code></pre><h2 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h2><pre><code>绝对单位： cm mm in pt pc相对单位：  px ：不考虑分辨率，当做绝对单位对待  % ：  em ：相对当前元素（首行缩进用text-indent：2em；）   rem ：相对于根元素(常用于移动端)视窗单位：   vh :视窗高度的百分比  vw   vmin ：vw vh中较小的一个  vmax ：vw vh中较大的一个% 相对于谁：  以父元素容器 **宽** 为基准：padding、margin、width  以父元素容器 **高** 为基准：height 、定位元素  以自身：translate</code></pre><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><blockquote><p>行级元素</p></blockquote><pre><code>父级 {        text-align: center ;  }   </code></pre><blockquote><p>块级元素</p></blockquote><pre><code>当前元素 {      margin: 0 auto ;  }</code></pre><blockquote><p>子元素浮动</p></blockquote><pre><code>父级 {    width:fit-content;      margin:0 auto;}  </code></pre><blockquote><p>flex 2012</p></blockquote><pre><code>子元素 {      display:flex;      justify-content:center; }  </code></pre><blockquote><p>绝对定位 + transform</p></blockquote><pre><code>子元素 {      position:absolute;      left:50%;      transform:translate（-50% ,0）;  }  </code></pre><blockquote><p>定宽 + 绝对定位 + 负值</p></blockquote><pre><code>子元素 {      left:50%;      margin-left:-0.5*宽度;  }   </code></pre><blockquote><p>定宽 + 绝对定位</p></blockquote><pre><code>子元素 {      left:0;      right:0;      margin:0 auto;  }</code></pre><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><blockquote><p>单行文本</p></blockquote><pre><code>当前元素 {         line-height:父级元素高度 ; }</code></pre><blockquote><p>行内块级元素</p></blockquote><pre><code>父级元素:after 当前元素{        display: inline-block;        vertical-align: middle;  }  </code></pre><blockquote><p>元素高度不定</p></blockquote><pre><code>  父元素: {          display:table;    }    当前元素 {          display: table-cell;        vertical-align:middle;    }  元素内容不会被截断 </code></pre><blockquote><p>元素高度固定</p></blockquote><pre><code>父级{        position:relative;  }  当前元素{        height:固定;        position:absolute;        top:50%;        margin-top:-0.5*高度；  }|{        height:固定;       position:absolute;         top:0;        bottom:0;        margin: auto 0;  }</code></pre><blockquote><p>Flex 2012</p></blockquote><pre><code>父级元素{      display:flex;      algin-items:center;  } </code></pre><blockquote><p>transform</p></blockquote><pre><code>父级{      position:relative;  }   当前元素{      position:absolute;      top:50%;      transform:translate(-50% , -50%);  }</code></pre><h2 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h2><p>[待完善]</p><h2 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h2><blockquote><p>伪类：效果可以通过添加实际类实现，只要不是互斥可以叠加使用，优先级与类相同</p></blockquote><blockquote><p>伪元素：效果可以通过添加实际元素来实现，在一个选择器中只能出现一次，且只能出现在末尾，优先级与标签相同</p></blockquote><blockquote><p>本质区别：是否抽象创造了新元素</p></blockquote><hr><p><a href="http://www.bslxx.com/m/view.php?aid=1217" target="_blank" rel="noopener">More&gt;&gt;</a></p><h2 id="html5为什么只需要写-lt-doctype-html-gt"><a href="#html5为什么只需要写-lt-doctype-html-gt" class="headerlink" title="html5为什么只需要写&lt;!doctype html&gt;"></a>html5为什么只需要写<code>&lt;!doctype html&gt;</code></h2><pre><code>html5不是基于sgml（标准通用标记语言），不需要对dtd文件进行引用，但是需要doctype来规范浏览器的行为，否则浏览器将开启怪异模式。而html4.01基于sgml，需要引入dtd，才能告知浏览器文档使用的文档类型</code></pre><h2 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h2><p>同:都是外部引用CSS的方式</p><p>异</p><table><thead><tr><th style="text-align:center">link</th><th style="text-align:left">@import</th></tr></thead><tbody><tr><td style="text-align:center">XHTML标签,除加载CSS,还可以定义RSS等其他事务</td><td style="text-align:left">属于CSS范畴，只能加载CSS</td></tr><tr><td style="text-align:center">引用CSS时，在页面载入时同时加载</td><td style="text-align:left">需要页面网页完全载入以后加载</td></tr><tr><td style="text-align:center">XHTML标签，无兼容问题</td><td style="text-align:left">CSS2.1提出,低版本的浏览器不支持</td></tr><tr><td style="text-align:center">支持使用Javascript控制DOM去改变样式</td><td style="text-align:left">不支持Javascript控制DOM去改变样式</td></tr></tbody></table><h2 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h2><table><thead><tr><th style="text-align:center">内核</th><th style="text-align:left">浏览器</th></tr></thead><tbody><tr><td style="text-align:center">Trident</td><td style="text-align:left"><strong>IE</strong>、Maxthon、TT、The World等</td></tr><tr><td style="text-align:center">Gecko</td><td style="text-align:left">Netcape6及以上版本、<strong>FireFox</strong>、MozillaSuite/SeaMonkey</td></tr><tr><td style="text-align:center">Presto</td><td style="text-align:left"><strong>Opera7及以上版本</strong></td></tr><tr><td style="text-align:center">Webkit</td><td style="text-align:left">Safari、<strong>Chrome</strong></td></tr></tbody></table><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于-CSS-持续更新&quot;&gt;&lt;a href=&quot;#关于-CSS-持续更新&quot; class=&quot;headerlink&quot; title=&quot;关于 CSS  [持续更新]&quot;&gt;&lt;/a&gt;关于 CSS &lt;span style=&quot;font-size:.5em&quot;&gt;[持续更新]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/CSS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="CSS" scheme="https://hotkang.cn/tags/CSS/"/>
    
      <category term="Notes" scheme="https://hotkang.cn/tags/Notes/"/>
    
      <category term="面试" scheme="https://hotkang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Notes_JS</title>
    <link href="https://hotkang.cn/2018/07/24/Notes-JS/"/>
    <id>https://hotkang.cn/2018/07/24/Notes-JS/</id>
    <published>2018-07-23T17:46:27.000Z</published>
    <updated>2018-07-26T08:27:03.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于JS-持续更新"><a href="#关于JS-持续更新" class="headerlink" title="关于JS [持续更新]"></a>关于JS <span style="font-size:.5em">[持续更新]</span></h2><p><img src="/img/JS.jpg" alt=""></p><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">MDN_重新介绍JavaScript</a></p></blockquote><h2 id="日常小结"><a href="#日常小结" class="headerlink" title="日常小结"></a>日常小结</h2><blockquote><h3 id="JS定义"><a href="#JS定义" class="headerlink" title="JS定义"></a>JS定义</h3></blockquote><ul><li><p>JavaScript是一种弱类型、动态的、解释型的脚本语言</p></li><li><p>JavaScript是客户端和服务器端脚本语言</p></li><li><p>JavaScript也是面向对象编程语言</p></li></ul><blockquote><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3></blockquote><ol><li><p>ECMAScript</p></li><li><p>DOM:文档对象模型</p></li><li><p>BOM:浏览器对象模型</p></li></ol><blockquote><h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3></blockquote><ol><li><p>基本类型:string、number、boolean、nudefined、null</p></li><li><p>复杂数据类型（引用数据类型）:Object、Function、Array、Data、RegExp…</p></li><li><p>typeof:判断基本数据类型</p></li><li><p>Object.prototype.toString.call():判断对象属于哪种内置对象类型</p></li><li><p>instanceof:判断构造函数原型</p></li></ol><blockquote><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3></blockquote><ol><li><p>JavaScript是一种弱类型、动态的、解释型的脚本语言</p><pre><code>强|弱类型:类型检查 严格|不严格，偏向于 不容忍|容忍 隐式转换动态类型：运行的时候执行类型检查静态类型：编译的时候就知道每个变量的类型解释型：不需要编译，在运行的时候才翻译成机器语言，执行一次翻译一次，故效率低，跨平台性好；编译型：需编译为机器语言的文件，运行时直接使用编译的结果；标记语言：被动，不具备与访问者互动的能力；脚本语言：编程语言：</code></pre></li><li><p>js代码解析原则</p><pre><code>第一个步骤是解释，先通篇扫描所有的Js代码，然后把所有变量声明提升到该作用域顶端第二个步骤是执行</code></pre></li><li><p>函数提升在变量提升之上</p></li></ol><blockquote><h3 id="typeof返回哪些数据类型"><a href="#typeof返回哪些数据类型" class="headerlink" title="typeof返回哪些数据类型"></a>typeof返回哪些数据类型</h3></blockquote><ul><li>Object</li><li>number</li><li>function</li><li>boolean</li><li>undefind</li></ul><blockquote><h3 id="3种强制类型转换"><a href="#3种强制类型转换" class="headerlink" title="3种强制类型转换"></a>3种强制类型转换</h3></blockquote><ul><li>parseInt</li><li>parseFloat</li><li>number</li></ul><blockquote><h3 id="2种隐式转换"><a href="#2种隐式转换" class="headerlink" title="2种隐式转换"></a>2种隐式转换</h3></blockquote><ul><li>==</li><li>===</li></ul><blockquote><h3 id="split-）"><a href="#split-）" class="headerlink" title="split(）"></a>split(）</h3></blockquote><ul><li>切割成数组的形式</li></ul><blockquote><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3></blockquote><ul><li>将数组转换成字符串</li></ul><blockquote><h3 id="IE和DOM事件流的区别"><a href="#IE和DOM事件流的区别" class="headerlink" title="IE和DOM事件流的区别"></a>IE和DOM事件流的区别</h3></blockquote><ul><li>执行顺序不一样、</li><li>参数不一样</li><li>事件加不加on</li><li>this指向问题</li></ul><blockquote><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3></blockquote><h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><ol><li>null是一个表示”无”的对象，转为数值时为0;</li><li>null表示”没有对象”，即该处不应该有值;<ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul></li></ol><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><ol><li><p>undefined是一个表示”无”的原始值，转为数值时为NaN。</p></li><li><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</p><ul><li>变量被声明了，但没有赋值时，就等于undefined。</li></ul><ul><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ul></li></ol><blockquote><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3></blockquote><p>进入”严格模式”的标志，老版本的浏览器会把它当作一行普通字符串，加以忽略</p><blockquote><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4></blockquote><ol><li>将”use strict”放在<strong>脚本文件的第一行</strong>，则整个脚本都将以”严格模式”运行。</li><li>将”use strict”放在<strong>函数体的第一行</strong>，则整个函数以”严格模式”运行</li></ol><p>因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将<strong>整个脚本文件放在一个立即执行的匿名函数之中</strong></p><blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4></blockquote><ol><li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p></li><li><p>提高编译器效率，增加运行速度；</p></li><li><p>为未来新版本的Javascript做好铺垫。</p></li></ol><blockquote><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3></blockquote><ol><li><p>执行对象查找时，永远不会去查找原型</p></li><li><p>用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。</p></li><li>该方法属于Object对象，由于所有的对象都”继承”了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。</li></ol><blockquote><h3 id="时间格式化YYY-MM-DD"><a href="#时间格式化YYY-MM-DD" class="headerlink" title="时间格式化YYY-MM-DD"></a>时间格式化YYY-MM-DD</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">now: function () &#123;</span><br><span class="line">  var time = new Date(),</span><br><span class="line">      Y = time.getFullYear(),</span><br><span class="line">      M = time.getMonth()+1,   </span><br><span class="line">      D = time.getDate();</span><br><span class="line"></span><br><span class="line">      M = M &lt; 10? &apos;0&apos;+M : M;</span><br><span class="line">      D = D &lt; 10? &apos;0&apos;+D :D;</span><br><span class="line">  return Y +&apos;-&apos;+ M +&apos;-&apos;+ D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="任意时间"><a href="#任意时间" class="headerlink" title="任意时间"></a>任意时间</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">date: function (Day) &#123;</span><br><span class="line">    var time = new Date();</span><br><span class="line">        time.setDate(time.getDate() + Day);</span><br><span class="line"></span><br><span class="line">    var Y = time.getFullYear(),</span><br><span class="line">        M = (time.getMonth()+1) &lt; 10 ? &quot;0&quot;+ (time.getMonth() + 1) : (time.getMonth() + 1),    </span><br><span class="line">        D = time.getDate() &lt; 10 ? &quot;0&quot; + time.getDate() : time.getDate();</span><br><span class="line"></span><br><span class="line">    return Y + &quot;-&quot; + M + &quot;-&quot; + D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="闭包"><a href="#闭包" class="headerlink" title=" 闭包 "></a><span id="inline-blue"> 闭包</span></h2><ol><li><p>可以访问其他函数内部作用域的函数,在有函数嵌套的情况下,子函数用到了父函数的参数或者局部变量.</p></li><li><p>作用：具有封闭性，保护变量；避免污染全局变量</p></li><li><p>缺点：内存泄漏</p></li></ol><h2 id="call、apply、bind的区别"><a href="#call、apply、bind的区别" class="headerlink" title="call、apply、bind的区别"></a>call、apply、bind的区别</h2><h3 id="1-call、apply"><a href="#1-call、apply" class="headerlink" title="1.call、apply"></a>1.call、apply</h3><ul><li>改变函数体内部 this 的指向。</li><li>作用完全一样，接受参数的方式不太一样</li><li>call:把参数按顺序传递进去</li><li>apply:把参数放在数组里。　　</li></ul><h3 id="2-call、apply、bind"><a href="#2-call、apply、bind" class="headerlink" title="2.call、apply、bind"></a>2.call、apply、bind</h3><ul><li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li><li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li><li>apply 、 call 、bind 三者都可以利用后续参数传参；</li><li>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li></ul><p><a href="http://www.cnblogs.com/coco1s/p/4833199.html" target="_blank" rel="noopener">查看更多&gt;&gt;</a></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol><li><p>对象的<strong>属性和方法</strong>，定义在<strong>自身</strong>或定义在<strong>它的原型对象上</strong>。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。</p></li><li><p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。而Object.prototype对象的原型就是没有任何属性和方法的null对象，而null对象没有自己的原型。</p></li><li><p>读取对象的某个属性时:</p><pre><code>JavaScript 引擎先寻找对象本身的属性,  找不到?就到它的原型去找,  还是找不到?就到原型的原型去找。  直到最顶层的Object.prototype还是找不到?则返回undefined。</code></pre></li><li><p>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p></li><li><p>需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">查看更多&gt;&gt;</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于JS-持续更新&quot;&gt;&lt;a href=&quot;#关于JS-持续更新&quot; class=&quot;headerlink&quot; title=&quot;关于JS [持续更新]&quot;&gt;&lt;/a&gt;关于JS &lt;span style=&quot;font-size:.5em&quot;&gt;[持续更新]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/JS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="Notes" scheme="https://hotkang.cn/tags/Notes/"/>
    
      <category term="面试" scheme="https://hotkang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="JS" scheme="https://hotkang.cn/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>GitHub修改邮箱后</title>
    <link href="https://hotkang.cn/2018/07/23/GitHub%E4%BF%AE%E6%94%B9%E9%82%AE%E7%AE%B1%E5%90%8E/"/>
    <id>https://hotkang.cn/2018/07/23/GitHub修改邮箱后/</id>
    <published>2018-07-23T08:05:18.000Z</published>
    <updated>2018-07-26T18:05:46.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改邮箱后。。。-待完善"><a href="#修改邮箱后。。。-待完善" class="headerlink" title="修改邮箱后。。。 [待完善]"></a>修改邮箱后。。。 <span style="font-size:.5em">[待完善]</span></h2><blockquote><p>有一天突然发现自己的提交记录变少了？？？？绿色少的可怜？？于是我就回想自己干了嘛！！！！<br>恩…前几天换了个邮箱…并且毫不犹豫的把旧邮箱删除了…</p><p>把旧邮箱重新添加回来,绿色也回来了！！！<br>但是我强迫症,不想把旧邮箱留着…</p></blockquote><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><ul><li><a href="http://blog.51cto.com/dangzhiqiang/1657864" target="_blank" rel="noopener">参考链接</a></li><li><a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">Changing author info</a>。</li></ul></blockquote><p><br><br><br></p><h2 id="全局Git设置"><a href="#全局Git设置" class="headerlink" title="全局Git设置"></a>全局Git设置</h2><hr><blockquote><p>全局设置用户及邮箱</p></blockquote><pre><code>$ git config --global user.name &quot;hotyan&quot;$ git config --global user.email &quot;hotyann@163.com&quot;</code></pre><p><br></p><blockquote><p>命令行查看全局设置</p></blockquote><pre><code>$ git config  user.name #hotyan$ git config  user.email #hotyann@163.com</code></pre><p>补救措施只对以后的 commit 起效。（解决了修改邮箱后的绿色~）</p><p>如果想修改之前的作者信息(删除旧邮箱的前提下拯救之前的绿色),Github 给出了可靠的官方指南：<a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">Changing author info</a>。</p><p><br></p><blockquote><p>取消全局设置用户及邮箱</p></blockquote><pre><code>$ git config --global --unset user.name $ git config --global --unset user.email </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;修改邮箱后。。。-待完善&quot;&gt;&lt;a href=&quot;#修改邮箱后。。。-待完善&quot; class=&quot;headerlink&quot; title=&quot;修改邮箱后。。。 [待完善]&quot;&gt;&lt;/a&gt;修改邮箱后。。。 &lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;有一天突然发现自己的提交记录变少了？？？？绿色少的可怜？？于是我就回想自己干了嘛！！！！&lt;br&gt;恩…前几天换了个邮箱…并且毫不犹豫的把旧邮箱删除了…&lt;/p&gt;&lt;p&gt;把旧邮箱重新添加回来,绿色也回来了！！！&lt;br&gt;但是我强迫症,不想把旧邮箱留着…&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://hotkang.cn/categories/GitHub/"/>
    
    
  </entry>
  
  <entry>
    <title>基于GitHubIssue的评论功能</title>
    <link href="https://hotkang.cn/2018/07/19/%E5%9F%BA%E4%BA%8EGitHubIssue%E7%9A%84%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <id>https://hotkang.cn/2018/07/19/基于GitHubIssue的评论功能/</id>
    <published>2018-07-19T11:45:13.000Z</published>
    <updated>2018-07-26T18:12:54.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加评论功能-完结"><a href="#添加评论功能-完结" class="headerlink" title="添加评论功能   [完结]"></a>添加评论功能 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>一开始是没有打算添加评论功能的,觉得没有存在的必要。没人来！后面觉得试试吧,Google了一下发现好多评论系统可以选择,往往选择太多的时候,越不知道选择哪个比较好。由于这些效果都满足不了<del>不将就的</del>我,所以评论功能搁置过一段时间…直到…</p></blockquote><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://wingjay.com/2017/06/08/rebuild-personal-blog/" target="_blank" rel="noopener">参考链接1</a></li><li><a href="https://hydroecology.net/using-github-to-host-blog-comments/" target="_blank" rel="noopener">参考链接2</a></li><li><a href="http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html" target="_blank" rel="noopener">参考链接3</a></li></ul><p>参考链接1&amp;2都是参考的链接3,建议先看一遍链接3,了解大概流程后再细看每个链接。具体代码要参考链接1。</p></blockquote><p><br><br><br></p><h2 id="实现评论功能"><a href="#实现评论功能" class="headerlink" title="实现评论功能"></a>实现评论功能</h2><hr><h3 id="1-手动创建Issue"><a href="#1-手动创建Issue" class="headerlink" title="1.手动创建Issue"></a>1.手动创建Issue</h3><blockquote><p>进入Github博客仓库</p></blockquote><blockquote><p>单击 <span id="inline-green">Issues</span></p></blockquote><blockquote><p>单击 <span id="inline-green">New issue</span></p></blockquote><blockquote><p>编辑Title、Leave a comment</p></blockquote><blockquote><p>单击 <span id="inline-green">Submit new issue</span>完成</p></blockquote><blockquote><p>获得 commentIssueId 值</p></blockquote><p><br></p><h3 id="2-文章添加commentIssueId字段"><a href="#2-文章添加commentIssueId字段" class="headerlink" title="2.文章添加commentIssueId字段"></a>2.文章添加commentIssueId字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我是置顶博文</span><br><span class="line">date: 2018-07-18 21:30:35</span><br><span class="line">tags: 留言板</span><br><span class="line">categories: hotYan_博客之路</span><br><span class="line">top: 100</span><br><span class="line">commentIssueId: 1    </span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-添加-github-comments-swig-文件"><a href="#3-添加-github-comments-swig-文件" class="headerlink" title="3.添加 github_comments.swig 文件"></a>3.添加 github_comments.swig 文件</h3><p>在/themes/next/layout/_partials文件下新添github_comments.swig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">/*内容如下*/</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;div id=&quot;comments&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;post-header bg-&#123;&#123;site.default_post_color&#125;&#125;&quot;&gt;</span><br><span class="line">            &lt;h1 &gt;留言区&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;本站留言区搭建在 Github Issue 上,请点击下面按钮进行留言。&lt;/p&gt;</span><br><span class="line">            &lt;hr/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function loadComments(data) &#123;</span><br><span class="line">            var commentUrl = &quot;window.open(&apos;https://github.com/hotyan/hotyan.github.io/issues/&#123;&#123; page.commentIssueId &#125;&#125;&apos;)&quot;</span><br><span class="line">            $(&quot;#comments&quot;).append(&apos;&lt;div class=&quot;submit-comment&quot; style=&quot;text-align: center&quot;&gt;&lt;button onclick=&apos; + commentUrl + &apos; class=&quot;btn btn-primary&quot;&gt;留&amp;nbsp;言&lt;/button&gt;&lt;/div&gt;&apos;)</span><br><span class="line"></span><br><span class="line">            for (var i=0; i&lt;data.length; i++) &#123;</span><br><span class="line">                var cuser = data[i].user.login;</span><br><span class="line">                var cuserlink = data[i].user.html_url;</span><br><span class="line">                var avatarlink = data[i].user.avatar_url;</span><br><span class="line">                var clink = data[i].html_url;</span><br><span class="line">                var cbody = data[i].body_html;</span><br><span class="line">                var cavatarlink = data[i].user.avatar_url;      </span><br><span class="line">                var cdate = new Date(data[i].created_at);</span><br><span class="line">                var dopts = &#123; month: &apos;short&apos;, day: &apos;numeric&apos;, year: &apos;numeric&apos; &#125;</span><br><span class="line"></span><br><span class="line">                $(&quot;#comments&quot;).append(&apos;&lt;div class=&quot;timeline-comment-wrapper&quot;&gt;&lt;div class=&quot;avatar-parent-child timeline-comment-avatar&quot;&gt;&lt;a href=&quot;&apos; + cuserlink +&apos;&quot;&gt;&lt;img width=&quot;44&quot; height=&quot;44&quot; class=&quot;avatar rounded-1&quot; src=&quot;&apos; + avatarlink + &apos;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;timeline-comment current-user&quot;&gt;&lt;div class=&quot;timeline-comment-header&quot;&gt;&lt;h3 class=&quot;timeline-comment-header-text text-normal f5&quot;&gt;&lt;strong&gt;&apos; + cuser + &apos;&lt;/strong&gt;&lt;span class=&quot;post-meta&quot;&gt;&apos; + cdate.toLocaleDateString(&quot;en&quot;, dopts) + &apos;&lt;/span&gt;&lt;/h3&gt;&lt;/div&gt;&lt;div style=&quot;display: block !important; padding: 15px;&quot;&gt;&lt;article class=&quot;post-content&quot;&gt;&apos; + cbody + &apos;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $.ajax(&quot;https://api.github.com/repos/hotyan/hotyan.github.io/issues/&#123;&#123; page.commentIssueId &#125;&#125;/comments&quot;, &#123;</span><br><span class="line">            headers: &#123;Accept: &quot;application/vnd.github.v3.html+json&quot;&#125;,</span><br><span class="line">            dataType: &quot;json&quot;,</span><br><span class="line">            success: function(msg)&#123;</span><br><span class="line">                console.log(msg);</span><br><span class="line">                loadComments(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .timeline-comment-wrapper &#123;</span><br><span class="line">        margin-top: 0;</span><br><span class="line">        position: relative;</span><br><span class="line">        padding-left: 60px;</span><br><span class="line">        margin-top: 15px;</span><br><span class="line">        margin-bottom: 15px;</span><br><span class="line">        border-top: 2px solid #fff;</span><br><span class="line">        border-bottom: 2px solid #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-avatar &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        margin-left: -60px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .avatar-parent-child &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-wrapper a &#123;</span><br><span class="line">        color: #0366d6;</span><br><span class="line">        text-decoration: none;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-wrapper .avatar &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        line-height: 1;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-wrapper .rounded-1 &#123;</span><br><span class="line">        border-radius: 3px !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment.current-user &#123;</span><br><span class="line">        border-color: #c0d3eb;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">        border: 1px solid #d1d5da;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment.current-user .timeline-comment-header &#123;</span><br><span class="line">        background-color: #f1f8ff;</span><br><span class="line">        border-bottom-color: #c0d3eb;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-header &#123;</span><br><span class="line">        padding-right: 15px;</span><br><span class="line">        padding-left: 15px;</span><br><span class="line">        color: #586069;</span><br><span class="line">        background-color: #f6f8fa;</span><br><span class="line">        border-bottom: 1px solid #d1d5da;</span><br><span class="line">        border-top-left-radius: 3px;</span><br><span class="line">        border-top-right-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-header-text &#123;</span><br><span class="line">        padding-top: 10px;</span><br><span class="line">        padding-bottom: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-header h3 &#123;</span><br><span class="line">        margin-top: 0px;</span><br><span class="line">        margin-bottom: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-header-text .post-meta &#123;</span><br><span class="line">        margin-left: 6px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment article p &#123;</span><br><span class="line">        margin: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">    .text-normal &#123;</span><br><span class="line">        font-weight: normal !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .f5 &#123;</span><br><span class="line">        font-size: 14px !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .submit-comment .btn &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        padding: 6px 12px;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">        font-weight: 600;</span><br><span class="line">        line-height: 20px;</span><br><span class="line">        white-space: nowrap;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">        -webkit-user-select: none;</span><br><span class="line">        -moz-user-select: none;</span><br><span class="line">        -ms-user-select: none;</span><br><span class="line">        user-select: none;</span><br><span class="line">        background-repeat: repeat-x;</span><br><span class="line">        background-position: -1px -1px;</span><br><span class="line">        background-size: 110% 110%;</span><br><span class="line">        border: 1px solid rgba(27,31,35,0.2);</span><br><span class="line">        border-radius: 0.25em;</span><br><span class="line">        -webkit-appearance: none;</span><br><span class="line">        -moz-appearance: none;</span><br><span class="line">        appearance: none;</span><br><span class="line">    &#125;</span><br><span class="line">    .submit-comment .btn-primary &#123;</span><br><span class="line">        color: #fff;</span><br><span class="line">        background-color: #28a745;</span><br><span class="line">        background-image: -webkit-linear-gradient(270deg, #34d058 0%, #28a745 90%);</span><br><span class="line">        background-image: linear-gradient(-180deg, #34d058 0%, #28a745 90%);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-修改-themes-next-layout-macro-post-swig"><a href="#4-修改-themes-next-layout-macro-post-swig" class="headerlink" title="4.修改/themes/next/layout/_macro/post.swig"></a>4.修改/themes/next/layout/_macro/post.swig</h3><p>在文件最后<code>&lt;/footer&gt;</code>前引入github_comments.swig<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer class=&quot;post-footer&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &#123;% if page.commentIssueId %&#125;</span><br><span class="line">        &#123;% include &apos;../_partials/github_comments.swig&apos; %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="5-修改-themes-next-layout-partials-head-swig"><a href="#5-修改-themes-next-layout-partials-head-swig" class="headerlink" title="5.修改/themes/next/layout/_partials/head.swig"></a>5.修改/themes/next/layout/_partials/head.swig</h3><p>文件最后引入JQuery<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.commentIssueId %&#125;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p></p><p><br><br><br></p><h2 id="总有一个适合你"><a href="#总有一个适合你" class="headerlink" title="总有一个适合你"></a>总有一个适合你</h2><hr><h3 id="选择真的太多了-先大概了解一下有哪些"><a href="#选择真的太多了-先大概了解一下有哪些" class="headerlink" title="选择真的太多了,先大概了解一下有哪些"></a>选择真的太多了,先大概了解一下有哪些</h3><blockquote><p>hexo已提供的选择</p></blockquote><pre><code># Duoshuo ShortName  //多说...# Disqus ...# Hypercomments ...# changyan  //畅言...# Valine...#youyan_uid //友言...#livere_uid...# Gitment </code></pre><p><br></p><blockquote><p>其他选择</p></blockquote><p>网易云跟帖<br>来必力<br>Gitalk<br>Gitter<br>…</p><p><a href="https://blog.shuiba.co/comment-systems-recommendation" target="_blank" rel="noopener">了解各种评论系统的利弊和效果预览&gt;&gt;</a></p><p><strong>But</strong>上面提到的个人都不太钟意~</p><p>一直在寻找!直到发现了<a href="http://wingjay.com/2017/06/08/rebuild-personal-blog/" target="_blank" rel="noopener"><strong>他</strong></a>！！是自己想要的效果！！</p><p><br><br><br></p><h2 id="独立Comments板块"><a href="#独立Comments板块" class="headerlink" title="独立Comments板块"></a>独立Comments板块</h2><hr><h3 id="1-修改-themes-next-layout-macro-post-swig"><a href="#1-修改-themes-next-layout-macro-post-swig" class="headerlink" title="1.修改/themes/next/layout/_macro/post.swig"></a>1.修改/themes/next/layout/_macro/post.swig</h3><p>删除之前引入github_comments.swig文件的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*删除*/</span><br><span class="line">&#123;% if page.commentIssueId %&#125;</span><br><span class="line">&#123;% include &apos;../_partials/github_comments.swig&apos; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">/*删除结束*/</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-新建GitHub-Issue-swig"><a href="#2-新建GitHub-Issue-swig" class="headerlink" title="2.新建GitHub_Issue.swig"></a>2.新建GitHub_Issue.swig</h3><p>在/themes/next/layout/_partials文件下新建GitHub_Issue.swig,并加入下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.commentIssueId %&#125;</span><br><span class="line">    &#123;% include &apos;../_partials/github_comments.swig&apos; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-修改-themes-next-layout-post-swig"><a href="#3-修改-themes-next-layout-post-swig" class="headerlink" title="3.修改/themes/next/layout/post.swig"></a>3.修改/themes/next/layout/post.swig</h3><p>在<span id="inline-green">block content</span>最后 <span id="inline-green">endblock</span> 之前引入GitHub_Issue.swig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  ...</span><br><span class="line">    &#123;% include &apos;_partials/GitHub_Issue.swig&apos; %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4-修改-themes-next-source-css-custom-custom-styl"><a href="#4-修改-themes-next-source-css-custom-custom-styl" class="headerlink" title="4.修改/themes/next/source/css/_custom/custom.styl"></a>4.修改/themes/next/source/css/_custom/custom.styl</h3><p>添加代码如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#comments&#123;</span><br><span class="line">    margin-top:20px;</span><br><span class="line">    padding: 40px;</span><br><span class="line">    background: white;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="5-效果预览"><a href="#5-效果预览" class="headerlink" title="5.效果预览"></a>5.效果预览</h3><p><img src="/img/Comments.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;添加评论功能-完结&quot;&gt;&lt;a href=&quot;#添加评论功能-完结&quot; class=&quot;headerlink&quot; title=&quot;添加评论功能   [完结]&quot;&gt;&lt;/a&gt;添加评论功能 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;一开始是没有打算添加评论功能的,觉得没有存在的必要。没人来！后面觉得试试吧,Google了一下发现好多评论系统可以选择,往往选择太多的时候,越不知道选择哪个比较好。由于这些效果都满足不了&lt;del&gt;不将就的&lt;/del&gt;我,所以评论功能搁置过一段时间…直到…&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo" scheme="https://hotkang.cn/tags/Hexo/"/>
    
      <category term="博客" scheme="https://hotkang.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub Issue" scheme="https://hotkang.cn/tags/GitHub-Issue/"/>
    
      <category term="Next" scheme="https://hotkang.cn/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Github添加SSH密钥</title>
    <link href="https://hotkang.cn/2018/07/18/Github%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/"/>
    <id>https://hotkang.cn/2018/07/18/Github添加SSH密钥/</id>
    <published>2018-07-18T13:33:55.000Z</published>
    <updated>2018-07-26T15:31:03.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加SSH密钥-完结"><a href="#添加SSH密钥-完结" class="headerlink" title="添加SSH密钥 [完结]"></a>添加SSH密钥 <span style="font-size:.5em">[完结]</span></h2><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">GitHub Help</a></li><li><a href="http://www.cnblogs.com/ayseeing/p/3572582.html" target="_blank" rel="noopener">参考连接</a></li></ul><p>参考链接有整体的流程总结。跟着步骤来没有问题。但我会觉得GitHub Help比较官方？权威？</p></blockquote><hr><h2 id="一、查看现有的SSH密钥"><a href="#一、查看现有的SSH密钥" class="headerlink" title="一、查看现有的SSH密钥"></a>一、查看现有的SSH密钥</h2><pre><code>$ ls -al ~/.ssh</code></pre><p><br></p><h2 id="二、生成新SSH密钥"><a href="#二、生成新SSH密钥" class="headerlink" title="二、生成新SSH密钥"></a>二、生成新SSH密钥</h2><blockquote><h3 id="1-根据实际情况填写GitHub电子邮件地址"><a href="#1-根据实际情况填写GitHub电子邮件地址" class="headerlink" title="1.根据实际情况填写GitHub电子邮件地址"></a>1.根据实际情况填写GitHub电子邮件地址</h3></blockquote><pre><code>$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; </code></pre><blockquote><h3 id="2-文件生成位置"><a href="#2-文件生成位置" class="headerlink" title="2.文件生成位置"></a>2.文件生成位置</h3></blockquote><pre><code>Enter file in which to save the key (/Users/hotkang/.ssh/id_rsa): [Press enter]  /*按回车默认文件位置*/</code></pre><blockquote><h3 id="3-设置push密码"><a href="#3-设置push密码" class="headerlink" title="3.设置push密码"></a>3.设置push密码</h3></blockquote><pre><code>Enter passphrase (empty for no passphrase):Enter same passphrase again: /*设置push文件时的密码,回车默认没有密码*/</code></pre><p><br></p><h2 id="三、添加密钥到GitHub"><a href="#三、添加密钥到GitHub" class="headerlink" title="三、添加密钥到GitHub"></a>三、添加密钥到GitHub</h2><blockquote><h3 id="1-打开-ssh-id-rsa-pub-文件-将内容复制到剪贴板"><a href="#1-打开-ssh-id-rsa-pub-文件-将内容复制到剪贴板" class="headerlink" title="1.打开 /.ssh/id_rsa.pub 文件,将内容复制到剪贴板"></a>1.打开 /.ssh/id_rsa.pub 文件,将内容复制到剪贴板</h3></blockquote><blockquote><h3 id="2-单击右上角头像"><a href="#2-单击右上角头像" class="headerlink" title="2.单击右上角头像"></a>2.单击右上角头像</h3></blockquote><blockquote><h3 id="3-单击-Settings"><a href="#3-单击-Settings" class="headerlink" title="3.单击 Settings "></a>3.单击 <span id="inline-green">Settings</span></h3></blockquote><blockquote><h3 id="4-单击-SSH-and-GPG-keys"><a href="#4-单击-SSH-and-GPG-keys" class="headerlink" title="4.单击 SSH and GPG keys  "></a>4.单击 <span id="inline-green">SSH and GPG keys</span></h3></blockquote><blockquote><h3 id="5-单击-New-SSH-Key"><a href="#5-单击-New-SSH-Key" class="headerlink" title="5.单击 New SSH Key"></a>5.单击 <span id="inline-green">New SSH Key</span></h3></blockquote><blockquote><h3 id="6-填写Title并将-ssh-id-rsa-pub文件内容粘贴到Key"><a href="#6-填写Title并将-ssh-id-rsa-pub文件内容粘贴到Key" class="headerlink" title="6.填写Title并将/.ssh/id_rsa.pub文件内容粘贴到Key"></a>6.填写<span id="inline-green">Title</span>并将/.ssh/id_rsa.pub文件内容粘贴到<span id="inline-green">Key</span></h3></blockquote><blockquote><h3 id="7-单击Add-SSH-Key完成"><a href="#7-单击Add-SSH-Key完成" class="headerlink" title="7.单击Add SSH Key完成"></a>7.单击<span id="inline-green">Add SSH Key</span>完成</h3></blockquote><blockquote><h3 id="8-如果出现提示-请确认你的GitHub密码"><a href="#8-如果出现提示-请确认你的GitHub密码" class="headerlink" title="8.如果出现提示,请确认你的GitHub密码"></a>8.如果出现提示,请确认你的GitHub密码</h3></blockquote><p><br></p><h2 id="四、测试SSH连接"><a href="#四、测试SSH连接" class="headerlink" title="四、测试SSH连接"></a>四、测试SSH连接</h2><pre><code>$ ssh -T git@github.com</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;添加SSH密钥-完结&quot;&gt;&lt;a href=&quot;#添加SSH密钥-完结&quot; class=&quot;headerlink&quot; title=&quot;添加SSH密钥 [完结]&quot;&gt;&lt;/a&gt;添加SSH密钥 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://hotkang.cn/categories/GitHub/"/>
    
    
      <category term="SSH" scheme="https://hotkang.cn/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>我是置顶博文</title>
    <link href="https://hotkang.cn/2018/07/18/%E6%88%91%E6%98%AF%E7%BD%AE%E9%A1%B6%E5%8D%9A%E6%96%87/"/>
    <id>https://hotkang.cn/2018/07/18/我是置顶博文/</id>
    <published>2018-07-18T13:30:35.000Z</published>
    <updated>2018-07-26T08:54:27.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h2 id="About-Blog"><a href="#About-Blog" class="headerlink" title="About Blog"></a>About Blog</h2><p><br></p><p><strong>作为学习过程的记录总结。<br>目前没有SEO优化,博客文章也不会被百度、Google搜索引擎收录。<br>如果这都被你发现了❓❓留下你的脚印❓❓</strong></p><p><br></p></blockquote><a id="more"></a><p><br><br><br></p><h2 id="About-Link"><a href="#About-Link" class="headerlink" title="About Link"></a>About Link</h2><hr><p><strong>本站的参考链接都是自己过滤后的,可能来自各大官网文档、Others’s Blog、简书、掘金、社区或者外网。如果涉及到外网链接打不开也没有关系,可以参考我的文章。</strong></p><p><br><br><br></p><h2 id="About-Post"><a href="#About-Post" class="headerlink" title="About Post"></a>About Post</h2><hr><p><strong>本站文章主要由【 <del>优质</del> 参考文章】和【个人记录总结】构成;<br>网上资源玲琅满目,如果每个人都一篇篇筛选,浪费时间走弯路;<br>记录自己完成的过程并在参考文章的基础上进行个人总结。</strong></p><p><br><br><br></p><h2 id="About-Comments"><a href="#About-Comments" class="headerlink" title="About Comments"></a>About Comments</h2><hr><p><strong>本站唯一的评论搭建在GitHub Issue上,点击<span id="inline-purple">Comment</span>跳转到博客文章对应的 Github issue 处,在 issue 下进行评论,文章展示时会实时获取数据。<br>还在等什么❓❓测试一下❓❓</strong></p><p><br><br><br></p><h2 id="ToDoList"><a href="#ToDoList" class="headerlink" title="ToDoList"></a>ToDoList</h2><hr><p><strong><del><a href="https://hotkang.cn/2018/07/19/%E5%9F%BA%E4%BA%8EGitHubIssue%E7%9A%84%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/">基于GitHubIssue的评论功能</a></del></strong></p><p><strong><del><a href="https://hotkang.cn/2018/07/18/Github%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/">Github添加SSH密钥</a></del></strong></p><p><strong><del><a href="https://hotkang.cn/2018/06/28/%E5%9C%A8GitHub-Pages%E4%B8%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8E%86/">在GitHub Pages上部署自己的简历</a></del></strong></p><p><strong>CSS世界</strong></p><p><strong>ES6标准入门</strong></p><p><strong>Vue权威指南</strong></p><p><strong>Grunt &amp; Gulp</strong></p><p><strong>…</strong></p><p><br><br><br></p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><hr><p><strong><del><a href="https://hotkang.cn/2018/07/19/%E5%9F%BA%E4%BA%8EGitHubIssue%E7%9A%84%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/">手动生成Issue,实现评论功能</a></del></strong></p><p><strong>文章详情界面点击不出现桃心,理论上应该是有效果的吧❓❓可能源码被我改砸了❓❓</strong></p><p><strong><del>Gulp压缩不成功❓❓已用<a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">hexo-all-minifier</a>替代</del></strong></p><p><strong>刷新一次不蒜子PV统计加2 ❓❓理论上加1才对</strong></p><p><strong>文章目录只显示大标题❓❓</strong></p><p><strong>自动生成Issue❓❓</strong></p><p><br><br><br></p><h3 id="博客文章预览-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-About-Me"><a href="#博客文章预览-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-About-Me" class="headerlink" title="博客文章预览&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;About Me"></a><a href="https://hotkang.cn/archives/"><span id="inline-blue">博客文章预览</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://hotkang.cn/about/"><span id="inline-green">About Me</span></a></h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h2 id=&quot;About-Blog&quot;&gt;&lt;a href=&quot;#About-Blog&quot; class=&quot;headerlink&quot; title=&quot;About Blog&quot;&gt;&lt;/a&gt;About Blog&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;作为学习过程的记录总结。&lt;br&gt;目前没有SEO优化,博客文章也不会被百度、Google搜索引擎收录。&lt;br&gt;如果这都被你发现了❓❓留下你的脚印❓❓&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>在GitHub Pages上部署自己的简历</title>
    <link href="https://hotkang.cn/2018/06/28/%E5%9C%A8GitHub-Pages%E4%B8%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    <id>https://hotkang.cn/2018/06/28/在GitHub-Pages上部署自己的简历/</id>
    <published>2018-06-28T09:11:27.000Z</published>
    <updated>2018-07-26T18:14:45.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitHub-Pages-完结"><a href="#GitHub-Pages-完结" class="headerlink" title="GitHub Pages [完结]"></a>GitHub Pages <span style="font-size:.5em">[完结]</span></h2><p><img src="/img/GHP.png" alt=""></p><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a></li></ul><p>看了很多教程,发现官网是说的最简洁明了又清楚的,最终解决了我的问题。建议打开<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>,两边参考着看更简单易懂。</p></blockquote><hr><h2 id="一、什么是GitHub-Pages"><a href="#一、什么是GitHub-Pages" class="headerlink" title="一、什么是GitHub Pages"></a>一、什么是GitHub Pages</h2><ol><li><p>GitHub Pages是一个静态站点托管服务,旨在直接从GitHub存储库托管我们的个人,组织或项目页面。不支持服务器端代码，例如PHP，Ruby或Python。</p></li><li><p>我们可以使用Jekyll Theme Chooser在线创建和发布GitHub Pages网站。我们也可以在本地工作，使用【GitHub Desktop】或【命令行】。</p></li></ol><blockquote><p>注意:</p><ol><li><strong><a href="https://desktop.github.com/" target="_blank" rel="noopener">GitHub Desktop</a></strong>:一个上传项目到github的软件。不想用命令行的不二选择。</li><li><strong><a href="https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/" target="_blank" rel="noopener">命令行</a></strong>:指使用git命令上传项目</li></ol><p>【PS:不会命令行没关系，谁敢说自己连一个软件都不会用呀？】</p></blockquote><p><br></p><h2 id="二、GitHub-Pages-提供什么"><a href="#二、GitHub-Pages-提供什么" class="headerlink" title="二、GitHub Pages 提供什么"></a>二、GitHub Pages 提供什么</h2><p>在官网上有这样一句话:</p><pre><code>You get one site per GitHub account and organization,and unlimited project sites. </code></pre><p>意思是:</p><pre><code>GitHub Pages为每个GitHub帐户/组织提供一个【站点】,以及无限制的【项目站点】。</code></pre><blockquote><p>注意:</p><ol><li><p>我们只能有一个【<code>User or organization site</code>】;但是我们可以有很多【<code>Project site</code>】。</p></li><li><p>部署简历用【<code>User or organization site</code>】简直是大材小用,用【<code>Project site</code>】就可以了。</p></li><li><p>【<code>User or organization site</code>】可以拿来部署个人博客,点击<a href="https://hotyan.github.io/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/" target="_blank" rel="noopener">用hexo搭建github博客</a>了解如何搭建个人博客。</p></li></ol></blockquote><p><br></p><h2 id="三、准备工作"><a href="#三、准备工作" class="headerlink" title="三、准备工作"></a>三、准备工作</h2><h3 id="1-默认已有GitHub账号-并已创建好存储库或会创建存储库。"><a href="#1-默认已有GitHub账号-并已创建好存储库或会创建存储库。" class="headerlink" title="1.默认已有GitHub账号,并已创建好存储库或会创建存储库。"></a>1.默认已有GitHub账号,并已创建好存储库或会创建存储库。</h3><ul><li><p>没有<code>GitHub</code>账号？？<a href="https://github.com/" target="_blank" rel="noopener">点击注册</a></p></li><li><p>没有存储库？？<a href="https://help.github.com/articles/creating-a-new-repository/" target="_blank" rel="noopener">了解如何创建</a></p></li></ul><h3 id="2-默认已有html简历-命名为-index-html"><a href="#2-默认已有html简历-命名为-index-html" class="headerlink" title="2.默认已有html简历,命名为 index.html"></a>2.默认已有html简历,命名为 index.html</h3><ul><li>没有简历？？<a href="http://cv.qiaobutang.com/" target="_blank" rel="noopener">制作并下载</a></li></ul><p><br></p><h2 id="四、简历部署"><a href="#四、简历部署" class="headerlink" title="四、简历部署"></a>四、简历部署</h2><blockquote><p>创建新存储库</p></blockquote><ol><li><p>点击右上角 <strong>+</strong> 选择 <strong><code>New repository</code></strong></p></li><li><p>填写 <strong><code>Repository name</code></strong> 并勾选 <strong><code>Initialize this repository with a README</code></strong></p></li><li>点击 <strong><code>Create repository</code></strong> 完成创建</li></ol><blockquote><p>上传简历</p></blockquote><ol><li><p>在新建的存储库点击 <strong><code>Upload files</code></strong></p></li><li><p>点击 <strong><code>choose your files</code></strong> 上传你的 <strong><code>index.html</code></strong> 文件</p></li><li>点击 <strong><code>Commit changes</code></strong> 完成上传</li></ol><blockquote><p>部署</p></blockquote><ol><li><p>点击 <strong><code>Settings</code></strong> 下滑到 <strong><code>GitHub Pages</code></strong> 部分</p></li><li><p>修改 <strong><code>Source</code></strong> 为 <strong><code>master branch</code></strong> 并点击 <strong><code>Save</code></strong></p></li><li>再次下滑到 <strong><code>GitHub Pages</code></strong> 部分就会看到一个链接</li></ol><blockquote><p>成功</p></blockquote><ol><li><p>如果不成功,再次修改 <strong><code>Source</code></strong> 为 <strong><code>master branch</code></strong> 并点击 <strong><code>Save</code></strong></p></li><li><p>点击链接就可以看到部署的简历</p></li><li><p>将简历链接写在你的<code>README.md</code>或者任何地方</p></li></ol><p><br></p><h2 id="五、创建【User-or-organization-site】"><a href="#五、创建【User-or-organization-site】" class="headerlink" title="五、创建【User or organization site】"></a>五、创建【User or organization site】</h2><p>跟创建一般存储库流程一样,只是因为我们每个用户只有一个【<code>User or organization site</code>】,所以存储库的名称比较唯一,必须是<strong><code>username.github.io</code></strong> 格式,其中<code>username</code>是我们在<code>GitHub</code>上的用户名或组织名称</p><p>如果不正确则不起作用，因此请确保正确无误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GitHub-Pages-完结&quot;&gt;&lt;a href=&quot;#GitHub-Pages-完结&quot; class=&quot;headerlink&quot; title=&quot;GitHub Pages [完结]&quot;&gt;&lt;/a&gt;GitHub Pages &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/GHP.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://hotkang.cn/categories/GitHub/"/>
    
    
      <category term="GitHub Pages" scheme="https://hotkang.cn/tags/GitHub-Pages/"/>
    
      <category term="简历" scheme="https://hotkang.cn/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>CSS_属性继承</title>
    <link href="https://hotkang.cn/2018/06/21/CSS-%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF/"/>
    <id>https://hotkang.cn/2018/06/21/CSS-属性继承/</id>
    <published>2018-06-21T10:29:02.000Z</published>
    <updated>2018-07-26T16:56:52.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-属性继承-待完善"><a href="#CSS-属性继承-待完善" class="headerlink" title="CSS_属性继承 [待完善]"></a>CSS_属性继承 <span style="font-size:.5em">[待完善]</span></h2><blockquote><p>哪些属性可继承？？呃。。。往下看。</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://www.cnblogs.com/thislbq/p/5882105.html" target="_blank" rel="noopener">参考链接</a></li><li><a href="http://www.runoob.com/cssref/css-reference.html" target="_blank" rel="noopener">CSS 参考手册</a></li><li><a href="https://www.w3schools.com/cssref/css3_pr_align-content.asp" target="_blank" rel="noopener">CSS Properties</a></li></ul></blockquote><hr><h2 id="一、无继承性的属性"><a href="#一、无继承性的属性" class="headerlink" title="一、无继承性的属性"></a>一、<strong>无继承性</strong>的属性</h2><h3 id="1-display"><a href="#1-display" class="headerlink" title="1. display"></a>1. display</h3><p>定义元素生成的框的类型,下面是常用的属性值:</p><table><thead><tr><th style="text-align:center">display值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">inherit</td><td style="text-align:left">继承父元素 display 属性的值</td></tr><tr><td style="text-align:center"><strong>none</strong></td><td style="text-align:left">不会被显示</td></tr><tr><td style="text-align:center"><strong>block</strong></td><td style="text-align:left">块级元素，前后会带有换行符</td></tr><tr><td style="text-align:center"><strong>inline</strong></td><td style="text-align:left">默认。内联元素，前后没有换行符</td></tr><tr><td style="text-align:center"><strong>inline-block</strong></td><td style="text-align:left">行内块元素</td></tr></tbody></table><h3 id="2-文本属性-部分属性无继承性"><a href="#2-文本属性-部分属性无继承性" class="headerlink" title="2. 文本属性[部分属性无继承性]"></a>2. 文本属性[部分属性无继承性]</h3><table><thead><tr><th style="text-align:center">文本属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">vertical-align</td><td style="text-align:left">垂直文本对齐</td></tr><tr><td style="text-align:center">text-decoration</td><td style="text-align:left">规定添加到文本的装饰</td></tr><tr><td style="text-align:center">text-shadow</td><td style="text-align:left">文本阴影效果</td></tr><tr><td style="text-align:center">white-space</td><td style="text-align:left">空白符的处理</td></tr><tr><td style="text-align:center">unicode-bidi</td><td style="text-align:left">设置文本的方向</td></tr></tbody></table><p></p><h3 id="3-盒子模型"><a href="#3-盒子模型" class="headerlink" title="3.盒子模型"></a>3.盒子模型</h3><table><thead><tr><th style="text-align:center">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">width/height</td><td style="text-align:left">宽/高</td></tr><tr><td style="text-align:center">margin: top right bottom left</td><td style="text-align:left">[上右下左]外边距</td></tr><tr><td style="text-align:center">padding: top right bottom left</td><td style="text-align:left">[上右下左]内边距</td></tr><tr><td style="text-align:center">border: top right bottom left</td><td style="text-align:left">[上右下左]边框</td></tr><tr><td style="text-align:center">border-[top/right/bottom/left]-style</td><td style="text-align:left">边框[上右下左]样式</td></tr><tr><td style="text-align:center">border-[top/right/bottom/left]-width</td><td style="text-align:left">边框[上右下左]宽度</td></tr><tr><td style="text-align:center">border-[top/right/bottom/left]-color</td><td style="text-align:left">边框[上右下左]颜色</td></tr></tbody></table><h3 id="4-背景属性-均无继承性"><a href="#4-背景属性-均无继承性" class="headerlink" title="4.背景属性[均无继承性]"></a>4.背景属性[均无继承性]</h3><table><thead><tr><th style="text-align:center">背景属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">background</td><td style="text-align:left">[颜色/图片/位置/大小/重复/原点/素材/附件]</td></tr><tr><td style="text-align:center">background-color</td><td style="text-align:left">颜色</td></tr><tr><td style="text-align:center">background-image</td><td style="text-align:left">图片</td></tr><tr><td style="text-align:center">background-position</td><td style="text-align:left">位置</td></tr><tr><td style="text-align:center">background-size</td><td style="text-align:left">大小</td></tr><tr><td style="text-align:center">background-repeat</td><td style="text-align:left">重复</td></tr><tr><td style="text-align:center">background-origin</td><td style="text-align:left">指定原点位置</td></tr><tr><td style="text-align:center">background-clip</td><td style="text-align:left">背景(颜色或图像)应在元素内延伸的距离</td></tr><tr><td style="text-align:center">background-attachment</td><td style="text-align:left">背景图像是否与页面的其余部分一起滚动,或者是否已修复。</td></tr></tbody></table><h3 id="5-定位属性"><a href="#5-定位属性" class="headerlink" title="5.定位属性"></a>5.定位属性</h3><table><thead><tr><th style="text-align:center">定位属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:left">指定元素应该如何浮动</td></tr><tr><td style="text-align:center">clear</td><td style="text-align:left">指定元素浮动元素的哪些边不允许浮动</td></tr><tr><td style="text-align:center">position</td><td style="text-align:left">指定用于元素的定位方法的类型(static/relative/absolute/fixed/sticky)</td></tr><tr><td style="text-align:center">top/bottom</td><td style="text-align:left">影响定位元素的垂直位置</td></tr><tr><td style="text-align:center">left/right</td><td style="text-align:left">影响定位元素的水平位置</td></tr><tr><td style="text-align:center">min-[width/height]</td><td style="text-align:left">定义了元素的最小宽度/高度</td></tr><tr><td style="text-align:center">max-[width/height]</td><td style="text-align:left">定义了元素的最大宽度/高度</td></tr><tr><td style="text-align:center">overflow</td><td style="text-align:left">溢出</td></tr><tr><td style="text-align:center">clip</td><td style="text-align:left">指定一个矩形来剪切绝对定位的元素</td></tr><tr><td style="text-align:center">z-index</td><td style="text-align:left">指定元素的堆栈顺序</td></tr></tbody></table><h3 id="6-生成内容属性"><a href="#6-生成内容属性" class="headerlink" title="6.生成内容属性"></a>6.生成内容属性</h3><table><thead><tr><th style="text-align:center">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">content</td><td style="text-align:left">::before和::after伪元素一起使用,以插入生成的内容</td></tr><tr><td style="text-align:center">counter-reset</td><td style="text-align:left">创建或重置一个或多个CSS计数器</td></tr><tr><td style="text-align:center">counter-increment</td><td style="text-align:left">增加或减少一个或多个CSS计数器的值</td></tr></tbody></table><h3 id="7-轮廓属性"><a href="#7-轮廓属性" class="headerlink" title="7.轮廓属性"></a>7.轮廓属性</h3><table><thead><tr><th style="text-align:center">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">outline</td><td style="text-align:left">轮廓[宽度/*样式/颜色]</td></tr><tr><td style="text-align:center">outline-style</td><td style="text-align:left">样式</td></tr><tr><td style="text-align:center">outline-width</td><td style="text-align:left">宽度</td></tr><tr><td style="text-align:center">outline-color</td><td style="text-align:left">颜色</td></tr></tbody></table><h3 id="8-打印属性"><a href="#8-打印属性" class="headerlink" title="8.打印属性"></a>8.打印属性</h3><table><thead><tr><th style="text-align:center">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">size</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">page-break-before</td><td style="text-align:left">元素之前添加分页符</td></tr><tr><td style="text-align:center">page-break-after</td><td style="text-align:left">元素后添加分页符</td></tr><tr><td style="text-align:center">page-break-inside</td><td style="text-align:left">指定元素内避免分页符</td></tr></tbody></table><h3 id="9-声音样式属性"><a href="#9-声音样式属性" class="headerlink" title="9.声音样式属性"></a>9.声音样式属性</h3><table><thead><tr><th style="text-align:center">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">pause-before</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">pause-after</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">pause</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">cue-before</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">cue-after</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">cue</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">play-during</td><td style="text-align:left"></td></tr></tbody></table><h2 id="二、有继承性的属性"><a href="#二、有继承性的属性" class="headerlink" title="二、有继承性的属性"></a>二、<strong>有继承性</strong>的属性</h2><h3 id="1-字体系列属性-均继承"><a href="#1-字体系列属性-均继承" class="headerlink" title="1.字体系列属性[均继承]"></a>1.字体系列属性[均继承]</h3><table><thead><tr><th style="text-align:center">字体属性</th><th style="text-align:left"> 描述</th></tr></thead><tbody><tr><td style="text-align:center">font</td><td style="text-align:left">[*size/* family/weight/style]</td></tr><tr><td style="text-align:center">font-style</td><td style="text-align:left">样式</td></tr><tr><td style="text-align:center">font-variant</td><td style="text-align:left">变形</td></tr><tr><td style="text-align:center">font-weight</td><td style="text-align:left">粗细</td></tr><tr><td style="text-align:center">font-size/line-height</td><td style="text-align:left">尺寸</td></tr><tr><td style="text-align:center">font-family</td><td style="text-align:left">字体系列</td></tr><tr><td style="text-align:center">font-stretch</td><td style="text-align:left">对字体进行伸缩变形</td></tr><tr><td style="text-align:center">font-size-adjust</td><td style="text-align:left">更好地控制字体大小。</td></tr></tbody></table><h3 id="2-文本属性-部分继承"><a href="#2-文本属性-部分继承" class="headerlink" title="2. 文本属性[部分继承]"></a>2. 文本属性[部分继承]</h3><table><thead><tr><th style="text-align:center">文本属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">text-indent</td><td style="text-align:left">文本缩进</td></tr><tr><td style="text-align:center">text-align</td><td style="text-align:left">文本水平对齐</td></tr><tr><td style="text-align:center">line-height</td><td style="text-align:left">行高</td></tr><tr><td style="text-align:center">word-spacing</td><td style="text-align:left">增加或减少<strong>单词间</strong>的空白（即字间隔）</td></tr><tr><td style="text-align:center">letter-spacing</td><td style="text-align:left">增加或减少<strong>字符间</strong>的空白（字符间距）</td></tr><tr><td style="text-align:center">text-transform</td><td style="text-align:left">控制文本大小写</td></tr><tr><td style="text-align:center">direction</td><td style="text-align:left">规定文本的书写方向</td></tr><tr><td style="text-align:center">color</td><td style="text-align:left">文本颜色</td></tr></tbody></table><h3 id="3-visibility"><a href="#3-visibility" class="headerlink" title="3.visibility"></a>3.visibility</h3><h3 id="4-表格布局属性"><a href="#4-表格布局属性" class="headerlink" title="4.表格布局属性"></a>4.表格布局属性</h3><table><thead><tr><th style="text-align:center">表格布局属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">aption-side</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">border-collapse</td><td style="text-align:left">表格边框是应折叠为单个边框还是按标准HTML分隔</td></tr><tr><td style="text-align:center">border-spacing</td><td style="text-align:left">相邻单元格边界之间的距离</td></tr><tr><td style="text-align:center">empty-cells</td><td style="text-align:left">是否在表格中的空单元格上显示边框</td></tr><tr><td style="text-align:center">table-layout</td><td style="text-align:left">布置表格单元格，行和列的算法</td></tr></tbody></table><h3 id="5-列表布局属性-均继承"><a href="#5-列表布局属性-均继承" class="headerlink" title="5.列表布局属性[均继承]"></a>5.列表布局属性[均继承]</h3><table><thead><tr><th style="text-align:center">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">list-style</td><td style="text-align:left">[type/image/position]</td></tr><tr><td style="text-align:center">list-style-type</td><td style="text-align:left">类型</td></tr><tr><td style="text-align:center">list-style-image</td><td style="text-align:left">图像</td></tr><tr><td style="text-align:center">list-style-position</td><td style="text-align:left">位置[inside/outside/initial/inherit];</td></tr></tbody></table><h3 id="6-引用属性-quotes"><a href="#6-引用属性-quotes" class="headerlink" title="6.引用属性:quotes"></a>6.引用属性:quotes</h3><p>引用的引号类型:none|string|initial|inherit;</p><h3 id="7-鼠标光标-cursor"><a href="#7-鼠标光标-cursor" class="headerlink" title="7.鼠标光标:cursor"></a>7.鼠标光标:cursor</h3><h3 id="8-打印属性-1"><a href="#8-打印属性-1" class="headerlink" title="8.打印属性"></a>8.打印属性</h3><table><thead><tr><th style="text-align:center">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">page</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">windows</td><td style="text-align:left">发生分页时必须在页面<strong>顶部</strong>保留的最少行数</td></tr><tr><td style="text-align:center">orphans</td><td style="text-align:left">生分页时必须在页面<strong>底部</strong>保留的最少行数</td></tr></tbody></table><h3 id="9-声音样式属性-1"><a href="#9-声音样式属性-1" class="headerlink" title="9.声音样式属性"></a>9.声音样式属性</h3><table><thead><tr><th style="text-align:center">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">speak</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">speak-punctuation</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">speak-numeral</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">speak-header</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">speech-rate</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">volume</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">voice-family</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">pitch</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">pitch-range</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">stress</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">richness</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">azimuth</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">elevation</td><td style="text-align:left"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS-属性继承-待完善&quot;&gt;&lt;a href=&quot;#CSS-属性继承-待完善&quot; class=&quot;headerlink&quot; title=&quot;CSS_属性继承 [待完善]&quot;&gt;&lt;/a&gt;CSS_属性继承 &lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;哪些属性可继承？？呃。。。往下看。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="CSS" scheme="https://hotkang.cn/tags/CSS/"/>
    
      <category term="属性继承" scheme="https://hotkang.cn/tags/%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统四</title>
    <link href="https://hotkang.cn/2018/06/19/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9B%9B/"/>
    <id>https://hotkang.cn/2018/06/19/图书管理系统四/</id>
    <published>2018-06-19T15:49:33.000Z</published>
    <updated>2018-07-26T18:15:23.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现具体功能-完结"><a href="#实现具体功能-完结" class="headerlink" title="实现具体功能 [完结]"></a>实现具体功能 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>所有的功能实现都在写在这里了。</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://www.alloyteam.com/2015/03/sexpressmysql/" target="_blank" rel="noopener">参考教程1</a></li><li><a href="https://www.xiabingbao.com/node/2017/02/20/node-express-forum.html" target="_blank" rel="noopener">参考教程2</a>(划重点!)</li></ul><p>虽然前期看了教程1之后，功能没有实现，但是给教程2奠定一定的知识储备,建议都看看。</p></blockquote><hr><h2 id="一、先了解整体架构"><a href="#一、先了解整体架构" class="headerlink" title="一、先了解整体架构"></a>一、先了解整体架构</h2><p>仔细看看<a href="http://blog.fens.me/nodejs-express4/" target="_blank" rel="noopener">Node.js开发框架Express4.x</a> 下的以下部分</p><pre><code>2. 目录结构3. package.json项目配置4. app.js核心文件5.Bootstrap界面框架(选看,里面涉及到的重复代码前面讲过)6. 路由功能</code></pre><p><br></p><h2 id="二、跟着参考教程2完成注册-登录"><a href="#二、跟着参考教程2完成注册-登录" class="headerlink" title="二、跟着参考教程2完成注册/登录"></a>二、跟着<a href="https://www.xiabingbao.com/node/2017/02/20/node-express-forum.html" target="_blank" rel="noopener">参考教程2</a>完成注册/登录</h2><pre><code>看了很多网上的教程吧,只有教程2让我成功了,作者写的也非常用心超级仔细！！！！我只跟着敲了用户注册登录,后面基本很顺畅~</code></pre><p><br></p><h2 id="三、写在后面"><a href="#三、写在后面" class="headerlink" title="三、写在后面"></a>三、写在后面</h2><pre><code>看了所有推荐的链接,基本上就没有什么问题啦。知识本身不难,难得是我们要在网上找到靠谱的教程。</code></pre><p><br></p><h2 id="四、根据项目记录下一些具体的细节"><a href="#四、根据项目记录下一些具体的细节" class="headerlink" title="四、根据项目记录下一些具体的细节"></a>四、根据项目记录下一些具体的细节</h2><blockquote><h3 id="保持用户登录状态-app-js"><a href="#保持用户登录状态-app-js" class="headerlink" title="保持用户登录状态(app.js)"></a>保持用户登录状态(app.js)</h3></blockquote><ol><li><p>加载依赖库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cookieParser = require(&apos;cookie-parser&apos;);  </span><br><span class="line">var session = require(&apos;express-session&apos;);</span><br></pre></td></tr></table></figure></li><li><p>定义cookie解析器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    secret: &apos;hotyan&apos;,  // 用来对session id相关的cookie进行签名</span><br><span class="line">    saveUninitialized: true,  // 是否自动保存未初始化的会话，建议false</span><br><span class="line">    resave: false,  // 是否每次都重新保存会话，建议false</span><br><span class="line">    cookie: &#123;maxAge:  60*60 * 1000 &#125; // 有效期，单位是毫秒</span><br><span class="line">    &#125;))</span><br></pre></td></tr></table></figure></li><li><p>在app.js文件下添加自定义中间件,实现保持用户登录状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.use(function(req, res, next)&#123;</span><br><span class="line">    // 如果session中存在，则说明已经登录</span><br><span class="line">    if( req.session.hotyan )&#123;</span><br><span class="line">        res.locals.hotyan = &#123;</span><br><span class="line">            UserId : req.session.hotyan.UserId,</span><br><span class="line">            UserName : req.session.hotyan.UserName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.locals.hotyan = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    next();//此处必须有</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><br></p><blockquote><h3 id="数据库连接-models-db-js"><a href="#数据库连接-models-db-js" class="headerlink" title="数据库连接(models/db.js)"></a>数据库连接(models/db.js)</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var mysql = require(&apos;mysql&apos;);</span><br><span class="line">var pool = mysql.createPool(&#123;</span><br><span class="line">    host: &apos;localhost&apos;,</span><br><span class="line">    user: &apos;root&apos;,</span><br><span class="line">    password: &apos;XXXXXX&apos;,</span><br><span class="line">    database: &apos;XXXXXX&apos;</span><br><span class="line">&#125;);</span><br><span class="line">module.exports = pool;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><h3 id="Mysql语句-方法总结于教程2"><a href="#Mysql语句-方法总结于教程2" class="headerlink" title="Mysql语句(方法总结于教程2)"></a>Mysql语句(方法总结于教程2)</h3></blockquote><p>以对图书管理员进行增删改查为例,新建(SQL/adminSql.js)文件,将需要的Mysql语句全部独立出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//对bookadmin进行增删改查</span><br><span class="line">var admin = &#123;</span><br><span class="line">    /**添加图书管理员 */</span><br><span class="line">    insert :&apos;INSERT INTO `bookadmin` SET `BAId`=?, `BAName`=? ,`BAPassword`=?,`BAPhone`=?,`BAEmail`=?&apos;,</span><br><span class="line">    </span><br><span class="line">    /**修改图书管理员信息 */</span><br><span class="line">    update : &apos;UPDATE `bookadmin` SET `BAName`=? ,`BAPhone`=?,`BAEmail`=? WHERE `BAId`=?&apos;,</span><br><span class="line">    </span><br><span class="line">    /**删除图书管理员 */</span><br><span class="line">    delete: &apos;DELETE FROM `bookadmin` WHERE `BAId`=?&apos;,</span><br><span class="line">    </span><br><span class="line">    /**精确查看图书管理员信息 */</span><br><span class="line">    queryById : &apos;SELECT * FROM `bookadmin` WHERE `BAId`=?&apos;,</span><br><span class="line">    </span><br><span class="line">    /**查看全部图书管理员信息 */</span><br><span class="line">    queryAll : &apos;SELECT * FROM `bookadmin` &apos;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = admin;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><h3 id="实现功能的函数放置在-models-users-js"><a href="#实现功能的函数放置在-models-users-js" class="headerlink" title="实现功能的函数放置在(models/users.js)"></a>实现功能的函数放置在(models/users.js)</h3></blockquote><ol><li><p>加载依赖文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pool = require(&apos;./db&apos;), // 连接数据库</span><br><span class="line">    admin = require(&apos;../SQL/adminSql&apos;),//图书管理员的Mysql语句</span><br><span class="line">    crypto = require(&apos;crypto&apos;); // 对密码进行加密</span><br></pre></td></tr></table></figure></li><li><p>以添加图书管理员为例学习如何使用封装的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">adminadd: function (BAId, BAName, BAPassword, BAPhone, BAEmail, cb) &#123;</span><br><span class="line">    pool.getConnection(function (err, connection) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line"></span><br><span class="line">            connection.query(admin.insert, [BAId, BAName, BAPassword, BAPhone, BAEmail], function (err, result) &#123;</span><br><span class="line">                if (err) throw err;</span><br><span class="line">                    cb(result);</span><br><span class="line">                    connection.release();</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><p>【此处应了解一下query()方法,参数可2可3,query(mysql语句,内容数组,回调函数）;我把Mysql语句独立了出去,看了教程2就知道。】</p><p><br></p><blockquote><h3 id="表单提交POST请求"><a href="#表单提交POST请求" class="headerlink" title="表单提交POST请求"></a>表单提交POST请求</h3></blockquote><p>以添加图书管理员为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/badAddAdmin&quot; method=&quot;POST&quot; class=&quot;ad_data&quot;&gt;//注意1</span><br><span class="line">    &lt;div class=&quot;data&quot;&gt;</span><br><span class="line">        &lt;label&gt;管理号&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;输入图书管理员编号&quot; name=&quot;BAId&quot; /&gt;//注意2</span><br><span class="line">    &lt;/div&gt;   </span><br><span class="line">    ...     </span><br><span class="line">    &lt;div class=&quot;data&quot;&gt;</span><br><span class="line">        &lt;label&gt;邮箱&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;输入图书管理员邮箱&quot; name=&quot;BAEmail&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;input class=&quot;add_btn&quot; type=&quot;submit&quot; value=&quot;确认添加&quot; /&gt;//注意3    </span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>注意三个地方:</p><ol><li><code>action=&quot;/badAddAdmin&quot; method=&quot;POST&quot;</code></li><li><code>name=&quot;BAId&quot;</code></li><li><code>type=&quot;submit&quot;</code></li></ol><p><br></p><blockquote><h3 id="在-routes-index-js-中添加POST代码"><a href="#在-routes-index-js-中添加POST代码" class="headerlink" title="在(routes/index.js)中添加POST代码"></a>在(routes/index.js)中添加POST代码</h3></blockquote><p>以添加图书管理员界面为例:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.post(&apos;/badAddAdmin&apos;, function (req, res, next) &#123;</span><br><span class="line">/*获取表单传来的数据*/</span><br><span class="line">    var BAId = req.body.BAId || &apos;&apos;,</span><br><span class="line">        BAName = req.body.BAName || &apos;&apos;,</span><br><span class="line">        BAPassword = req.body.BAPassword || &apos;&apos;,</span><br><span class="line">        BAPhone = req.body.BAPhone || &apos;&apos;,</span><br><span class="line">        BAEmail = req.body.BAEmail || &apos;&apos;;</span><br><span class="line">    /*调用密码加密函数*/</span><br><span class="line">    var password_hash = user_m.hash(BAPassword);</span><br><span class="line">    /*调用添加图书管理员函数*/</span><br><span class="line">    user_m.adminadd(BAId, BAName, password_hash, BAPhone, BAEmail, function (result) &#123;</span><br><span class="line">        console.log(&quot;添加成功&quot;);</span><br><span class="line">        res.redirect(&apos;/badAddAdmin&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><h3 id="EJS循环渲染-查看界面需要"><a href="#EJS循环渲染-查看界面需要" class="headerlink" title="EJS循环渲染(查看界面需要)"></a>EJS循环渲染(查看界面需要)</h3></blockquote><p>在(routes/index.js)中加入:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.post(&apos;/badCheckAdmin&apos;, function (req, res, next) &#123;</span><br><span class="line">    console.log(req.body);</span><br><span class="line">    var BAId = req.body.BAId;</span><br><span class="line">    user_m.adminId(BAId, function (result) &#123;</span><br><span class="line">        console.log(&quot;精确查看成功&quot;);</span><br><span class="line">        res.render(&apos;badCheckAdmin&apos;, &#123;</span><br><span class="line">            title: &apos;查看图书管理员信息&apos;,</span><br><span class="line">            datas: result     //返回json数据,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>【返回json数据,需要依赖模块body-parser,此处应了解一下res.render() 】</p><p>在(views/badCheckAdmin.ejs)中渲染代码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line">    &lt;% for(var i=0;i&lt; datas.length;i++)&#123; %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td &gt;&lt;%= datas[i].BAId %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= datas[i].BAName %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= datas[i].BAPhone %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= datas[i].BAEmail %&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;% &#125;%&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><h3 id="日期格式YYYY-MM-DD"><a href="#日期格式YYYY-MM-DD" class="headerlink" title="日期格式YYYY-MM-DD"></a>日期格式YYYY-MM-DD</h3></blockquote><p>在(routes/index.js)文件中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*加载依赖模块*/</span><br><span class="line">var time = require(&apos;silly-datetime&apos;)</span><br><span class="line"></span><br><span class="line">/*在需要的地方使用,以注册时间为例*/</span><br><span class="line">RegTime = time.format(new Date(), &apos;YYYY-MM-DD&apos;);</span><br></pre></td></tr></table></figure><p><br></p><blockquote><h3 id="图书应该归还日期-30天后"><a href="#图书应该归还日期-30天后" class="headerlink" title="图书应该归还日期(30天后)"></a>图书应该归还日期(30天后)</h3></blockquote><p>在(models/users.js)中添加date方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">date: function (AddDay) &#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    /*****获取AddDay天后的日期 ********/</span><br><span class="line">    date.setDate(date.getDate() + AddDay);</span><br><span class="line"></span><br><span class="line">    var Y = date.getFullYear(),</span><br><span class="line"></span><br><span class="line">    /***** 获取当前月份的日期，不足10补0 *****/</span><br><span class="line">        M = (date.getMonth() + 1) &lt; 10 ? &quot;0&quot; + (date.getMonth() + 1) : (date.getMonth() + 1),</span><br><span class="line"></span><br><span class="line">        /****获取当前几号，不足10补0  ****/</span><br><span class="line">        D = date.getDate() &lt; 10 ? &quot;0&quot; + date.getDate() : date.getDate();</span><br><span class="line"></span><br><span class="line">    return Y + &quot;-&quot; + M + &quot;-&quot; + D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在(routes/index.js)借书界面调用date方法:</p><pre><code>var ShouldTime = user_m.date(30);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现具体功能-完结&quot;&gt;&lt;a href=&quot;#实现具体功能-完结&quot; class=&quot;headerlink&quot; title=&quot;实现具体功能 [完结]&quot;&gt;&lt;/a&gt;实现具体功能 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;所有的功能实现都在写在这里了。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql命令小结</title>
    <link href="https://hotkang.cn/2018/06/19/Mysql%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>https://hotkang.cn/2018/06/19/Mysql命令小结/</id>
    <published>2018-06-19T14:04:20.000Z</published>
    <updated>2018-07-26T18:16:42.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql语句-持续完善"><a href="#Mysql语句-持续完善" class="headerlink" title="Mysql语句 [持续完善]"></a>Mysql语句 <span style="font-size:.5em">[持续完善]</span></h2><blockquote><p>常用命令小结</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://juejin.im/post/5ae55861f265da0ba062ec71" target="_blank" rel="noopener">参考链接</a></li></ul></blockquote><hr><h2 id="一、DATABASE"><a href="#一、DATABASE" class="headerlink" title="一、DATABASE"></a>一、DATABASE</h2><p>新建数据库：</p><pre><code>CREATE DATABASE database_name;</code></pre><p>删除数据库：</p><pre><code>DROP DATABASE database_name;</code></pre><p>查看所有可用的数据库：</p><pre><code>SHOW DATABASES;  </code></pre><p>选择数据库：</p><pre><code>USE database_name;</code></pre><p>显示数据库服务器的状态信息：</p><pre><code>SHOW STATUS;  </code></pre><p>获取当前所选的数据库中所有可用的表：</p><pre><code>SHOW TABLES; </code></pre><p>获取表中所有列的信息：</p><pre><code>SHOW COLUMNS FROM table_name; </code></pre><p><br></p><h2 id="二、TABLE"><a href="#二、TABLE" class="headerlink" title="二、TABLE"></a>二、TABLE</h2><p>新建表:</p><pre><code>CREATE TABLE table_name;</code></pre><p>删除表,使用DROP TABLE子句:</p><pre><code>DROP TABLE table_name。</code></pre><p>清空表中记录:</p><pre><code>delete from table_name;</code></pre><p>显示表中的记录:</p><pre><code>select * from table_name;</code></pre><p><br></p><h2 id="三、导入导出"><a href="#三、导入导出" class="headerlink" title="三、导入导出"></a>三、导入导出</h2><p>导入.sql</p><pre><code>source .sql文件路径</code></pre><p>备份数据,导出.sql文件</p><pre><code>cd 存放目录mysqldump -u root_name -p database_name&gt;file_name.sql例如:mysqldump -u root -p hotyan&gt;db.sql</code></pre><p>退出MYSQL命令:</p><pre><code>exit(回车)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mysql语句-持续完善&quot;&gt;&lt;a href=&quot;#Mysql语句-持续完善&quot; class=&quot;headerlink&quot; title=&quot;Mysql语句 [持续完善]&quot;&gt;&lt;/a&gt;Mysql语句 &lt;span style=&quot;font-size:.5em&quot;&gt;[持续完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;常用命令小结&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/Mysql/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统三</title>
    <link href="https://hotkang.cn/2018/06/11/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%89/"/>
    <id>https://hotkang.cn/2018/06/11/图书管理系统三/</id>
    <published>2018-06-11T15:24:23.000Z</published>
    <updated>2018-07-26T18:17:53.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Use-Homebre-Install-Mysql-完结"><a href="#Use-Homebre-Install-Mysql-完结" class="headerlink" title="Use Homebre Install Mysql [完结]"></a>Use Homebre Install Mysql <span style="font-size:.5em">[完结]</span></h2><blockquote><p>安装Mysql,你可能会进入Mysql官网,下载安装适合你自己电脑的版本,我用的Mac,所以我继续看了一下在【macOS上安装MySQL】,然后就跟着操作,结果不成功,解决不了？？？卸载试试？？？重新安装,依旧失败~</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/installing.html" target="_blank" rel="noopener">Mysql官网</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/osx-installation.html" target="_blank" rel="noopener">在macOS上安装MySQL</a></li><li><a href="https://brew.sh/" target="_blank" rel="noopener">homebrew官网</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html" target="_blank" rel="noopener">本文参考链接</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/MySql/index.html" target="_blank" rel="noopener">YouTube视频教程</a>(划重点,是这个视频让我成功的！！！)</li></ul></blockquote><hr><h2 id="一、安装homebrew"><a href="#一、安装homebrew" class="headerlink" title="一、安装homebrew"></a>一、安装homebrew</h2><p>请参考<a href="https://hotyan.github.io/2018/05/29/use%20homebrew%20install%20mongodb/" target="_blank" rel="noopener">Mac Use Homebrew Install Mongodb</a>,那里有详细记录,这边不再赘述</p><p><br></p><h2 id="二、安装Mysql"><a href="#二、安装Mysql" class="headerlink" title="二、安装Mysql"></a>二、安装Mysql</h2><blockquote><p>1.终端下运行以下命令</p></blockquote><pre><code>$ brew install mysql</code></pre><p>【暂时忽略你看到的一些提示！！！】</p><blockquote><p>2.启动Mysql服务器</p></blockquote><p>先把服务器start再说</p><pre><code>$ brew services start mysql</code></pre><p>【现在可以跟着你看到的提示一步一步来！！！】</p><blockquote><p>3.先安全登录Mysql</p></blockquote><p>运行提示一:</p><pre><code>$ mysql_secure_installation  </code></pre><ul><li><p>根据提示设置user root密码</p><pre><code>Enter password for user root：（此处输入你的密码）</code></pre></li><li><p>根据提示进行设置</p><pre><code>可一路yes</code></pre></li><li><p>设置完后，你会看到提示</p><pre><code>All done！</code></pre></li></ul><blockquote><p>4.连接Mysql</p></blockquote><p>运行提示二:</p><pre><code>$ mysql -uroot</code></pre><p>或者</p><pre><code>$ mysql -u root -p    </code></pre><p>回车后,输入刚刚设置的密码：</p><pre><code>Enter password：</code></pre><blockquote><p>5.success！</p></blockquote><p>成功之后,就可以对Mysql进行操作啦</p><blockquote><p>6.退出mysql</p></blockquote><pre><code>mysql&gt; exitBye</code></pre><blockquote><p>7.关闭mysql服务器</p></blockquote><pre><code>$ brew services start mysql</code></pre><blockquote><p>8.配置.bash_profile</p></blockquote><p>先查看你的mysql安装在哪</p><pre><code>$ which mysql</code></pre><p>比如我返回的是</p><pre><code>/usr/local/Cellar/mysql/5.7.22/bin/mysql</code></pre><p>打开.bash_profile文件</p><pre><code>$ open ~/.bash_profile</code></pre><p>将下面这行代码加入.bash_profile</p><pre><code>export PATH=&quot;/usr/local/Cellar/mysql/5.7.22/bin:$PATH&quot;</code></pre><p>保存,退出后,保存新配置</p><pre><code>$ source ~/.bash_profile</code></pre><blockquote><p>9.运行流程</p></blockquote><p>开启服务器:</p><pre><code>$ brew services start mysql</code></pre><p>登录Mysql:</p><pre><code>$ mysql -u root -p</code></pre><p>操作Mysql:</p><ul><li>可参考<a href="https://hotyan.github.io/2018/06/19/Mysql%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">Mysql指令小结</a></li></ul><p>退出Mysql:</p><pre><code>mysql&gt;exitBye</code></pre><p>关闭服务器</p><pre><code>$ brew services stop mysql</code></pre><blockquote><p>10.基本完成</p></blockquote><p>其实我遇到过很多问题，也尝试解决，Google了很多，并没有很成功的解决问题，课设期间时间也比较有限，所以在尝试解决不成功后，出现问题我选择卸载，重新安装~</p><p>根据上面打开流程，基本不会再出差啦</p><p><br></p><h2 id="三、卸载Mysql"><a href="#三、卸载Mysql" class="headerlink" title="三、卸载Mysql"></a>三、卸载Mysql</h2><blockquote><p>1.打开终端,依次输入</p></blockquote><pre><code>$ brew remove mysql$ brew cleanup$ sudo rm /usr/local/mysql$ sudo rm -rf /usr/local/var/mysql$ sudo rm -rf /usr/local/mysql*$ sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ sudo rm -rf /Library/StartupItems/MySQLCOM$ sudo rm -rf /Library/PreferencePanes/My*</code></pre><blockquote><p>2.查看是否成功</p></blockquote><pre><code>$ mysql</code></pre><p>提示mysql 没有发现，多半就可以了。（其实我也不确定哈，只是我这样就可以~）</p><blockquote><p>3.最后重启电脑重新安装即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Use-Homebre-Install-Mysql-完结&quot;&gt;&lt;a href=&quot;#Use-Homebre-Install-Mysql-完结&quot; class=&quot;headerlink&quot; title=&quot;Use Homebre Install Mysql [完结]&quot;&gt;&lt;/a&gt;Use Homebre Install Mysql &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;安装Mysql,你可能会进入Mysql官网,下载安装适合你自己电脑的版本,我用的Mac,所以我继续看了一下在【macOS上安装MySQL】,然后就跟着操作,结果不成功,解决不了？？？卸载试试？？？重新安装,依旧失败~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Install" scheme="https://hotkang.cn/categories/Install/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/categories/Install/Mysql/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
      <category term="Homebrew" scheme="https://hotkang.cn/tags/Homebrew/"/>
    
      <category term="Node.js" scheme="https://hotkang.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统二</title>
    <link href="https://hotkang.cn/2018/06/11/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BA%8C/"/>
    <id>https://hotkang.cn/2018/06/11/图书管理系统二/</id>
    <published>2018-06-11T15:24:16.000Z</published>
    <updated>2018-07-26T18:19:01.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EJS模板引擎-完结"><a href="#EJS模板引擎-完结" class="headerlink" title="EJS模板引擎 [完结]"></a>EJS模板引擎 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>初步渲染页面~</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">EJS官网</a></li></ul></blockquote><hr><h2 id="一、首先来了解一下项目结构"><a href="#一、首先来了解一下项目结构" class="headerlink" title="一、首先来了解一下项目结构"></a>一、首先来了解一下项目结构</h2><pre><code>.├── app.js  //程序启动文件├── bin│   └── www├── package.json  //项目依赖配置及开发者信息├── public        //静态文件(存css,js,img)│   ├── images│   ├── javascripts│   └── stylesheets│       └── style.css├── routes          //路由文件│   ├── index.js│   └── users.js└── views           //页面文件(ejs模板)    ├── error.ejs    ├── index.ejs    └── layout.ejs</code></pre><p><br></p><h2 id="二、渲染界面"><a href="#二、渲染界面" class="headerlink" title="二、渲染界面"></a>二、渲染界面</h2><blockquote><p>1.对views文件夹进行操作:</p></blockquote><pre><code>在现有的首页index.ejs里面加入你的首页界面代码新建注册界面reg.ejs,并加入该界面代码新建登录界面login.ejs,并加入该界面代码...</code></pre><p><br></p><blockquote><p>2.对routes文件夹进行操作</p></blockquote><p>在<code>index.js</code>文件里面分别渲染<code>index.ejs</code>、<code>reg.ejs</code> 、<code>login.ejs</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.render(&apos;index&apos;, &#123;</span><br><span class="line">        title: &apos;index&apos;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/reg&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.render(&apos;reg&apos;, &#123;</span><br><span class="line">        title: &apos;reg&apos;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/login&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.render(&apos;login&apos;, &#123;</span><br><span class="line">        title: &apos;login&apos;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><p>3.将相同代码独立出来</p></blockquote><p>比如我的(基本资料/修改资料/借书/还书/借阅记录)这5个界面,上半部分是重复代码。</p><p>新建<code>TopBar.ejs</code>,放置重复代码,在其他五个界面添加<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- include TopBar %&gt;</span><br></pre></td></tr></table></figure><p></p><p>所有重复代码以此类推</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;EJS模板引擎-完结&quot;&gt;&lt;a href=&quot;#EJS模板引擎-完结&quot; class=&quot;headerlink&quot; title=&quot;EJS模板引擎 [完结]&quot;&gt;&lt;/a&gt;EJS模板引擎 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;初步渲染页面~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
      <category term="Express" scheme="https://hotkang.cn/tags/Express/"/>
    
      <category term="EJS" scheme="https://hotkang.cn/tags/EJS/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统一</title>
    <link href="https://hotkang.cn/2018/06/11/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%80/"/>
    <id>https://hotkang.cn/2018/06/11/图书管理系统一/</id>
    <published>2018-06-11T15:24:02.000Z</published>
    <updated>2018-07-26T18:19:38.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-完结"><a href="#Express-完结" class="headerlink" title="Express [完结]"></a>Express <span style="font-size:.5em">[完结]</span></h2><blockquote><p>图书管理系统大家应该都不陌生~<br>老师对大一的说：写一个图书管理系统吧？！！！<br>老师对大二的说：写一个图书管理系统！！！！<br>老师对大三的说：写一个图书管理系统！<br>大一的图书管理系统VS大三的图书管理系统？？</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><h3 id="个人比较喜欢先甩参考链接-可以选择直接去看参考链接。"><a href="#个人比较喜欢先甩参考链接-可以选择直接去看参考链接。" class="headerlink" title="个人比较喜欢先甩参考链接,可以选择直接去看参考链接。"></a>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</h3><ul><li><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">Express官网</a></li></ul></blockquote><hr><p>首先默认你已经安装了 Node.js,没有装的可以参考<a href="https://hotyan.github.io/2018/05/30/%E7%94%A8nvm%E8%A3%85node-js/" target="_blank" rel="noopener">用nvm装node.js</a></p><h2 id="一、为你的应用创建一个目录（-hotyan）"><a href="#一、为你的应用创建一个目录（-hotyan）" class="headerlink" title="一、为你的应用创建一个目录（/hotyan）"></a>一、为你的应用创建一个目录（/hotyan）</h2><pre><code>$ mkdir hotyan</code></pre><p><br></p><h2 id="二、进入此目录并将其作为当前工作目录"><a href="#二、进入此目录并将其作为当前工作目录" class="headerlink" title="二、进入此目录并将其作为当前工作目录"></a>二、进入此目录并将其作为当前工作目录</h2><pre><code>$ cd hotyan</code></pre><p><br></p><h2 id="三、install-Express应用生成器"><a href="#三、install-Express应用生成器" class="headerlink" title="三、install Express应用生成器"></a>三、install Express应用生成器</h2><p>通过应用生成器工具 express 可以快速创建一个应用的骨架。</p><p>通过如下命令安装：</p><pre><code>$ npm install express-generator -g</code></pre><p><br></p><h2 id="四、创建工作项目"><a href="#四、创建工作项目" class="headerlink" title="四、创建工作项目"></a>四、创建工作项目</h2><p>当前工作目录下（/hotyan）创建一个命名为 Librarys 的工作项目。</p><pre><code>$ express --view=ejs  Libraryscreate : Librarys/create : Librarys/public/create : Librarys/public/javascripts/create : Librarys/public/images/create : Librarys/public/stylesheets/create : Librarys/public/stylesheets/style.csscreate : Librarys/routes/create : Librarys/routes/index.jscreate : Librarys/routes/users.jscreate : Librarys/views/create : Librarys/views/error.ejscreate : Librarys/views/index.ejscreate : Librarys/app.jscreate : Librarys/package.jsoncreate : Librarys/bin/create : Librarys/bin/wwwchange directory:    $ cd Librarysinstall dependencies:    $ npm installrun the app:    $ DEBUG=librarys:* npm start</code></pre><p><br></p><h2 id="五、进入Library并安装依赖包"><a href="#五、进入Library并安装依赖包" class="headerlink" title="五、进入Library并安装依赖包"></a>五、进入Library并安装依赖包</h2><pre><code>$ cd Librarys$ npm install</code></pre><p><br></p><h2 id="六、启动这个项目（MacOS-或-Linux-平台）"><a href="#六、启动这个项目（MacOS-或-Linux-平台）" class="headerlink" title="六、启动这个项目（MacOS 或 Linux 平台）"></a>六、启动这个项目（MacOS 或 Linux 平台）</h2><pre><code>$ DEBUG=librarys:* npm start</code></pre><p><br></p><h2 id="七、在浏览器打开-http-localhost-3000"><a href="#七、在浏览器打开-http-localhost-3000" class="headerlink" title="七、在浏览器打开 http://localhost:3000/"></a>七、在浏览器打开 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Express-完结&quot;&gt;&lt;a href=&quot;#Express-完结&quot; class=&quot;headerlink&quot; title=&quot;Express [完结]&quot;&gt;&lt;/a&gt;Express &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;图书管理系统大家应该都不陌生~&lt;br&gt;老师对大一的说：写一个图书管理系统吧？！！！&lt;br&gt;老师对大二的说：写一个图书管理系统！！！！&lt;br&gt;老师对大三的说：写一个图书管理系统！&lt;br&gt;大一的图书管理系统VS大三的图书管理系统？？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Node.js" scheme="https://hotkang.cn/tags/Node-js/"/>
    
      <category term="Express" scheme="https://hotkang.cn/tags/Express/"/>
    
      <category term="EJS" scheme="https://hotkang.cn/tags/EJS/"/>
    
  </entry>
  
  <entry>
    <title>用nvm装node.js</title>
    <link href="https://hotkang.cn/2018/05/30/%E7%94%A8nvm%E8%A3%85node-js/"/>
    <id>https://hotkang.cn/2018/05/30/用nvm装node-js/</id>
    <published>2018-05-30T14:23:44.000Z</published>
    <updated>2018-07-26T18:20:14.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于node安装-完结"><a href="#关于node安装-完结" class="headerlink" title="关于node安装  [完结]"></a>关于node安装 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>本地安装？全局安装？nvm安装？傻傻分不清楚？<br>使用 nvm 管理不同版本的 node 与 npm</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li>了解<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">NVM</a></li><li>了解<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></li><li>了解<a href="https://nodejs.org/en/download/package-manager/" target="_blank" rel="noopener">通过包管理器安装Node.js</a>NVM部分</li><li>了解<a href="https://www.npmjs.com/get-npm" target="_blank" rel="noopener">NPM</a></li><li><a href="https://www.runoob.com/w3cnote/nvm-manager-node-versions.html" target="_blank" rel="noopener">本文参考链接</a></li></ul></blockquote><hr><h2 id="一、卸载全局安装的-node"><a href="#一、卸载全局安装的-node" class="headerlink" title="一、卸载全局安装的 node"></a>一、卸载全局安装的 node</h2><p>在官网下载的 node 安装包,运行后会自动安装在全局目录,使用过程中经常会遇到一些权限问题,用以下方法卸载全局安装的 node。(不需要卸载则跳过此步骤)</p><blockquote><p>1.删除 node 和 node_modules 相关的文件和文件夹</p></blockquote><p>打开Finder,按 shift+command+G 来打开前往文件夹的窗口,分别进入下列目录,删除 node 和 node_modules 相关的文件和文件夹</p><pre><code>/usr/local/lib/usr/local/include</code></pre><blockquote><p>2.如果你是使用的 brew install node 安装的,还需要在终端中执行以下命令来卸载</p></blockquote><pre><code>$ brew uninstall node </code></pre><blockquote><p>3.检查 node 和 node_modules 相关文件/文件夹是否删除成功</p></blockquote><p>检查个人主文件夹下面的所有的 local、lib 以及 include 文件夹，并且删除所有与 node 和 node_modules 相关的文件以及文件夹</p><blockquote><p>4.进入 /usr/local/bin 并删除 node 可执行文件</p></blockquote><blockquote><p>5.你可能还需要在终端中输入一些额外的指令</p></blockquote><pre><code>$ sudo rm /usr/local/bin/npm$ sudo rm /usr/local/share/man/man1/node.1$ sudo rm /usr/local/lib/dtrace/node.d$ sudo rm -rf ~/.npm$ sudo rm -rf ~/.node-gyp$ sudo rm /opt/local/bin/node$ sudo rm /opt/local/include/node$ sudo rm -rf /opt/local/lib/node_modules</code></pre><p><br></p><h2 id="二、OSX-安装-NVM"><a href="#二、OSX-安装-NVM" class="headerlink" title="二、OSX 安装 NVM"></a>二、OSX 安装 NVM</h2><blockquote><p>用 X-Code 的命令行工具</p></blockquote><p>运行以下命令</p><pre><code>$ xcode-select --install$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</code></pre><p><br></p><h2 id="三、安装多版本-node"><a href="#三、安装多版本-node" class="headerlink" title="三、安装多版本 node"></a>三、安装多版本 node</h2><p>查看远程服务器上所有的可用版本</p><pre><code>$ nvm ls-remote</code></pre><p>安装最新版 Node</p><pre><code>$ nvm install node </code></pre><p>安装某一版本(4.2.2)</p><pre><code>$ nvm install 4.2.2</code></pre><p>安装4.2 系列的最新的一个版本</p><pre><code>$ nvm install 4.2</code></pre><p>nvm 遵守语义化版本命名规则,nvm 会寻找 4.2.x 中最高的版本来安装。</p><p><br></p><h2 id="四、在不同版本间切换"><a href="#四、在不同版本间切换" class="headerlink" title="四、在不同版本间切换"></a>四、在不同版本间切换</h2><p>每当安装了一个新版本 Node 后,全局环境会自动把这个新版本设置为默认。</p><blockquote><p>nvm 提供 nvm use 命令用于版本切换</p></blockquote><p>切换到最新版：</p><pre><code>$ nvm use node</code></pre><p>切换到 4.2.2：</p><pre><code>$ nvm use 4.2.2</code></pre><p>切换到最新的 4.2.x：</p><pre><code>$ nvm use 4.2</code></pre><p>每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。</p><p><br></p><h2 id="五、用-nvm-给不同的版本号设置别名"><a href="#五、用-nvm-给不同的版本号设置别名" class="headerlink" title="五、用 nvm 给不同的版本号设置别名"></a>五、用 nvm 给不同的版本号设置别名</h2><p>给4.2.2 版本号起个别名hotyan-version</p><pre><code>$ nvm alias hotyan-version 4.2.2</code></pre><p>运行:</p><pre><code>$ nvm use hotyan-version</code></pre><p>取消别名：</p><pre><code>$ nvm unalias hotyan-version  </code></pre><p><br></p><h2 id="六、列出已安装实例"><a href="#六、列出已安装实例" class="headerlink" title="六、列出已安装实例"></a>六、列出已安装实例</h2><pre><code>$ nvm ls</code></pre><p><br></p><h2 id="七、确认某个版本Node的路径"><a href="#七、确认某个版本Node的路径" class="headerlink" title="七、确认某个版本Node的路径"></a>七、确认某个版本Node的路径</h2><pre><code>$ nvm which 4.2.2</code></pre><p><br></p><h2 id="八、检查是否成功安装node和npm"><a href="#八、检查是否成功安装node和npm" class="headerlink" title="八、检查是否成功安装node和npm"></a>八、检查是否成功安装node和npm</h2><p>当成功下载Node.js时,会自动安装npm。</p><p>检查Node:</p><pre><code>$ node -v</code></pre><p>确认npm:</p><pre><code>$ npm -v</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于node安装-完结&quot;&gt;&lt;a href=&quot;#关于node安装-完结&quot; class=&quot;headerlink&quot; title=&quot;关于node安装  [完结]&quot;&gt;&lt;/a&gt;关于node安装 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;本地安装？全局安装？nvm安装？傻傻分不清楚？&lt;br&gt;使用 nvm 管理不同版本的 node 与 npm&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Install" scheme="https://hotkang.cn/categories/Install/"/>
    
      <category term="Node.js" scheme="https://hotkang.cn/categories/Install/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://hotkang.cn/tags/Node-js/"/>
    
      <category term="NVM" scheme="https://hotkang.cn/tags/NVM/"/>
    
      <category term="NPM" scheme="https://hotkang.cn/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>用hexo搭建github博客二</title>
    <link href="https://hotkang.cn/2018/05/29/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E4%BA%8C/"/>
    <id>https://hotkang.cn/2018/05/29/用hexo搭建github博客二/</id>
    <published>2018-05-29T07:39:01.000Z</published>
    <updated>2018-07-26T18:22:56.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优化博客-持续完善"><a href="#优化博客-持续完善" class="headerlink" title="优化博客 [持续完善]"></a>优化博客 <span style="font-size:.5em">[持续完善]</span></h2><blockquote><p>搜索了很多Next主题的效果，总结了下常用的效果~</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next使用文档</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">参考链接1</a></li><li><a href="https://www.jianshu.com/p/efbeddc5eb19" target="_blank" rel="noopener">参考链接2</a></li><li><a href="https://www.vincentqin.tech/posts/build-a-website-using-hexo/" target="_blank" rel="noopener">参考链接3</a></li><li><a href="http://devinol.com/Hexo/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E4%B8%89/" target="_blank" rel="noopener">参考链接4</a></li><li><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题</a></li></ul></blockquote><hr><h2 id="一、修改Next主题模式"><a href="#一、修改Next主题模式" class="headerlink" title="一、修改Next主题模式"></a>一、修改Next主题模式</h2><blockquote><p>修改themes/next/_config.yml文件Schemes属性</p></blockquote><p>注意不要跟根目录下的_config.yml混淆</p><pre><code># Schemes    #scheme: Muse       #scheme: Mist    scheme: Pisces    #scheme: Gemini</code></pre><p>NexT主题默认使用Muse模式,根据自己的喜好选择。<br><del>我比较喜欢Pisces ,对源码做了些样式修改。</del><br>后来我喜欢上了Gemini。<br>Gemini跟Pisce相似,而且Gemini的源码样式是在Pisce的基础上重写的。</p><p><br></p><blockquote><p>更新Hexo部署</p></blockquote><p>每次修改后都可以更新部署,也可最后再一次性部署。后面不再赘述。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cd  HotYan_Blog //进入博客文件夹目录</span><br><span class="line"></span><br><span class="line">$ hexo clean    // 清理缓存</span><br><span class="line">$ hexo generate // 生成文件</span><br><span class="line">$ hexo deploy   // 线上部署</span><br><span class="line"></span><br><span class="line">/*简写如下*/</span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="二、设置首页预览摘要"><a href="#二、设置首页预览摘要" class="headerlink" title="二、设置首页预览摘要"></a>二、设置首页预览摘要</h2><p>了解一下官网【Next使用文档】【<a href="https://theme-next.iissnan.com/faqs.html#read-more" target="_blank" rel="noopener">如何设置阅读全文</a>】介绍的三种方法</p><p>我使用的是用<code>&lt;!-- more --&gt;</code>进行手动截断</p><p><br></p><h2 id="三、侧边栏显示效果"><a href="#三、侧边栏显示效果" class="headerlink" title="三、侧边栏显示效果"></a>三、侧边栏显示效果</h2><blockquote><p>修改themes/next/_config.yml文件sidebar属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">        # Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">        position: left</span><br><span class="line">        #position: right //修改侧边栏位置</span><br><span class="line"></span><br><span class="line">        # Sidebar Display, available value (only for Muse | Mist):</span><br><span class="line">        #  - post    expand on posts automatically. Default.</span><br><span class="line">        #  - always  expand for all pages automatically</span><br><span class="line">        #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">        #  - remove  Totally remove sidebar including sidebar toggle.</span><br><span class="line">        #display: post      //默认</span><br><span class="line">        display: always     //一直显示</span><br><span class="line">        #display: hide      //初始隐藏</span><br><span class="line">        #display: remove    //移除侧边栏</span><br></pre></td></tr></table></figure><p>根据提示,设置自己喜欢的样式,我是Pisces主题,设置侧边栏在左边,且一直显示。</p><p><br></p><h2 id="四、侧边栏社交链接"><a href="#四、侧边栏社交链接" class="headerlink" title="四、侧边栏社交链接"></a>四、侧边栏社交链接</h2><blockquote><p>修改themes/next/_config.yml文件social属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*文字链接*/</span><br><span class="line">social:</span><br><span class="line">   GitHub: https://github.com/hotYan || github</span><br><span class="line">   E-Mail: mailto:15823566422@163.com || envelope</span><br><span class="line">/*链接前图标*/</span><br><span class="line">social_icons:</span><br><span class="line">   enable: true</span><br><span class="line">   GitHub: github</span><br></pre></td></tr></table></figure><p>我只添加了GitHub、E-Mail。</p><p><br></p><h2 id="五、设置RSS"><a href="#五、设置RSS" class="headerlink" title="五、设置RSS"></a>五、设置RSS</h2><blockquote><p>安装 hexo-generator-feed 插件</p></blockquote><p>RSS需要有一个Feed链接，而这个链接需要靠hexo-generator-feed插件来生成</p><pre><code>$ cd HotYan_Blog$ npm install hexo-generator-feed --save</code></pre><p><br></p><blockquote><p>修改/_config.yml文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#type: RSS的类型(atom/rss2)</span><br><span class="line">#path: 文件路径,默认是atom.xml/rss2.xml</span><br><span class="line">#limit:展示文章的数量,使用0或则false代表展示全部</span><br><span class="line"></span><br><span class="line"># RSS订阅插件</span><br><span class="line">feed: </span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: 0</span><br><span class="line">#RSS订阅支持</span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>修改themes/next/_config.yml文件rss属性</p></blockquote><pre><code>rss: /atom.xml </code></pre><p><br></p><h2 id="六、添加菜单选项"><a href="#六、添加菜单选项" class="headerlink" title="六、添加菜单选项"></a>六、添加菜单选项</h2><p>默认情况下，菜单导航栏有首页、归档、关于三个选项，我们可以自行添加</p><blockquote><p>修改themes/next/_config.yml文件menu属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">        home: / || home                //默认有</span><br><span class="line">        about: /about/ || user         // 默认有</span><br><span class="line">        tags: /tags/ || tags            //自行添加</span><br><span class="line">        categories: /categories/ || th  //自行添加</span><br><span class="line">        archives: /archives/ || archive   //默认有</span><br></pre></td></tr></table></figure><p>比如我添加了tags、categories</p><p><br></p><blockquote><p>创建文件夹</p></blockquote><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo new page &quot;tags&quot;$ hexo new page &quot;categories&quot;</code></pre><p><br></p><blockquote><p>修改index.md</p></blockquote><p>在/source/目录下创建了categories、tags文件夹,在这些文件夹中分别会创建一个index.md文件,对内容type进行修改，使之分别为:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-05-29 00:02:39</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-05-29 00:02:54</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><br></p><h2 id="七、修改文章底部标签样式"><a href="#七、修改文章底部标签样式" class="headerlink" title="七、修改文章底部标签样式"></a>七、修改文章底部标签样式</h2><blockquote><p>修改/themes/next/layout/_macro/post.swig文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;post-tags&quot;&gt;  </span><br><span class="line">  &#123;% for tag in post.tags %&#125;</span><br><span class="line">     &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><p><br></p><h2 id="八、文章末尾添加结束标记"><a href="#八、文章末尾添加结束标记" class="headerlink" title="八、文章末尾添加结束标记"></a>八、文章末尾添加结束标记</h2><blockquote><p>在/themes/next/layout/_macro新建passage-end-tag.swig</p></blockquote><p>添加以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">            &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt; - END - &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>修改/themes/next/layout/_macro/post.swig文件</p></blockquote><p>在下面相应的位置添加添加相应的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/*插入代码如下*/</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include&apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*插入到此处结束*/</span><br><span class="line"></span><br><span class="line">&lt;footer class=&quot;post-footer&quot;&gt;</span><br><span class="line">   &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><del>看参考文档的时候觉得代码插入的地方描述的不是很清楚</del><br><del>觉得自己描述的很清楚了</del></p><p><br></p><blockquote><p>修改themes/next/_config.yml文件</p></blockquote><p>在任意地方添加下面代码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加结束标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">        enabled: true</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="九、访问量统计"><a href="#九、访问量统计" class="headerlink" title="九、访问量统计"></a>九、访问量统计</h2><h4 id="1-busuanzi统计"><a href="#1-busuanzi统计" class="headerlink" title="1.busuanzi统计"></a>1.busuanzi统计</h4><blockquote><p>修改themes/next/_config.yml文件busuanzi_count属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">        # count values only if the other configs are false</span><br><span class="line">        enable: true </span><br><span class="line"></span><br><span class="line">        # 站点UV配置 总访问人次(一个人访问多篇文章记录一次)</span><br><span class="line">        site_uv: false</span><br><span class="line">        site_uv_header: 总访问量</span><br><span class="line">        site_uv_footer:</span><br><span class="line"></span><br><span class="line">        # 站点PV配置 总访问量(一个人访问多篇文章记录多次)</span><br><span class="line">        site_pv: false</span><br><span class="line">        site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">        site_pv_footer: 次</span><br><span class="line"></span><br><span class="line">        # 文章PV配置 访问量</span><br><span class="line">        page_pv: true</span><br><span class="line">        page_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">        page_pv_footer:</span><br></pre></td></tr></table></figure><p><del>我只设置了文章访问量</del></p><p><a href="https://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">更多&gt;&gt;</a></p><p><br></p><h4 id="2-LeanCloud统计文章阅读量"><a href="#2-LeanCloud统计文章阅读量" class="headerlink" title="2.LeanCloud统计文章阅读量"></a>2.LeanCloud统计文章阅读量</h4><p>【<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a>】</p><p><br></p><h2 id="十、修改头像"><a href="#十、修改头像" class="headerlink" title="十、修改头像"></a>十、修改头像</h2><blockquote><p>在themes/next/source/images下放置头像</p></blockquote><blockquote><p>修改themes/next/_config.yml文件avatar属性</p></blockquote><pre><code>#avatar: 路径为头像目录avatar: ../images/avata.gif     </code></pre><p><br></p><h2 id="十一、添加背景图"><a href="#十一、添加背景图" class="headerlink" title="十一、添加背景图"></a>十一、添加背景图</h2><blockquote><p>修改themes/next/source/css _custom/custom.styl</p></blockquote><p>添加如下代码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background:url(../images/xx.jpg);</span><br><span class="line">    background-size:cover;</span><br><span class="line">    background-repeat:no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="十二、修改各版块透明度"><a href="#十二、修改各版块透明度" class="headerlink" title="十二、修改各版块透明度"></a>十二、修改各版块透明度</h2><blockquote><p>内容板块</p></blockquote><ul><li><p>修改在对应主题的对应.yml文件中,ID为【.content-wrap】标签下的background属性</p><pre><code>background: rgba(255,255,255,0.7); </code></pre></li><li><p>以主题Pisces为例,对应内容板块文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre></li></ul><p><br></p><blockquote><p>菜单栏</p></blockquote><ul><li>修改在对应主题的对应.yml文件中,ID为【.header-inner】标签下的background属性。</li><li><p>以主题Pisces为例,对应菜单栏文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre></li></ul><p><br></p><blockquote><p>站点概况</p></blockquote><ul><li>修改在对应主题的对应.yml文件中,ID为【.sidebar-inner】标签下的background属性</li><li><p>以主题Pisces为例,对应站点概况文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_sidebar.styl</code></pre></li><li>修改在对应主题的对应.yml文件中,ID为【.sidebar】标签下的background属性</li><li><p>以主题Pisces为例,对应站点概况文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre></li></ul><p><br></p><blockquote><p>按钮背景</p></blockquote><p>主题共享的文件,文件位置:</p><pre><code>themes/next/source/css _custom/components/post/post-button.styl</code></pre><p><br></p><h2 id="十三、点击出现桃心"><a href="#十三、点击出现桃心" class="headerlink" title="十三、点击出现桃心"></a>十三、点击出现桃心</h2><ol><li>copy<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="noopener">网页</a>代码</li><li>在<code>/themes/next/source/js/src</code>目录下新建love.js文件,把copy的代码粘贴到此文件。</li><li><p>在\themes\next\layout_layout.swig 文件引入love.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;   //在&lt;/body&gt;标签前引入love.js</span><br></pre></td></tr></table></figure></li></ol><p>【我发现在文章详情界面,没有效果,理论上应该是有效果的吧？？可能源码被我改砸了？？】</p><p><br></p><h2 id="十四、文章目录"><a href="#十四、文章目录" class="headerlink" title="十四、文章目录"></a>十四、文章目录</h2><p>目录不能跨级,否则会导致编号会错误。<a href="https://github.com/iissnan/hexo-theme-next/issues/1259" target="_blank" rel="noopener">More&gt;&gt;</a></p><h4 id="1-取消文章目录自动编号"><a href="#1-取消文章目录自动编号" class="headerlink" title="1.取消文章目录自动编号"></a>1.取消文章目录自动编号</h4><blockquote><p>修改themes/next/_config.yml文件toc属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Table Of Contents in the Sidebar</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"># Automatically add list number to toc.</span><br><span class="line">number: false      /*修改这里*/</span><br><span class="line"></span><br><span class="line"># If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">wrap: false</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-自定义文章目录全显示"><a href="#2-自定义文章目录全显示" class="headerlink" title="2.自定义文章目录全显示"></a>2.自定义文章目录全显示</h4><blockquote><p>修改/themes/next/source/css/_custom/custom.styl,添加以下代码</p></blockquote><pre><code>.post-toc .nav .nav-child {        display: block;} </code></pre><p>并不确定是否成功<a href="https://github.com/iissnan/hexo-theme-next/issues/531" target="_blank" rel="noopener">More &gt;&gt;</a></p><p><br></p><h4 id="3-自定义文章目录级数"><a href="#3-自定义文章目录级数" class="headerlink" title="3.自定义文章目录级数"></a>3.自定义文章目录级数</h4><pre><code>h1      # h2      ## h3      ### h4      #### </code></pre><p>我的标题从h2开始。</p><pre><code>## 十四、文章目录### 1.取消文章目录自动编号#### 修改themes/next/_config.yml文件toc属性  </code></pre><p>不喜欢阅读的时候左边目录一直动,也不喜欢目录全部显示。想要只显示大标题的效果</p><pre><code>一、修改Next主题模式二、设置首页预览摘要三、侧边栏显示效果...</code></pre><p>没有Google到解决方法,以下方法是自己乱改的！！！</p><p><br></p><blockquote><p>修改根目录下/node_modules/hexo/lib/plugins/helper/toc.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*修改前*/</span><br><span class="line">const headingsMaxDepth = options.hasOwnProperty(&apos;max_depth&apos;) ? options.max_depth : 6;</span><br><span class="line"></span><br><span class="line">/*修改后*/</span><br><span class="line">const headingsMaxDepth = options.hasOwnProperty(&apos;max_depth&apos;) ? options.max_depth : 2;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="十五、博文置顶"><a href="#十五、博文置顶" class="headerlink" title="十五、博文置顶"></a>十五、博文置顶</h2><blockquote><p>修改 node_modules/hexo-generator-index/lib/generator.js 文件</p></blockquote><p>代码全部替换为:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class="line">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class="line">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><p>在文章添加top字段</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我是置顶博文</span><br><span class="line">date: 2018-07-18 21:30:35</span><br><span class="line">tags: 留言板</span><br><span class="line">categories: hotYan_博客之路</span><br><span class="line">top: 100                   //值越大,越靠前</span><br><span class="line">commentIssueId: 1</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><br></p><h2 id="十六、博客压缩"><a href="#十六、博客压缩" class="headerlink" title="十六、博客压缩"></a>十六、博客压缩</h2><blockquote><p>【<a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">hexo-all-minifier</a>】</p></blockquote><p><br></p><h2 id="十七、精简部署命令"><a href="#十七、精简部署命令" class="headerlink" title="十七、精简部署命令"></a>十七、精简部署命令</h2><blockquote><p>修改根目录下/package.json文件</p></blockquote><p>添加下面代码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;update&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><p>更新Hexo部署</p></blockquote><pre><code>$ npm run update</code></pre><p><br></p><h2 id="十八、文章categories字段多级"><a href="#十八、文章categories字段多级" class="headerlink" title="十八、文章categories字段多级"></a>十八、文章categories字段多级</h2><blockquote><p>写法一</p></blockquote><pre><code>categories: [博客,Hexo]</code></pre><p><br></p><blockquote><p>写法二</p></blockquote><pre><code>categories:         - 博客        - Hexo</code></pre><p><br></p><blockquote><p>效果如下</p></blockquote><ul><li>博客<ul><li>Next</li></ul></li></ul><p><br></p><h2 id="十九、文章多个Tags字段值"><a href="#十九、文章多个Tags字段值" class="headerlink" title="十九、文章多个Tags字段值"></a>十九、文章多个Tags字段值</h2><p>写法同十八,表达意思不一样,tags表示多个标签,categories表示多级分类</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优化博客-持续完善&quot;&gt;&lt;a href=&quot;#优化博客-持续完善&quot; class=&quot;headerlink&quot; title=&quot;优化博客 [持续完善]&quot;&gt;&lt;/a&gt;优化博客 &lt;span style=&quot;font-size:.5em&quot;&gt;[持续完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;搜索了很多Next主题的效果，总结了下常用的效果~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo" scheme="https://hotkang.cn/tags/Hexo/"/>
    
      <category term="博客" scheme="https://hotkang.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Next" scheme="https://hotkang.cn/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>用hexo搭建github博客一</title>
    <link href="https://hotkang.cn/2018/05/29/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E4%B8%80/"/>
    <id>https://hotkang.cn/2018/05/29/用hexo搭建github博客一/</id>
    <published>2018-05-29T07:38:51.000Z</published>
    <updated>2018-07-26T18:27:22.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建博客-完结"><a href="#搭建博客-完结" class="headerlink" title="搭建博客 [完结]"></a>搭建博客 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>一直想搭个人博客,却无从下手？？</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://dmkf.xyz/2017/03/12/6272440/" target="_blank" rel="noopener">参考教程1</a></li><li><a href="https://sunny73.github.io/2018/02/10/Build-my-first-blog/" target="_blank" rel="noopener">参考教程2</a></li><li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官网文档</a></li></ul><p>第二个链接也是参考第一个写的,第一个链接加载超级慢,可以选择看第二个。</p></blockquote><hr><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><blockquote><p>默认已有GitHub账号</p></blockquote><ul><li>没有GitHub账号？？<a href="https://github.com/" target="_blank" rel="noopener">点击注册</a></li></ul><p><br></p><blockquote><p>默认已安装Git</p></blockquote><ul><li>没有安装Git？？<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="noopener">了解如何安装</a></li></ul><p><br></p><blockquote><p>默认已安装 Node.js</p></blockquote><ul><li>没有安装Node.js??<a href="https://hotyan.github.io/2018/05/30/%E7%94%A8nvm%E8%A3%85node-js/" target="_blank" rel="noopener">了解如何安装</a></li></ul><p><br></p><blockquote><p>4 Install Hexo</p></blockquote><ul><li><p>全局下载hexo</p><pre><code>$ npm install -g hexo-cli</code></pre></li><li><p>查看是否成功</p><pre><code>$ hexo</code></pre></li></ul><p>进入<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官网文档</a>了解更多</p><p><br></p><h2 id="二、初始化博客"><a href="#二、初始化博客" class="headerlink" title="二、初始化博客"></a>二、初始化博客</h2><pre><code>$ hexo init HotYan_Bolg //创建一个放在博客项目的文件$ cd HotYan_Bolg       //进入该文件$ npm install       //安装依赖包</code></pre><p><br>进入HotYan_Bolg,已自动生成以下文件</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p><br></p><h2 id="三、本地搭建"><a href="#三、本地搭建" class="headerlink" title="三、本地搭建"></a>三、本地搭建</h2><blockquote><p>修改_config.yml文件</p></blockquote><p>根据个人情况修改以下部分:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*修改前*/</span><br><span class="line"># Site</span><br><span class="line">title: # The title of your website</span><br><span class="line">subtitle: # The subtitle of your website</span><br><span class="line">description: # The description of your website</span><br><span class="line">author: # Your name</span><br><span class="line">language: # The language of your website</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line">/*修改后*/</span><br><span class="line"># Site</span><br><span class="line">title: hotYan&apos;s Blog </span><br><span class="line">subtitle: 爱美的程序媛</span><br><span class="line">description: 毒鸡汤Yan</span><br><span class="line">keywords:</span><br><span class="line">author: hotYan</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure><p></p><p>【每一项的填写,其 <strong>:</strong> 后面都要保留一个空格,下同。】</p><p><br></p><blockquote><p>本地运行</p></blockquote><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo generate // 生成文件$ hexo server   //本地部署/*简写如下*/$ hexo g$ hexo s</code></pre><p>可在浏览器输入地址 <a href="http://host:4000" target="_blank" rel="noopener">http://host:4000</a> 进行查看</p><p><br></p><h2 id="四、配置远程环境-线上运行"><a href="#四、配置远程环境-线上运行" class="headerlink" title="四、配置远程环境,线上运行"></a>四、配置远程环境,线上运行</h2><blockquote><p>github新建一个库</p></blockquote><pre><code>库名格式为: username.github.io //非常重要！！！</code></pre><p>你可能想了解一下<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a></p><p><br></p><blockquote><p><a href="https://hotkang.cn/2018/07/18/Github%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/">GitHub添加SSH密钥</a></p></blockquote><p><br></p><blockquote><p>配置_config.yml文件</p></blockquote><ul><li><p>配置统一资源定位符（个人域名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*配置前*/</span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, .....</span><br><span class="line">url: http://yoursite.com/child</span><br><span class="line">        </span><br><span class="line">/*配置后*/  </span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory,......</span><br><span class="line"> url: http://github.com</span><br></pre></td></tr></table></figure></li><li><p>配置部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">        type: git </span><br><span class="line">        /*repo项是之前Github上创建好的仓库地址*/</span><br><span class="line">        repo: https://github.com/hotYan/hotYan.github.io.git</span><br><span class="line">        branch: master</span><br></pre></td></tr></table></figure></li></ul><p><br></p><blockquote><p>线上运行</p></blockquote><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo generate // 生成文件$ hexo deploy   // 线上部署/*简写如下*/$ hexo g$ hexo d</code></pre><p>可在浏览器输入博客地址 <a href="https://hotyan.github.io/" target="_blank" rel="noopener">https://hotyan.github.io/</a> 进行查看</p><p><br></p><h2 id="五、修改主题"><a href="#五、修改主题" class="headerlink" title="五、修改主题"></a>五、修改主题</h2><blockquote><p>1.<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">下载Next主题</a></p></blockquote><blockquote><p>2.下载后,将压缩包解压缩,复制其中名称为next的文件夹到你博客文件的themes下</p></blockquote><blockquote><p>3.修改博客文件根目录下的_config.yml,将主题改为next</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line"># theme: landscape</span><br><span class="line">        theme: next</span><br></pre></td></tr></table></figure><p><br></p><h2 id="六、创建新文章"><a href="#六、创建新文章" class="headerlink" title="六、创建新文章"></a>六、创建新文章</h2><blockquote><p>创建</p></blockquote><pre><code>$ cd  HotYan_Blog   //进入博客文件夹目录$ hexo new &quot;用hexo搭建github博客一&quot;  // 新建一篇文章</code></pre><p>可在博客文件夹下的source/_post查看你新建的markdown文件</p><p><br></p><blockquote><p>编写内容</p></blockquote><p>如果不清楚如何编写markdown文件,你可能需要先了解一下。</p><ul><li><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">参考链接1</a></li><li><a href="http://xianbai.me/learn-md/article/syntax/blockquotes.html" target="_blank" rel="noopener">参考链接2</a></li></ul><p><br></p><h2 id="七、更新Hexo部署"><a href="#七、更新Hexo部署" class="headerlink" title="七、更新Hexo部署"></a>七、更新Hexo部署</h2><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo clean    // 清理缓存$ hexo generate // 生成文件$ hexo deploy   // 线上部署/*简写如下*/$ hexo clean$ hexo g$ hexo d</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;搭建博客-完结&quot;&gt;&lt;a href=&quot;#搭建博客-完结&quot; class=&quot;headerlink&quot; title=&quot;搭建博客 [完结]&quot;&gt;&lt;/a&gt;搭建博客 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;一直想搭个人博客,却无从下手？？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo" scheme="https://hotkang.cn/tags/Hexo/"/>
    
      <category term="博客" scheme="https://hotkang.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Mac Use Homebrew Install Mongodb</title>
    <link href="https://hotkang.cn/2018/05/29/use%20homebrew%20install%20mongodb/"/>
    <id>https://hotkang.cn/2018/05/29/use homebrew install mongodb/</id>
    <published>2018-05-29T07:38:51.000Z</published>
    <updated>2018-07-26T18:28:45.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac-Use-Homebrew-Install-Mongodb-完结"><a href="#Mac-Use-Homebrew-Install-Mongodb-完结" class="headerlink" title="Mac Use Homebrew Install Mongodb [完结]"></a>Mac Use Homebrew Install Mongodb <span style="font-size:.5em">[完结]</span></h2><blockquote><p>图书管理系统,一开始是打算用Express+ejs+Mongodb,但是后期,使用mongoose出现了问题,尝试解决,没有成功后,就放弃了,转而使用Mysql。将安装过程记录一下。</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接,以下内容作为我的个人记录,以我的角度去记录,总结。</p><ul><li><a href="https://brew.sh/" target="_blank" rel="noopener">homebrew官网</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html" target="_blank" rel="noopener">参考链接</a></li></ul></blockquote><hr><h2 id="一、安装Homebrew"><a href="#一、安装Homebrew" class="headerlink" title="一、安装Homebrew"></a>一、安装Homebrew</h2><p>打开Terminal并运行以下命令</p><pre><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>【注意】 Homebrew将作为安装过程的一部分下载并安装Xcode 8.0的命令行工具。</p><p><br></p><h2 id="二、安装MongoDB"><a href="#二、安装MongoDB" class="headerlink" title="二、安装MongoDB"></a>二、安装MongoDB</h2><p>1.运行以下命令进行安装mongodb</p><pre><code>$ brew install mongodb</code></pre><p>2.将mongodb升级，确保版本最新</p><pre><code>$ brew upgrade mongodb</code></pre><p>3.创建一个目录，用来保存mongo默认的数据</p><pre><code>$ mkdir -p /data/db</code></pre><p>4.给目录以可读可写的权限</p><pre><code>$ chown `id -u` /data/db</code></pre><p>5.启动</p><pre><code>$ brew services start mongodb</code></pre><p><br></p><h2 id="三、未正常关闭导致数据库突然启动不了"><a href="#三、未正常关闭导致数据库突然启动不了" class="headerlink" title="三、未正常关闭导致数据库突然启动不了"></a>三、未正常关闭导致数据库突然启动不了</h2><p>1.删除掉mongod.lock文件，然后重新启动</p><p>2.如果还是不可以，先查看一下进程</p><pre><code>$ ps -aef | grep mongo</code></pre><p>3.然后根据进程ID杀掉进程</p><pre><code>$ sudo kill 6955</code></pre><p>4.重新启动mongodb服务</p><pre><code>$ brew services start mongodb</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mac-Use-Homebrew-Install-Mongodb-完结&quot;&gt;&lt;a href=&quot;#Mac-Use-Homebrew-Install-Mongodb-完结&quot; class=&quot;headerlink&quot; title=&quot;Mac Use Homebrew Install Mongodb [完结]&quot;&gt;&lt;/a&gt;Mac Use Homebrew Install Mongodb &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;图书管理系统,一开始是打算用Express+ejs+Mongodb,但是后期,使用mongoose出现了问题,尝试解决,没有成功后,就放弃了,转而使用Mysql。将安装过程记录一下。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Install" scheme="https://hotkang.cn/categories/Install/"/>
    
      <category term="Mongodb" scheme="https://hotkang.cn/categories/Install/Mongodb/"/>
    
    
      <category term="Homebrew" scheme="https://hotkang.cn/tags/Homebrew/"/>
    
      <category term="Mongodb" scheme="https://hotkang.cn/tags/Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>高性能网站建设指南14条规则</title>
    <link href="https://hotkang.cn/2018/05/29/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%9714%E6%9D%A1%E8%A7%84%E5%88%99/"/>
    <id>https://hotkang.cn/2018/05/29/高性能网站建设指南14条规则/</id>
    <published>2018-05-29T00:54:54.000Z</published>
    <updated>2018-07-10T11:03:36.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14条常用性能规则-待完善"><a href="#14条常用性能规则-待完善" class="headerlink" title="14条常用性能规则[待完善]"></a>14条常用性能规则<span style="font-size:.5em">[待完善]</span></h2><p><img src="/img/XN.png" alt=""></p><a id="more"></a><h1 id="高性能网站建设指南"><a href="#高性能网站建设指南" class="headerlink" title="高性能网站建设指南"></a>高性能网站建设指南</h1><p>按照优先级顺序依次介绍14个性能规则</p><p><a href="#减少http请求"><code>1. 减少HTTP请求</code></a><br><a href="#使用内容分发网络cdn"><code>2. 使用内容分发网络CDN</code></a><br><a href="#添加Expires头"><code>3. 添加Expires头</code></a><br><a href="#压缩组件"><code>4. 压缩组件</code></a><br><a href="#将样式表放在顶部"><code>5. 将样式表放在顶部</code></a><br><a href="#将脚本放在底部"><code>6. 将脚本放在底部</code></a><br><a href="#避免使用css表达式"><code>7. 避免使用CSS表达式</code></a><br><a href="#使用外部JavaScript和CSS"><code>8. 使用外部JavaScript和CSS</code></a><br><a href="#减少dns查找"><code>9. 减少DNS查找</code></a><br><a href="#精简javascript"><code>10. 精简JavaScript</code></a><br><a href="#避免重定向"><code>11. 避免重定向</code></a><br><a href="#删除重复的脚本"><code>12. 删除重复的脚本</code></a><br><a href="#配置etags"><code>13. 配置ETags</code></a><br><a href="#使ajax可缓存"><code>14. 使Ajax可缓存</code></a></p><hr><p>终端用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像、样式表、脚本、Flash等。</p><h2 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h2><ul><li><p>图片地图</p><ul><li><p>假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。</p><p><img src="/img/JL.png" alt=""></p></li><li>服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应</li><li>客户端图片地图：直接将点击映射到操作</li></ul></li><li><p>CSS Sprites ：将背景图像组合成单个图像</p><ul><li><p>优点 ：</p><pre><code>1.减少HTTP请求，响应时间短  2.图片数量变少，降低下载量</code></pre></li><li><p>方法：</p><pre><code>使用  CSSbackground-image  background-position  属性显示所需的图像片段。      </code></pre></li></ul></li></ul><ul><li><p>内内联图片</p><ul><li><p>使用 data:URL 模式，允许将小块数据内联为“立即数”，数据就在URL自身中。</p><pre><code>格式：data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></pre><ul><li>合并脚本和样式表</li></ul></li><li>通过将所有脚本合并为一个脚本来减少HTTP请求数量的方法，同样也可以将所有CSS合并到一个样式表中，能够缩短响应时间。</li></ul></li></ul><h3 id="使用内容分发网络CDN"><a href="#使用内容分发网络CDN" class="headerlink" title="使用内容分发网络CDN"></a>使用内容分发网络CDN</h3><ul><li>用户与Web服务器的距离对响应时间有影响。在多个地理位置分散的服务器上部署您的内容将使您的网页从用户的角度更快加载。但是你应该从哪里开始？</li></ul><p>作为实现地理上分散的内容的第一步，不要尝试重新设计您的Web应用程序以在分布式架构中工作。根据应用程序的不同，更改体系结构可能包括艰巨的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与内容之间的距离可能会延迟或不能通过此应用程序体系结构步骤。</p><p>请记住，80-90％的最终用户响应时间用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是性能黄金法则。</p><p>不要从重新设计应用程序体系结构的艰巨任务开始，最好先分散您的静态内容。这不仅实现了响应时间的更大缩短，而且由于内容交付网络，这更容易实现。</p><p><code>内容传送网络（CDN）</code>是分布在多个位置的网络服务器的集合，以更高效地向用户传送内容。选择用于将内容递送给特定用户的服务器通常基于网络邻近度的度量。例如，选择网络跳数最少的服务器或响应时间最快的服务器。</p><p>一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如Akamai Technologies，EdgeCast或level3）具有成本效益。对于创业公司和私人网站来说，CDN服务的成本可能会很高，但随着您的目标受众不断扩大并变得更加全球化，CDN是实现快速响应所必需的。</p><h3 id="添加Expires头"><a href="#添加Expires头" class="headerlink" title="添加Expires头"></a>添加Expires头</h3><p>这条规则有两个方面：</p><ul><li>对于静态组件：通过设置远期<code>Expires</code>标题实现“永不过期”策略</li><li>对于动态组件：使用适当的<code>Cache-Control</code>头文件来帮助浏览器提供有条件的请求</li></ul><p>网页设计越来越丰富，这意味着更多的脚本，样式表，图像和Flash在页面中。</p><p>首次访问您的页面可能需要发出多个HTTP请求，但通过使用Expires标头，可以使这些组件可缓存。这避免了后续页面浏览中不必要的HTTP请求。</p><p>过期标头最常用于图像，但它们应该用于所有组件，包括脚本，样式表和Flash组件。</p><p>浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，使网页加载速度更快。<br>Web服务器使用HTTP响应中的Expires标头告诉客户端可以缓存组件的时间。</p><p>请记住，如果您使用远期未来的Expires头文件，则只要组件更改，就必须更改组件的文件名。</p><p>只有在用户已经访问过您的网站后，使用远期未来的Expires标题才会影响页面浏览。</p><p>当用户第一次访问您的网站并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。</p><p>因此，这种性能改进的影响取决于用户多久访问一次带有缓冲区的页面。（一个“准备好的缓存”已经包含了页面中的所有组件。）我们在Yahoo!上测试了这一点。并发现带有引导缓存的页面浏览量为75-85％。通过使用远期未来的Expires标题，您可以增加浏览器缓存的组件数量，并在后续页面浏览中重新使用，而无需在用户的Internet连接上发送单个字节。</p><h3 id="Gzip压缩传输文件"><a href="#Gzip压缩传输文件" class="headerlink" title="Gzip压缩传输文件"></a>Gzip压缩传输文件</h3><p>通过网络传输HTTP请求和响应所需的时间可以通过前端工程师做出的决策大大减少。</p><p>确实，最终用户的带宽速度，互联网服务提供商，邻近对等交换点等是超出了开发团队的控制范围。</p><p>但还有其他一些影响响应时间的因素。</p><p>压缩通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP / 1.1开始，Web客户端通过HTTP请求中的Accept-Encoding标头指示对压缩的支持。</p><pre><code>Accept-Encoding：gzip，deflate</code></pre><p>如果Web服务器在请求中看到该头部，则可能使用客户端列出的方法之一压缩响应。</p><p>Web服务器通过响应中的Content-Encoding标头通知Web客户端。</p><pre><code>内容编码：gzip</code></pre><blockquote><p>Gzip是目前最流行和最有效的压缩方法。它由GNU项目开发并由RFC 1952标准化。您可能会看到的唯一的其他压缩格式是压缩，但效果不太好，不太受欢迎。Gzipping通常将响应大小减少约70％。目前大约90％的互联网流量都通过声称支持gzip的浏览器。</p></blockquote><blockquote><p>浏览器和代理存在已知的问题，这些问题可能会导致浏览器期望的不匹配和接收到的有关压缩内容的不匹配。幸运的是，随着旧版浏览器的使用下降，这些边缘案例正在减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。</p></blockquote><p>服务器根据文件类型选择要压缩的内容，但在决定压缩的内容时通常太有限。</p><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。</p><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p><p>尽可能多地缩放文件类型是减少页面重量和加速用户体验的简单方法。</p><h3 id="将样式表放在顶部"><a href="#将样式表放在顶部" class="headerlink" title="将样式表放在顶部"></a>将样式表放在顶部</h3><p>将样式表移动到文档HEAD中,页面显示加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。这改善了整体用户体验。</p><p>将样式表放在文档底部附近的问题:它禁止在许多浏览器（包括Internet Explorer）中进行渐进式呈现。这些浏览器会阻止渲染，以避免在样式更改时重新绘制页面元素。用户停留在查看空白页面。</p><p>没有任何替代方案，空白屏幕或无风格内容的闪光都值得冒这个风险。最佳解决方案是遵循HTML规范，并将样式表加载到文档HEAD中。</p><h3 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h3><p>脚本导致的问题是它们会阻止并行下载。</p><p>在HTTP / 1.1规范建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以同时发生两个以上的下载。然而，当脚本正在下载时，浏览器将不会启动任何其他下载，即使是在不同的主机名上。</p><p>在某些情况下，将脚本移动到底部并不容易。例如，如果脚本用于document.write插入页面内容的一部分，则不能在页面中移动较小的内容。也可能存在范围问题。在很多情况下，有办法解决这些情况。</p><p>经常出现的另一个建议是使用延迟脚本。<br>该DEFER属性指示该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该DEFER属性。在Internet Explorer中，该脚本可能会延迟，但不如预期的那么多。如果脚本可以被延期，它也可以被移动到页面的底部。这会让你的网页加载速度更快。</p><h3 id="避免使用CSS表达式"><a href="#避免使用CSS表达式" class="headerlink" title="避免使用CSS表达式"></a>避免使用CSS表达式</h3><p>CSS表达式是动态设置CSS属性的强大（也是危险的）方法。<br>从版本5开始，它们在Internet Explorer中受支持，但从IE8开始已弃用。</p><p>表达式的问题在于它们比大多数人期望的更频繁地进行评估。</p><p>减少CSS表达式评估次数的一种方法是使用一次性表达式，第一次评估表达式时，它将style属性设置为一个显式值，该值将替换CSS表达式。</p><p>如果样式属性必须在页面的整个生命周期中动态设置，则使用事件处理程序而不是CSS表达式是一种替代方法。</p><p>如果您必须使用CSS表达式，请记住它们可能会被评估数千次，并且可能会影响页面的性能。</p><h3 id="使用外部JavaScript和CSS"><a href="#使用外部JavaScript和CSS" class="headerlink" title="使用外部JavaScript和CSS"></a>使用外部JavaScript和CSS</h3><p>许多这些性能规则涉及如何管理外部组件。但是，在出现这些问题之前，您应该提出一个更基本的问题：JavaScript和CSS应该包含在外部文件中还是包含在页面本身中？</p><p>在现实世界中<code>使用外部文件通常会产生更快的页面</code>，因为浏览器会缓存JavaScript和CSS文件。</p><ul><li>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</li><li>JavaScript和CSS位于浏览器缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><p>许多网站都处于这些指标的中间。对于这些网站，最好的解决方案通常是将JavaScript和CSS作为外部文件进行部署。首选内联的唯一例外是主页，例如雅虎的首页和My Yahoo! 。每个会话只有很少（可能只有一个）页面视图的主页可能会发现内嵌JavaScript和CSS可以缩短最终用户的响应时间。</p><p>对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少以及通过使用外部文件实现的缓存优点。其中一种方法是在首页内嵌JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已经在浏览器缓存中的外部文件。</p><h3 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h3><p><code>域名系统（DNS）</code>将主机名映射到IP地址，就像电话本将人名映射到他们的电话号码一样。<br>当您在浏览器中输入<a href="http://www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。" target="_blank" rel="noopener">www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。</a><br>DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。直到DNS查找完成后，浏览器才能从此主机名下载任何内容。</p><p>DNS查找缓存以获得更好的性能。这种高速缓存可以发生在用户的ISP或局域网维护的特殊高速缓存服务器上，但也可以在个人用户的计算机上进行高速缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器在自己的缓存中保存了一条DNS记录，它就不会打扰操作系统请求记录。</p><p>按照DnsCacheTimeout注册表设置的指定，Internet Explorer默认缓存DNS查找30分钟 。Firefox缓存DNS查找1分钟，由network.dnsCacheExpiration配置设置控制。（Fasterfox将此更改为1小时。）</p><p>当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。</p><p>减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间取得了很好的折衷。</p><h3 id="精简JavaScript"><a href="#精简JavaScript" class="headerlink" title="精简JavaScript"></a>精简JavaScript</h3><ul><li>在JavaScript的情况下，由于下载文件的大小减小，这提高了响应时间性能。</li><li>从代码中移除不必要的字符以减少其大小，减少加载时间。</li><li><p>减少JavaScript 文件大小的有几种手段:</p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。</li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。</li></ul></li></ul><h3 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h3><p>重定向是使用301和302状态码完成的。</p><p>浏览器会自动将用户转到该Location字段中指定的URL 。重定向所需的所有信息都在标题中,响应的主体通常是空的。</p><p>尽管名称不同，301和302响应在实践中都不会被缓存，除非额外的标头（例如Expires或Cache-Control）指示它应该是。</p><p>元刷新标记和JavaScript是将用户引导到不同URL的其他方式，但是如果您必须执行重定向，首选方法是使用标准的3xx HTTP状态代码，主要是为了确保后退按钮正常工作。</p><p>要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。</p><p>将旧网站连接到新网站是重定向的另一个常见用途。</p><p>其他包括连接网站的不同部分，并根据特定条件（浏览器类型，用户帐户类型等）指导用户。</p><p>使用重定向来连接两个网站很简单，只需要很少的附加编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。</p><p>这种重定向的替代方案包括使用Alias和mod_rewrite如果两个代码路径托管在同一台服务器上。</p><p>如果域名更改是使用重定向的原因，另一种方法是创建一个CNAME（一个DNS记录，用于创建一个别名从一个域名指向另一个域名）与Alias或mod_rewrite。</p><h3 id="删除重复的脚本"><a href="#删除重复的脚本" class="headerlink" title="删除重复的脚本"></a>删除重复的脚本</h3><p>在一个页面中包含两次相同的JavaScript文件会使性能受损。</p><p>当它发生时，通过创建不必要的HTTP请求和浪费JavaScript执行，重复脚本会损害性能。</p><p>不必要的HTTP请求发生在Internet Explorer中，但不在Firefox中。</p><p>在Internet Explorer中，如果外部脚本包含两次并且不可缓存，则会在加载页面期间生成两个HTTP请求。如果脚本可缓存，当用户重新加载页面时也会发生额外的HTTP请求。</p><p>除了生成浪费的HTTP请求之外，还会浪费多次时间评估脚本。无论脚本是否可缓存，此冗余JavaScript执行都会在Firefox和Internet Explorer中发生。</p><h3 id="配置ETags"><a href="#配置ETags" class="headerlink" title="配置ETags"></a>配置ETags</h3><p>实体标签（ETags）是Web服务器和浏览器用来确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（一个“实体”是另一个词“组件”：图像，脚本，样式表等）</p><p>ETag被添加来提供一种机制来验证比上一次修改日期更灵活的实体。</p><p>ETag是唯一标识组件特定版本的字符串。唯一的格式约束是字符串被引用。原始服务器使用ETag响应头指定组件的ETag 。</p><pre><code>HTTP / 1.1 200 OKLast-Modified：Tue，2006年12月12日03:03:59 GMTETag：“10c24bc-4ab-457e1c1f”内容长度：12195</code></pre><p>之后，如果浏览器必须验证组件，它将使用If-None-Match标头将ETag传递回原始服务器。如果ETags匹配，则返回一个304状态码，在此示例中将响应减少12195字节。</p><pre><code>GET /i/yahoo.gif HTTP / 1.1主持人：us.yimg.comIf-Modified-Since：星期二，2006年12月12日03:03:59 GMTIf-None-Match：“10c24bc-4ab-457e1c1f”HTTP / 1.1 304未修改</code></pre><p>ETags的问题在于，它们通常使用属性来构建，这些属性使它们对托管站点的特定服务器是唯一的。</p><p>当浏览器从一台服务器获取原始组件并稍后尝试在另一台服务器上验证该组件时，ETags将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。</p><p>虽然给定的文件可能位于多个服务器的相同目录中，并且具有相同的文件大小，权限，时间戳等，但其inode不同于一台服务器。</p><p>IIS 5.0和6.0与ETags有类似的问题。IIS上ETags的格式是Filetimestamp:ChangeNumber。A ChangeNumber是用于跟踪IIS配置更改的计数器。ChangeNumber在网站后面的所有IIS服务器上都不可能是相同的。</p><p>最终结果是由Apache和IIS生成的ETags完全相同的组件不会从一台服务器到另一台服务器进行匹配。如果ETags不匹配，用户不会收到ETags设计的小而快的304响应; 相反，他们会得到一个正常的200响应以及组件的所有数据。</p><p>如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多台服务器托管您的网站，并且您使用的是默认的ETag配置的Apache或IIS，那么您的用户的页面速度会变慢，您的服务器的负载会更高，消耗的带宽也会更大，高效地缓存您的内容。即使你的组件有一个遥远的将来Expires头，当用户点击重新加载或刷新时，仍然会发出条件GET请求。</p><p>如果您没有充分利用ETags提供的灵活验证模型，最好完全删除ETag。</p><p>该Last-Modified头验证基于对组件的时间戳。</p><p>删除ETag可以减少响应和后续请求中HTTP头的大小。</p><h3 id="使Ajax可缓存"><a href="#使Ajax可缓存" class="headerlink" title="使Ajax可缓存"></a>使Ajax可缓存</h3><p>Ajax引用的好处之一是，它向用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待这些异步JavaScript和XML响应返回时扭动拇指。</p><p>在许多应用程序中，用户是否在等待取决于如何使用Ajax。例如，在基于Web的电子邮件客户端中，用户将不断等待Ajax请求的结果，以查找与其搜索条件匹配的所有电子邮件。记住“异步”并不意味着“即时”。</p><p>为了提高性能，优化这些Ajax响应非常重要。</p><p>提高Ajax性能的最重要方法是使响应可缓存，如<code>添加过期或缓存控制头</code>中所述。</p><ul><li>其他一些规则也适用于Ajax：<br>Gzip组件<br>减少DNS查找<br>缩小JavaScript<br>避免重定向<br>配置ETags</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;14条常用性能规则-待完善&quot;&gt;&lt;a href=&quot;#14条常用性能规则-待完善&quot; class=&quot;headerlink&quot; title=&quot;14条常用性能规则[待完善]&quot;&gt;&lt;/a&gt;14条常用性能规则&lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/XN.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>7类35条网页性能优化</title>
    <link href="https://hotkang.cn/2018/05/29/7%E7%B1%BB35%E6%9D%A1%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://hotkang.cn/2018/05/29/7类35条网页性能优化/</id>
    <published>2018-05-29T00:52:55.000Z</published>
    <updated>2018-07-19T15:42:13.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小结于"><a href="#小结于" class="headerlink" title="小结于"></a>小结于</h2><blockquote><p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#menu" target="_blank" rel="noopener">参考链接</a></p></blockquote><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="一、内容"><a href="#一、内容" class="headerlink" title="一、内容"></a><a href="#内容">一、内容</a></h3><p><a href="#减少http请求次数"><code>1. 减少HTTP请求次数</code></a><br><a href="#减少dns查询次数"><code>2. 减少DNS查询次数</code></a><br><a href="#避免重定向"><code>3. 避免重定向</code></a><br><a href="#使ajax可缓存"><code>4. 使Ajax可缓存</code></a><br><a href="#延迟加载组件"><code>5. 延迟加载组件</code></a><br><a href="#预加载组件"><code>6. 预加载组件</code></a><br><a href="#减少dom元素的数量"><code>7. 减少DOM元素的数量</code></a><br><a href="#拆分组件跨域"><code>8. 拆分组件跨域</code></a><br><a href="#尽量减少iframe的数量"><code>9. 尽量减少iframe的数量</code></a><br><a href="#避免404"><code>10. 避免404</code></a></p><h3 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a><a href="#css">二、CSS</a></h3><p><a href="#将样式表放置在顶部"><code>11. 将样式表放置在顶部</code></a><br><a href="#避免使用css表达式"><code>12. 避免使用CSS表达式</code></a><br><a href="#用link替代import"><code>13. 用&lt;link&gt;替代@import</code></a><br><a href="#避免过滤器filters"><code>14. 避免过滤器Filters</code></a></p><h3 id="三、JavaScript"><a href="#三、JavaScript" class="headerlink" title="三、JavaScript"></a><a href="#javascript">三、JavaScript</a></h3><p><a href="#将脚本放在底部"><code>15. 将脚本放在底部</code></a><br><a href="#使javascript和css在外部"><code>16. 使JavaScript和CSS在外部</code></a><br><a href="#精简javascript和css"><code>17. 精简JavaScript和CSS</code></a><br><a href="#删除重复的脚本"><code>18. 删除重复的脚本</code></a><br><a href="#最小化dom访问"><code>19. 最小化DOM访问</code></a><br><a href="#开发智能事件处理程序"><code>20. 开发智能事件处理程序</code></a></p><h3 id="四、图片"><a href="#四、图片" class="headerlink" title="四、图片"></a><a href="#图片">四、图片</a></h3><p><a href="#优化图像"><code>21. 优化图像</code></a><br><a href="#优化css精灵"><code>22. 优化CSS精灵</code></a><br><a href="#不要在html中缩放图像"><code>23. 不要在HTML中缩放图像</code></a><br><a href="#制作faviconicosmall和cacheable"><code>24. 制作favicon.ico Small和Cacheable</code></a></p><h3 id="五、Cookie"><a href="#五、Cookie" class="headerlink" title="五、Cookie"></a><a href="#cookie">五、Cookie</a></h3><p><a href="#减小cookie大小"><code>25. 减小Cookie大小</code></a><br><a href="#页面内容使用无cookie域"><code>26. 页面内容使用无Cookie域</code></a></p><h3 id="六、服务器"><a href="#六、服务器" class="headerlink" title="六、服务器"></a><a href="#服务器">六、服务器</a></h3><p><a href="#使用内容分发网络cdn"><code>27. 使用内容分发网络CDN</code></a><br><a href="#添加expires或cache-control标题"><code>28. 添加Expires或Cache-Control标题</code></a><br><a href="#gzip压缩传输文件"><code>29. Gzip压缩传输文件</code></a><br><a href="#配置etags"><code>30. 配置ETags</code></a><br><a href="#尽早flush输出"><code>31. 尽早flush输出</code></a><br><a href="#使用get获取ajax请求"><code>32. 使用GET获取AJAX请求</code></a><br><a href="#避免空图像src"><code>33. 避免空图像src</code></a></p><h3 id="七、手机"><a href="#七、手机" class="headerlink" title="七、手机"></a><a href="#手机">七、手机</a></h3><p><a href="#保持组件低于25k"><code>34. 保持组件低于25K</code></a><br><a href="#将组件打包成多部分文档"><code>35. 将组件打包成多部分文档</code></a></p><hr><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h3><p>终端用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像、样式表、脚本、Flash等。<br>减少组件数量又会减少呈现页面所需的HTTP请求数量。这是更快页面的关键。</p><p>减少页面中组件数量的一种方法是简化页面的设计。但是，有没有办法构建更丰富的内容，同时实现快速响应时间？</p><p>以下是一些减少HTTP请求数量的技术，同时还支持丰富的页面设计。</p><ul><li><p><code>组合文件</code>是一种通过将所有脚本合并为一个脚本来减少HTTP请求数量的方法，同样也可以将所有CSS合并到一个样式表中。当脚本和样式表因页面而异时，将文件组合起来更具挑战性，但使发布过程的这一部分能够缩短响应时间。</p></li><li><p><code>CSS Sprites</code>是减少图片请求数量的首选方法。将背景图像组合成单个图像，并使用CSSbackground-image和background-position属性显示所需的图像片段。</p></li><li><p><code>图像映射</code>将多个图像组合成单个图像。整体大小大致相同，但减少HTTP请求的数量会加快页面的速度。仅当图像在页面中连续存在时（例如导航栏），图像映射才起作用。定义图像映射的坐标可能很乏味且容易出错。使用图像地图进行导航也无法访问，因此不推荐。</p></li><li><p><code>内联图像</code>使用data:URL方案将图像数据嵌入到实际页面中。这可以增加HTML文档的大小。将内嵌图像合并到缓存的样式表中是减少HTTP请求并避免增加页面大小的一种方法。所有主流浏览器都不支持内嵌图像。</p></li></ul><p>减少页面中的HTTP请求数量是开始的地方。这是提高初次访问者性能的最重要指导方针。</p><h3 id="减少DNS查询次数"><a href="#减少DNS查询次数" class="headerlink" title="减少DNS查询次数"></a>减少DNS查询次数</h3><p><code>域名系统（DNS）</code>将主机名映射到IP地址，就像电话本将人名映射到他们的电话号码一样。<br>当您在浏览器中输入<a href="http://www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。" target="_blank" rel="noopener">www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。</a><br>DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。直到DNS查找完成后，浏览器才能从此主机名下载任何内容。</p><p>DNS查找缓存以获得更好的性能。这种高速缓存可以发生在用户的ISP或局域网维护的特殊高速缓存服务器上，但也可以在个人用户的计算机上进行高速缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器在自己的缓存中保存了一条DNS记录，它就不会打扰操作系统请求记录。</p><p>按照DnsCacheTimeout注册表设置的指定，Internet Explorer默认缓存DNS查找30分钟 。Firefox缓存DNS查找1分钟，由network.dnsCacheExpiration配置设置控制。（Fasterfox将此更改为1小时。）</p><p>当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。</p><p>减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间取得了很好的折衷。</p><h3 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h3><p>重定向是使用301和302状态码完成的。</p><p>浏览器会自动将用户转到该Location字段中指定的URL 。重定向所需的所有信息都在标题中,响应的主体通常是空的。</p><p>尽管名称不同，301和302响应在实践中都不会被缓存，除非额外的标头（例如Expires或Cache-Control）指示它应该是。</p><p>元刷新标记和JavaScript是将用户引导到不同URL的其他方式，但是如果您必须执行重定向，首选方法是使用标准的3xx HTTP状态代码，主要是为了确保后退按钮正常工作。</p><p>要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。</p><p>将旧网站连接到新网站是重定向的另一个常见用途。</p><p>其他包括连接网站的不同部分，并根据特定条件（浏览器类型，用户帐户类型等）指导用户。</p><p>使用重定向来连接两个网站很简单，只需要很少的附加编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。</p><p>这种重定向的替代方案包括使用Alias和mod_rewrite如果两个代码路径托管在同一台服务器上。</p><p>如果域名更改是使用重定向的原因，另一种方法是创建一个CNAME（一个DNS记录，用于创建一个别名从一个域名指向另一个域名）与Alias或mod_rewrite。</p><h3 id="使Ajax可缓存"><a href="#使Ajax可缓存" class="headerlink" title="使Ajax可缓存"></a>使Ajax可缓存</h3><p>Ajax引用的好处之一是，它向用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待这些异步JavaScript和XML响应返回时扭动拇指。</p><p>在许多应用程序中，用户是否在等待取决于如何使用Ajax。例如，在基于Web的电子邮件客户端中，用户将不断等待Ajax请求的结果，以查找与其搜索条件匹配的所有电子邮件。记住“异步”并不意味着“即时”。</p><p>为了提高性能，优化这些Ajax响应非常重要。</p><p>提高Ajax性能的最重要方法是使响应可缓存，如<code>添加过期或缓存控制头</code>中所述。</p><ul><li>其他一些规则也适用于Ajax：<br>Gzip组件<br>减少DNS查找<br>缩小JavaScript<br>避免重定向<br>配置ETags</li></ul><h3 id="延迟加载组件"><a href="#延迟加载组件" class="headerlink" title="延迟加载组件"></a>延迟加载组件</h3><p>你可以仔细看看你的页面，并问自己：“为了最初呈现页面，绝对需要什么？”。其余的内容和组件可以等待。</p><p>JavaScript是在onload事件之前和之后进行分割的理想人选。</p><p>例如，如果您有JavaScript代码和用于拖放和动画的库，则可以等待，因为在初始渲染之后拖动页面上的元素。其他要查找候选人进行后加载的地方包括隐藏内容（用户操作后显示的内容）和低于该对象的图像。</p><p>性能目标与其他Web开发最佳实践保持一致是很好的。在这种情况下，逐步增强的想法告诉我们，JavaScript在受支持的情况下可以改善用户体验，但是即使没有JavaScript，您也必须确保页面能够正常工作。</p><p>因此，在确保页面正常工作后，您可以使用一些后期加载的脚本来增强它，从而为您提供更多的细节和哨音，例如拖放和动画。</p><h3 id="预加载组件"><a href="#预加载组件" class="headerlink" title="预加载组件"></a>预加载组件</h3><p>预加载看起来可能与后加载相反，但它实际上有一个不同的目标。通过预加载组件，您可以利用浏览器闲置的时间以及将来需要的组件（如图像，样式和脚本）。通过这种方式，当用户访问下一页时，您可以将大部分组件都存储在缓存中，并且您的页面将为用户加载得更快。</p><p>实际上有几种类型的预加载：</p><ul><li><p>无条件预加载:只要onload激活，您就可以继续并获取一些额外的组件。</p></li><li><p>有条件预加载:根据用户操作，您可以根据用户的行为猜测下一个用户前进的位置并相应地进行预加载。</p></li><li>预期的预加载:在启动重新设计之前提前预加载。它经常发生在重新设计之后，您会听到：“新网站很酷，但速度比以前慢”。部分问题可能在于用户使用完全缓存访问旧网站，但新网站总是空的缓存体验。您甚至可以在启动重新设计之前通过预加载某些组件来减轻这种副作用。您的旧网站可以使用浏览器闲置的时间，并请求将由新网站使用的图像和脚本</li></ul><h3 id="减少DOM元素的数量"><a href="#减少DOM元素的数量" class="headerlink" title="减少DOM元素的数量"></a>减少DOM元素的数量</h3><p>复杂的页面意味着需要下载更多的字节，这也意味着JavaScript中的DOM访问速度较慢。例如，当您想要添加事件处理程序时，如果在页面上循环遍历500或5000个DOM元素，则会有所不同。</p><p>大量的DOM元素可能是一种症状，应该通过页面的标记来改善某些内容，而不必删除内容。</p><p>DOM元素的数量很容易测试，只需输入Firebug的控制台：<br>document.getElementsByTagName(‘*’).length</p><h3 id="拆分组件跨域"><a href="#拆分组件跨域" class="headerlink" title="拆分组件跨域"></a>拆分组件跨域</h3><p>拆分组件可让您最大限度地平行下载。由于DNS查找惩罚，请确保您使用的域不超过2-4个。</p><h3 id="尽量减少iframe的数量"><a href="#尽量减少iframe的数量" class="headerlink" title="尽量减少iframe的数量"></a>尽量减少iframe的数量</h3><p>Iframe允许将HTML文档插入到父文档中。了解iframe如何工作以便可以有效使用非常重要。</p><ul><li><p><code>&lt;iframe&gt;</code>优点：</p><ul><li>像徽章和广告等缓慢的第三方内容</li><li>安全沙箱</li><li>并行下载脚本</li></ul></li><li><p><code>&lt;iframe&gt;</code>缺点：</p><ul><li>即使空白也很昂贵</li><li>阻止页面载入</li><li>非语义</li></ul></li></ul><h3 id="避免404"><a href="#避免404" class="headerlink" title="避免404"></a>避免404</h3><p>HTTP请求很昂贵，因此提出HTTP请求并获得无用的响应（即404 Not Found）是完全没有必要的，并且会减慢用户体验而没有任何好处。</p><p>有些网站有帮助的404s“你的意思是X？”，这对用户体验很好，但也浪费了服务器资源（如数据库等）。特别糟糕的是，当到外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应正文，就好像它是JavaScript代码一样，试图找到可用的东西。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="将样式表放置在顶部"><a href="#将样式表放置在顶部" class="headerlink" title="将样式表放置在顶部"></a>将样式表放置在顶部</h3><p>将样式表移动到文档HEAD中,页面显示加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。这改善了整体用户体验。</p><p>将样式表放在文档底部附近的问题:它禁止在许多浏览器（包括Internet Explorer）中进行渐进式呈现。这些浏览器会阻止渲染，以避免在样式更改时重新绘制页面元素。用户停留在查看空白页面。</p><p>没有任何替代方案，空白屏幕或无风格内容的闪光都值得冒这个风险。最佳解决方案是遵循HTML规范，并将样式表加载到文档HEAD中。</p><h3 id="避免使用CSS表达式"><a href="#避免使用CSS表达式" class="headerlink" title="避免使用CSS表达式"></a>避免使用CSS表达式</h3><p>CSS表达式是动态设置CSS属性的强大（也是危险的）方法。<br>从版本5开始，它们在Internet Explorer中受支持，但从IE8开始已弃用。</p><p>表达式的问题在于它们比大多数人期望的更频繁地进行评估。</p><p>减少CSS表达式评估次数的一种方法是使用一次性表达式，第一次评估表达式时，它将style属性设置为一个显式值，该值将替换CSS表达式。</p><p>如果样式属性必须在页面的整个生命周期中动态设置，则使用事件处理程序而不是CSS表达式是一种替代方法。</p><p>如果您必须使用CSS表达式，请记住它们可能会被评估数千次，并且可能会影响页面的性能。</p><h3 id="用-lt-link-gt-替代-import"><a href="#用-lt-link-gt-替代-import" class="headerlink" title="用&lt;link&gt;替代@import"></a>用<code>&lt;link&gt;</code>替代@import</h3><p>以前的最佳实践之一指出，为了允许渐进式渲染，CSS应该处于顶端。</p><p>在IE中的@import行为与<link>在页面底部使用的行为相同，因此最好不要使用它。</p><h3 id="避免过滤器Filters"><a href="#避免过滤器Filters" class="headerlink" title="避免过滤器Filters"></a>避免过滤器Filters</h3><p>IE专有AlphaImageLoader过滤器旨在解决IE版本&lt;7中的半透明真彩色PNG问题。该过滤器的问题在于，它会在图像下载时阻止渲染并冻结浏览器。它也增加了内存消耗，并且每个元素应用，而不是每个图像，因此问题倍增。</p><p>最好的方法是AlphaImageLoader完全避免使用PNG8而不是降级，这在IE中是很好的。如果您绝对需要AlphaImageLoader，请使用下划线黑客_filter来惩罚您的IE7 +用户。</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h3 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h3><p>脚本导致的问题是它们会阻止并行下载。</p><p>在HTTP / 1.1规范建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以同时发生两个以上的下载。然而，当脚本正在下载时，浏览器将不会启动任何其他下载，即使是在不同的主机名上。</p><p>在某些情况下，将脚本移动到底部并不容易。例如，如果脚本用于document.write插入页面内容的一部分，则不能在页面中移动较小的内容。也可能存在范围问题。在很多情况下，有办法解决这些情况。</p><p>经常出现的另一个建议是使用延迟脚本。<br>该DEFER属性指示该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该DEFER属性。在Internet Explorer中，该脚本可能会延迟，但不如预期的那么多。如果脚本可以被延期，它也可以被移动到页面的底部。这会让你的网页加载速度更快。</p><h3 id="使JavaScript和CSS在外部"><a href="#使JavaScript和CSS在外部" class="headerlink" title="使JavaScript和CSS在外部"></a>使JavaScript和CSS在外部</h3><p>许多这些性能规则涉及如何管理外部组件。但是，在出现这些问题之前，您应该提出一个更基本的问题：JavaScript和CSS应该包含在外部文件中还是包含在页面本身中？</p><p>在现实世界中<code>使用外部文件通常会产生更快的页面</code>，因为浏览器会缓存JavaScript和CSS文件。</p><ul><li>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</li><li>JavaScript和CSS位于浏览器缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><p>许多网站都处于这些指标的中间。对于这些网站，最好的解决方案通常是将JavaScript和CSS作为外部文件进行部署。首选内联的唯一例外是主页，例如雅虎的首页和My Yahoo! 。每个会话只有很少（可能只有一个）页面视图的主页可能会发现内嵌JavaScript和CSS可以缩短最终用户的响应时间。</p><p>对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少以及通过使用外部文件实现的缓存优点。其中一种方法是在首页内嵌JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已经在浏览器缓存中的外部文件。</p><h3 id="精简JavaScript和CSS"><a href="#精简JavaScript和CSS" class="headerlink" title="精简JavaScript和CSS"></a>精简JavaScript和CSS</h3><ul><li>在JavaScript的情况下，由于下载文件的大小减小，这提高了响应时间性能。</li><li>从代码中移除不必要的字符以减少其大小，减少加载时间。</li><li><p>减少JavaScript 文件大小的有几种手段:</p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。</li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。</li></ul></li></ul><h3 id="删除重复的脚本"><a href="#删除重复的脚本" class="headerlink" title="删除重复的脚本"></a>删除重复的脚本</h3><p>在一个页面中包含两次相同的JavaScript文件会使性能受损。</p><p>当它发生时，通过创建不必要的HTTP请求和浪费JavaScript执行，重复脚本会损害性能。</p><p>不必要的HTTP请求发生在Internet Explorer中，但不在Firefox中。</p><p>在Internet Explorer中，如果外部脚本包含两次并且不可缓存，则会在加载页面期间生成两个HTTP请求。如果脚本可缓存，当用户重新加载页面时也会发生额外的HTTP请求。</p><p>除了生成浪费的HTTP请求之外，还会浪费多次时间评估脚本。无论脚本是否可缓存，此冗余JavaScript执行都会在Firefox和Internet Explorer中发生。</p><h3 id="最小化DOM访问"><a href="#最小化DOM访问" class="headerlink" title="最小化DOM访问"></a>最小化DOM访问</h3><p>使用JavaScript访问DOM元素很慢，所以为了获得更响应的页面，您应该：</p><ul><li>缓存对访问元素的引用</li><li>更新节点“脱机”，然后将它们添加到树中</li><li>避免使用JavaScript修复布局</li></ul><h3 id="开发智能事件处理程序"><a href="#开发智能事件处理程序" class="headerlink" title="开发智能事件处理程序"></a>开发智能事件处理程序</h3><p>有时由于过多的事件处理程序附加到DOM树的不同元素上，而这些事件处理程序过于频繁地执行，有时页面的响应速度会降低 这就是为什么使用事件授权是一个好方法。</p><p>如果在a中有10个按钮div，则只将一个事件处理程序附加到div包装器，而不是每个按钮的一个处理程序。事件冒泡，所以你可以捕捉事件并找出它起源于哪个按钮。</p><p>您也不需要等待onload事件才能开始使用DOM树进行操作。通常你需要的是你想访问的元素在树中可用。您不必等待下载所有图像。</p><p>DOMContentLoaded是您可能考虑使用而不是onload的事件.</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h3 id="优化图像"><a href="#优化图像" class="headerlink" title="优化图像"></a>优化图像</h3><ul><li><p>减少图像周围的空白。 一些开发人员使用空白的填充这是万万要不得的。裁剪图像，删除图像周围任何空白，并使用CSS来填充。</p></li><li><p>使用正确的文件格式。如果你有图标，或者没有太多颜色的图形，可以保存为GIF这种较少颜色的图形。如果你有更详细的图形，可以使用JPG文件格式，降低质量保存图像。</p></li><li>以适当的尺寸保存图像。如果您正在使用HTML和CSS来调整您的图像，那么不要这样。以期望的大小保存你的图像，从而减少文件大小。</li></ul><blockquote><p>恰当的图片格式：</p><ul><li>PNG格式几乎一直优于GIF格式，尽管某些旧版浏览器只能为PNG格式提供部分支持。</li><li>为较小或简单的图形（例如，小于10x10像素的图形或调色板小于3色的图形）以及包含动画的图片使用GIF格式。</li><li>为所有摄影风格的图片使用JPG格式。</li><li>请勿使用BMP格式或TIFF格式。</li></ul></blockquote><h3 id="优化CSS精灵"><a href="#优化CSS精灵" class="headerlink" title="优化CSS精灵"></a>优化CSS精灵</h3><p>一种网页图片应用处理方式。允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，再利用CSS的以下属性精确的定位出背景图片的位置。</p><blockquote><p>background-image<br>background- repeat<br>background-position</p></blockquote><h3 id="不要在HTML中缩放图像"><a href="#不要在HTML中缩放图像" class="headerlink" title="不要在HTML中缩放图像"></a>不要在HTML中缩放图像</h3><p>指定所有图片的宽度和高度可以加速渲染，因为省去了不必要的回流和重绘。</p><h3 id="制作favicon-icoSmall和Cacheable"><a href="#制作favicon-icoSmall和Cacheable" class="headerlink" title="制作favicon.icoSmall和Cacheable"></a>制作<code>favicon.icoSmall</code>和Cacheable</h3><p>favicon.ico是保留在服务器根目录中的映像。这是一个必要的罪恶，因为即使你不关心它，浏览器仍然会请求它，所以最好不要回应404 Not Found。</p><p>另外，由于它位于同一台服务器上，每次请求时都会发送Cookie。此图片还会干扰下载顺序，例如在IE中，当您在onload中请求额外的组件时，favicon会在这些额外的组件之前下载。</p><p>因此，要减轻拥有favicon.ico的缺点，请确保：</p><ul><li>它很小，最好在1K以下。</li><li>设置过期标题与你感觉舒适（因为你不能重命名，如果你决定改变它）。您几乎可以在将来几个月安全地设置Expires标题。您可以查看您当前的favicon.ico的最后修改日期，以做出明智的决定。</li><li>Imagemagick可以帮助您创建小型图标</li></ul><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h3 id="减小Cookie大小"><a href="#减小Cookie大小" class="headerlink" title="减小Cookie大小"></a>减小Cookie大小</h3><p>HTTP cookie由于各种原因（如身份验证和个性化）而被使用。有关cookie的信息在Web服务器和浏览器之间的HTTP标头中交换。尽可能降低cookies的大小以尽量减少对用户响应时间的影响，这一点很重要。</p><ul><li>消除不必要的cookie</li><li>尽可能降低Cookie大小，以尽量减少对用户响应时间的影响</li><li>请注意在适当的域级别设置cookie，以便其他子域不受影响</li><li>适当设置过期日期。更早的过期日期或不更早删除cookie，提高用户响应时间</li></ul><h3 id="页面内容使用无Cookie域"><a href="#页面内容使用无Cookie域" class="headerlink" title="页面内容使用无Cookie域"></a>页面内容使用无Cookie域</h3><p>当浏览器发出静态图像请求并将cookie与请求一起发送时，服务器对这些cookie没有任何用处。所以他们只是没有理由地创建网络流量。您应该确保使用无cookie请求来请求静态组件。创建一个子域，并在其中托管所有静态组件。</p><p>在无Cookie域上托管静态组件的另一个好处是，某些代理可能会拒绝缓存使用cookie请求的组件。</p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h3 id="使用内容分发网络CDN"><a href="#使用内容分发网络CDN" class="headerlink" title="使用内容分发网络CDN"></a>使用内容分发网络CDN</h3><ul><li>用户与Web服务器的距离对响应时间有影响。在多个地理位置分散的服务器上部署您的内容将使您的网页从用户的角度更快加载。但是你应该从哪里开始？</li></ul><p>作为实现地理上分散的内容的第一步，不要尝试重新设计您的Web应用程序以在分布式架构中工作。根据应用程序的不同，更改体系结构可能包括艰巨的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与内容之间的距离可能会延迟或不能通过此应用程序体系结构步骤。</p><p>请记住，80-90％的最终用户响应时间用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是性能黄金法则。</p><p>不要从重新设计应用程序体系结构的艰巨任务开始，最好先分散您的静态内容。这不仅实现了响应时间的更大缩短，而且由于内容交付网络，这更容易实现。</p><p><code>内容传送网络（CDN）</code>是分布在多个位置的网络服务器的集合，以更高效地向用户传送内容。选择用于将内容递送给特定用户的服务器通常基于网络邻近度的度量。例如，选择网络跳数最少的服务器或响应时间最快的服务器。</p><p>一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如Akamai Technologies，EdgeCast或level3）具有成本效益。对于创业公司和私人网站来说，CDN服务的成本可能会很高，但随着您的目标受众不断扩大并变得更加全球化，CDN是实现快速响应所必需的。</p><h3 id="添加Expires或Cache-Control标题"><a href="#添加Expires或Cache-Control标题" class="headerlink" title="添加Expires或Cache-Control标题"></a>添加Expires或<code>Cache-Control</code>标题</h3><p>这条规则有两个方面：</p><ul><li>对于静态组件：通过设置远期<code>Expires</code>标题实现“永不过期”策略</li><li>对于动态组件：使用适当的<code>Cache-Control</code>头文件来帮助浏览器提供有条件的请求</li></ul><p>网页设计越来越丰富，这意味着更多的脚本，样式表，图像和Flash在页面中。</p><p>首次访问您的页面可能需要发出多个HTTP请求，但通过使用Expires标头，可以使这些组件可缓存。这避免了后续页面浏览中不必要的HTTP请求。</p><p>过期标头最常用于图像，但它们应该用于所有组件，包括脚本，样式表和Flash组件。</p><p>浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，使网页加载速度更快。<br>Web服务器使用HTTP响应中的Expires标头告诉客户端可以缓存组件的时间。</p><p>请记住，如果您使用远期未来的Expires头文件，则只要组件更改，就必须更改组件的文件名。</p><p>只有在用户已经访问过您的网站后，使用远期未来的Expires标题才会影响页面浏览。</p><p>当用户第一次访问您的网站并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。</p><p>因此，这种性能改进的影响取决于用户多久访问一次带有缓冲区的页面。（一个“准备好的缓存”已经包含了页面中的所有组件。）我们在Yahoo!上测试了这一点。并发现带有引导缓存的页面浏览量为75-85％。通过使用远期未来的Expires标题，您可以增加浏览器缓存的组件数量，并在后续页面浏览中重新使用，而无需在用户的Internet连接上发送单个字节。</p><h3 id="Gzip压缩传输文件"><a href="#Gzip压缩传输文件" class="headerlink" title="Gzip压缩传输文件"></a>Gzip压缩传输文件</h3><p>通过网络传输HTTP请求和响应所需的时间可以通过前端工程师做出的决策大大减少。</p><p>确实，最终用户的带宽速度，互联网服务提供商，邻近对等交换点等是超出了开发团队的控制范围。</p><p>但还有其他一些影响响应时间的因素。</p><p>压缩通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP / 1.1开始，Web客户端通过HTTP请求中的Accept-Encoding标头指示对压缩的支持。</p><pre><code>Accept-Encoding：gzip，deflate</code></pre><p>如果Web服务器在请求中看到该头部，则可能使用客户端列出的方法之一压缩响应。</p><p>Web服务器通过响应中的Content-Encoding标头通知Web客户端。</p><pre><code>内容编码：gzip</code></pre><blockquote><p>Gzip是目前最流行和最有效的压缩方法。它由GNU项目开发并由RFC 1952标准化。您可能会看到的唯一的其他压缩格式是压缩，但效果不太好，不太受欢迎。Gzipping通常将响应大小减少约70％。目前大约90％的互联网流量都通过声称支持gzip的浏览器。</p></blockquote><blockquote><p>浏览器和代理存在已知的问题，这些问题可能会导致浏览器期望的不匹配和接收到的有关压缩内容的不匹配。幸运的是，随着旧版浏览器的使用下降，这些边缘案例正在减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。</p></blockquote><p>服务器根据文件类型选择要压缩的内容，但在决定压缩的内容时通常太有限。</p><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。</p><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p><p>尽可能多地缩放文件类型是减少页面重量和加速用户体验的简单方法。</p><h3 id="配置ETags"><a href="#配置ETags" class="headerlink" title="配置ETags"></a>配置ETags</h3><p>实体标签（ETags）是Web服务器和浏览器用来确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（一个“实体”是另一个词“组件”：图像，脚本，样式表等）</p><p>ETag被添加来提供一种机制来验证比上一次修改日期更灵活的实体。</p><p>ETag是唯一标识组件特定版本的字符串。唯一的格式约束是字符串被引用。原始服务器使用ETag响应头指定组件的ETag 。</p><pre><code>HTTP / 1.1 200 OKLast-Modified：Tue，2006年12月12日03:03:59 GMTETag：“10c24bc-4ab-457e1c1f”内容长度：12195</code></pre><p>之后，如果浏览器必须验证组件，它将使用If-None-Match标头将ETag传递回原始服务器。如果ETags匹配，则返回一个304状态码，在此示例中将响应减少12195字节。</p><pre><code>GET /i/yahoo.gif HTTP / 1.1主持人：us.yimg.comIf-Modified-Since：星期二，2006年12月12日03:03:59 GMTIf-None-Match：“10c24bc-4ab-457e1c1f”HTTP / 1.1 304未修改</code></pre><p>ETags的问题在于，它们通常使用属性来构建，这些属性使它们对托管站点的特定服务器是唯一的。</p><p>当浏览器从一台服务器获取原始组件并稍后尝试在另一台服务器上验证该组件时，ETags将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。</p><p>虽然给定的文件可能位于多个服务器的相同目录中，并且具有相同的文件大小，权限，时间戳等，但其inode不同于一台服务器。</p><p>IIS 5.0和6.0与ETags有类似的问题。IIS上ETags的格式是Filetimestamp:ChangeNumber。A ChangeNumber是用于跟踪IIS配置更改的计数器。ChangeNumber在网站后面的所有IIS服务器上都不可能是相同的。</p><p>最终结果是由Apache和IIS生成的ETags完全相同的组件不会从一台服务器到另一台服务器进行匹配。如果ETags不匹配，用户不会收到ETags设计的小而快的304响应; 相反，他们会得到一个正常的200响应以及组件的所有数据。</p><p>如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多台服务器托管您的网站，并且您使用的是默认的ETag配置的Apache或IIS，那么您的用户的页面速度会变慢，您的服务器的负载会更高，消耗的带宽也会更大，高效地缓存您的内容。即使你的组件有一个遥远的将来Expires头，当用户点击重新加载或刷新时，仍然会发出条件GET请求。</p><p>如果您没有充分利用ETags提供的灵活验证模型，最好完全删除ETag。</p><p>该Last-Modified头验证基于对组件的时间戳。</p><p>删除ETag可以减少响应和后续请求中HTTP头的大小。</p><h3 id="尽早flush输出"><a href="#尽早flush输出" class="headerlink" title="尽早flush输出"></a>尽早flush输出</h3><p>当用户请求页面时，后端服务器可能需要200到500毫秒才能将HTML页面拼接在一起。在此期间，浏览器在等待数据到达时处于空闲状态。</p><p>在PHP中，你有函数flush（）。</p><p>它允许您将部分就绪的HTML响应发送到浏览器，以便浏览器可以在您的后端忙于HTML页面的其余部分时开始获取组件。好处主要出现在繁忙的后端或前端。<br>考虑刷新的好地方就在HEAD之后，因为头部的HTML通常更容易生成，并且允许您在浏览器中包含任何CSS和JavaScript文件，以便在后端仍在处理的同时开始并行读取。</p><h3 id="使用GET获取AJAX请求"><a href="#使用GET获取AJAX请求" class="headerlink" title="使用GET获取AJAX请求"></a>使用GET获取AJAX请求</h3><p>在使用时XMLHttpRequest，POST在浏览器中实现为两步：首先发送标题，然后发送数据。所以最好使用GET，它只需要一个TCP数据包发送（除非你有很多的cookie）。</p><p>IE中最大的URL长度是2K，所以如果你发送的数据超过2K，你可能无法使用GET。</p><p>一个有趣的副作用是POST没有实际发布任何数据就像GET一样。</p><p>基于HTTP规范，GET旨在用于检索信息，所以在您仅请求数据时使用GET（在语义上）是合理的，而不是将数据发送到服务器端存储。</p><h3 id="避免空图像src"><a href="#避免空图像src" class="headerlink" title="避免空图像src"></a>避免空图像src</h3><p>具有空字符串src属性的图像会发生超过一个人的预期。它以两种形式出现：</p><ul><li><code>&lt;img src =“”&gt;</code></li><li><code>var img = new Image（）;</code><br><code>img.src =“”;</code></li></ul><p>两种形式都会产生相同的效果：浏览器向您的服务器发出另一个请求</p><blockquote><p>Internet Explorer向该页面所在的目录发出请求。<br>Safari和Chrome向实际页面本身发出请求。<br>Firefox 3和更早版本的行为与Safari和Chrome相同，但版本3.5解决了此问题[错误444931]，不再发送请求。<br>当遇到空图像src时，Opera不会执行任何操作。</p></blockquote><p>为什么这种行为不好？</p><ul><li>通过发送大量意外流量来瘫痪您的服务器，特别是对于每天获得数百万页面浏览量的页面。</li><li>浪费服务器计算周期生成一个永远不会被查看的页面。</li><li>可能损坏的用户数据。如果您通过Cookie或以其他方式跟踪请求中的状态，则可能会销毁数据。即使图像请求没有返回图像，浏览器也会读取并接受所有标题，包括所有的Cookie。虽然其余的反应被抛弃，但损害可能已经完成。</li></ul><h1 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h1><h3 id="保持组件低于25K"><a href="#保持组件低于25K" class="headerlink" title="保持组件低于25K"></a>保持组件低于25K</h3><p>此限制与iPhone不会缓存大于25K的组件有关。请注意，这是未压缩的大小。这是缩小比例很重要的地方，因为gzip本身可能不够。</p><h3 id="将组件打包成多部分文档"><a href="#将组件打包成多部分文档" class="headerlink" title="将组件打包成多部分文档"></a>将组件打包成多部分文档</h3><p>将组件打包成多部分文档就像带有附件的电子邮件一样，它可以帮助您用一个HTTP请求获取多个组件（记住：HTTP请求很贵）。当你使用这种技术时，首先检查用户代理是否支持它（iPhone不支持）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小结于&quot;&gt;&lt;a href=&quot;#小结于&quot; class=&quot;headerlink&quot; title=&quot;小结于&quot;&gt;&lt;/a&gt;小结于&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1#menu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器请求和响应过程来谈性能优化</title>
    <link href="https://hotkang.cn/2018/05/29/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B%E6%9D%A5%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://hotkang.cn/2018/05/29/从浏览器请求和响应过程来谈性能优化/</id>
    <published>2018-05-29T00:52:08.000Z</published>
    <updated>2018-07-19T15:35:12.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小结于"><a href="#小结于" class="headerlink" title="小结于"></a>小结于</h2><p><img src="/img/XNGC.png" alt=""></p><a id="more"></a><ul><li><p>为什么前端性能如此重要？数据显示：</p><ul><li>只有10%~20%的最终用户响应时间用来下载HTML文档，其余80%~90%时间用在下载页面中的所有组件</li><li>优化后台成本大，优化前端只需要适当遵循一些法则就会有较大的提升，低成本高收益</li></ul></li></ul><h2 id="一、浏览器预处理"><a href="#一、浏览器预处理" class="headerlink" title="一、浏览器预处理"></a>一、浏览器预处理</h2><ul><li>查询Cache：读取Cache或者发送304 请求</li></ul><h2 id="二、查询DNS"><a href="#二、查询DNS" class="headerlink" title="二、查询DNS"></a>二、查询DNS</h2><blockquote><p>DNS查找就是输入域名对服务器IP地址的查找过程。<br>DNS缓存: 浏览器DNS缓存、操作系统DNS缓存。<br>当你输入<a href="http://www.google.com的时候，浏览器会先去自身的" target="_blank" rel="noopener">www.google.com的时候，浏览器会先去自身的</a> <code>DNS缓存</code> 里面查找有没有google服务器的IP地址;如果找不到则继续到 <code>操作系统的DNS缓存</code> 查找;如果浏览器在这两个容器都没有找到google的IP地址记录，则会向广域域名体系查找。</p></blockquote><h3 id="1-优化规则-减少DNS查找"><a href="#1-优化规则-减少DNS查找" class="headerlink" title="1. 优化规则 - 减少DNS查找"></a><code>1. 优化规则 - 减少DNS查找</code></h3><ul><li>方法1：使用DNS缓存<br>浏览器DNS缓存 | 计算机DNS缓存 | 服务器DNS缓存（TTL）</li></ul><ul><li><p>方法2：使用Keep-Alive特性<br>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。</p></li><li><p>方法3：较少的域名来减少DNS查找（2-4个主机）</p></li><li><p>方法4：使用第三方DNS域名解析加速服务<br>国内的一款免费DNS加速服务DNSPOD；</p></li></ul><h2 id="三、建立连接"><a href="#三、建立连接" class="headerlink" title="三、建立连接"></a>三、建立连接</h2><blockquote><p>CDN是一组分布在多个不同地理位置的Web服务器，由于距离用户 物理距离比较短，所以能够更加有利于用户获取到静态资源；这种服务通常需要购买，也有一些免费、通用的CDN可使用，国内的可以使用BootCDN。</p></blockquote><h3 id="2-优化规则-–-使用内容分发网络（CDN）"><a href="#2-优化规则-–-使用内容分发网络（CDN）" class="headerlink" title="2. 优化规则 – 使用内容分发网络（CDN）"></a><code>2. 优化规则 – 使用内容分发网络（CDN）</code></h3><ul><li><p>方法1：美国十大Internet网站和CDN服务提供商</p></li><li><p>方法2：页面静态化,取决于发布系统</p></li><li><p>方法3：Ctrip使用的China-Cache和网宿</p></li></ul><h3 id="3-优化规则-–-用域名划分页面内容"><a href="#3-优化规则-–-用域名划分页面内容" class="headerlink" title="3. 优化规则 – 用域名划分页面内容"></a><code>3. 优化规则 – 用域名划分页面内容</code></h3><p>按页面内容划分域名，在合适的资源服务器上存放文件</p><h2 id="四、发送请求"><a href="#四、发送请求" class="headerlink" title="四、发送请求"></a>四、发送请求</h2><blockquote><p>一般来说，使用外链的脚本和样式表更加有利。分别把外链脚本和样式表进行合并会减少HTTP请求，以节省客户端和服务器之间的通讯次数来加快页面打开速度。但是出于开发的便利，开发的时候一般会采取模块化的方式；这时候可以在部署前采用一些前端构建工具 <code>gulp</code> 、<code>grunt</code> 把这些模块文件合并起来再发布。</p></blockquote><h3 id="4-优化规则-–-减少HTTP请求"><a href="#4-优化规则-–-减少HTTP请求" class="headerlink" title="4. 优化规则 – 减少HTTP请求"></a><code>4. 优化规则 – 减少HTTP请求</code></h3><ul><li><p>图片地图</p><ul><li>假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。</li></ul><p><img src="/img/JL.png" alt=""></p><ul><li>服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应</li><li>客户端图片地图：直接将点击映射到操作</li></ul></li><li><p>内联图像</p></li><li><p>合并文件: js文件不超过7个,css文件不超过4个,各频道首页和全站首页不超过3个;</p></li><li>目前无法解决的是allyes广告的请求数。</li><li>大量的广告和产品图片可能会造成，图片请求数很大，可能造成总请求数指标吃紧，这个只能从设计上搞定，需要权衡</li><li><p>目前老页面可能css和js文件请求数可能会超标</p></li><li><p>合并样式和脚本</p></li></ul><h3 id="5-优化规则-–-优化CSS-Spirite-图片精灵"><a href="#5-优化规则-–-优化CSS-Spirite-图片精灵" class="headerlink" title="5. 优化规则 – 优化CSS Spirite(图片精灵)"></a><code>5. 优化规则 – 优化CSS Spirite(图片精灵)</code></h3><p>一种网页图片应用处理方式。允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，再利用CSS的以下属性精确的定位出背景图片的位置。</p><blockquote><p>background-image<br>background- repeat<br>background-position</p></blockquote><h3 id="6-优化规则-–-避免404错误"><a href="#6-优化规则-–-避免404错误" class="headerlink" title="6. 优化规则 – 避免404错误"></a><code>6. 优化规则 – 避免404错误</code></h3><p>HTTP请求很昂贵，因此提出HTTP请求并获得无用的响应（即404 Not Found）是完全没有必要的，会减慢用户体验没有任何好处。</p><p>有些网站有帮助的404“你的意思是X？”，这对用户体验很好，但也浪费了服务器资源（如数据库等）。</p><p>特别糟糕的是，当到外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应正文，就好像它是JavaScript代码一样，试图找到可用的东西。</p><h3 id="7-优化规则-–-不要使用frameset-少使用iframe"><a href="#7-优化规则-–-不要使用frameset-少使用iframe" class="headerlink" title="7. 优化规则 – 不要使用frameset,少使用iframe"></a><code>7. 优化规则 – 不要使用frameset,少使用iframe</code></h3><p>搜索引擎不友好，即使内容为空，加载也需要时间、会阻止页面加载</p><p>Iframe允许将HTML文档插入到父文档中。了解iframe如何工作以便可以有效使用非常重要。</p><ul><li><p><code>&lt;iframe&gt;</code>优点：</p><ul><li>像徽章和广告等缓慢的第三方内容</li><li>安全沙箱</li><li>并行下载脚本</li></ul></li><li><p><code>&lt;iframe&gt;</code>缺点：</p><ul><li>即使空白也很昂贵</li><li>阻止页面载入</li><li>非语义</li></ul></li></ul><p>禁止使用iframe引入外部资源，不包括allyes广告，不包括about:blank的空页面。</p><h2 id="五、等待响应"><a href="#五、等待响应" class="headerlink" title="五、等待响应"></a>五、等待响应</h2><h3 id="8-优化规则-–-避免重定向"><a href="#8-优化规则-–-避免重定向" class="headerlink" title="8. 优化规则 – 避免重定向"></a><code>8. 优化规则 – 避免重定向</code></h3><p>以下是一个重定向的过程：</p><p>浏览器发送请求——&gt;服务器返回302——&gt;浏览器发送第二次请求—–&gt;服务器返回200—&gt;浏览器开始呈现</p><p>就是说，在重定向完毕并且HTML下载完毕之前，是没有任何东西显示给用户</p><p>要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。</p><p>涉及服务器负载、数据查询、服务器端缓存等</p><h2 id="六、接收数据"><a href="#六、接收数据" class="headerlink" title="六、接收数据"></a>六、接收数据</h2><h3 id="9-优化规则-–-压缩组件Gzip"><a href="#9-优化规则-–-压缩组件Gzip" class="headerlink" title="9. 优化规则 – 压缩组件Gzip"></a><code>9. 优化规则 – 压缩组件Gzip</code></h3><ul><li><p>HTML文档、脚本和样式表、XML和JSON的文本响应,压缩通常能将响应的数据量减少将近70%</p></li><li><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。</p></li><li><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p></li></ul><h3 id="10-优化规则-–-精简Javascript和CSS文件大小"><a href="#10-优化规则-–-精简Javascript和CSS文件大小" class="headerlink" title="10. 优化规则 – 精简Javascript和CSS文件大小"></a><code>10. 优化规则 – 精简Javascript和CSS文件大小</code></h3><ul><li><p>从代码中移除不必要的字符以减少其大小，减少加载时间。</p></li><li><p>减少JavaScript 文件大小的有几种手段:</p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。</li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。</li></ul></li></ul><h3 id="11-优化规则-–-尽量缩减页面大小"><a href="#11-优化规则-–-尽量缩减页面大小" class="headerlink" title="11. 优化规则 – 尽量缩减页面大小"></a><code>11. 优化规则 – 尽量缩减页面大小</code></h3><ul><li><p>页面必须小于150K(不含图片）</p></li><li><p>静态文件是否gzip</p></li><li>图片是否压缩优化过</li></ul><h2 id="七、读取Cache"><a href="#七、读取Cache" class="headerlink" title="七、读取Cache"></a>七、读取Cache</h2><h3 id="12-优化规则-–-添加-Expires-头或-Cache-Control"><a href="#12-优化规则-–-添加-Expires-头或-Cache-Control" class="headerlink" title="12. 优化规则 – 添加 Expires 头或 Cache-Control"></a><code>12. 优化规则 – 添加 Expires 头或 Cache-Control</code></h3><ul><li><p>Expires头是用来告诉浏览器该响应的有效期，可以理解为该资源的“保质期”，在期限内可以使用该资源的缓存不需要重新请求。</p></li><li><p>由于浏览器与服务器存在时钟同步问题，HTTP1.2.1还添加了Cache-Control和max-age来弥补Expires头的不足。</p></li><li>通常用于脚本、样式表、图片等静态资源。</li></ul><p>使用这种策略可能会遇到一个问题是，开发者可能想要在资源过期前这段时间更新它们。</p><p>这时候，由于浏览器的缓存还没失效，这就需要通过更改文件名来令静态资源 强制失效。有很多种方式给静态资源打上版本号，可以一本正经地打上数字版本号，根据内容生成哈希码也行，甚至有人用π来给自己的资源打版本号.</p><p>应用于不经常变化的组件，包括脚本、样式表、Flash组件、图片</p><h3 id="13-优化规则-–-使用外链JavaScript和CSS"><a href="#13-优化规则-–-使用外链JavaScript和CSS" class="headerlink" title="13. 优化规则 – 使用外链JavaScript和CSS"></a><code>13. 优化规则 – 使用外链JavaScript和CSS</code></h3><ul><li>尽可能 使用外链JavaScript和CSS，因为我们目前大部分avaScript和CSS都做了Gzip和缓存技术，可以充分利用。</li></ul><ul><li><p>使用外链样式和脚本优点有：</p><ul><li>可以被浏览器缓存起来；</li><li>组件可重用</li><li>可模块化；</li><li>能够被构建（合并压缩打版本）</li></ul></li><li><p>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</p></li><li>JavaScript和CSS位于浏览器：缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><h2 id="八、处理元素"><a href="#八、处理元素" class="headerlink" title="八、处理元素"></a>八、处理元素</h2><p>不要对image和pdf等二进制文件进行gzip压缩</p><h2 id="九、渲染元素"><a href="#九、渲染元素" class="headerlink" title="九、渲染元素"></a>九、渲染元素</h2><h3 id="14-优化规则-–-将样式表放在顶部"><a href="#14-优化规则-–-将样式表放在顶部" class="headerlink" title="14. 优化规则 – 将样式表放在顶部"></a><code>14. 优化规则 – 将样式表放在顶部</code></h3><ul><li><p>样式表放在底部时，浏览器会延迟显示任何可视化组件(使用 CSS 的@import 等同于把想要加载的样式放在底部，所以不建议使用。)</p></li><li><p>对于浏览器的渲染机制，本书并没有过多提及，只是对现象做出了描述以及提供了解决办法.</p></li><li><p>如果样式表仍然在加载，构建呈现树就是一种浪费，因为在所有样式表 加载并解析完毕 之前无需绘制任何东西。因为在样式表准备好之前显示内容会遇到 FOUC（无样式内容的闪烁，Flash of Unstyled Content）问题。</p></li><li>样式表不在顶部中，当遇到样式时，浏览器就会阻止页面呈现，等待样式表下载完毕。如果把样式表放在底部，在 IE 中还会产生白屏现象。</li><li>总之，把样式表放进就能避免这些问题。</li></ul><h3 id="15-优化规则-–-建议将脚本放在底部"><a href="#15-优化规则-–-建议将脚本放在底部" class="headerlink" title="15. 优化规则 – 建议将脚本放在底部"></a><code>15. 优化规则 – 建议将脚本放在底部</code></h3><p>一般浏览器可以允许并行下载，取决于主机个数、带宽等（默认情况下，IE是2个而FF是8个）下载脚本时并行下载实际上是被禁用的。</p><ul><li>脚本对页面的影响是：<ul><li>阻塞对其后面内容的呈现</li><li>阻塞后面组件的下载</li><li>浏览器会在下载脚本的时候阻塞并行下载，因为需要确保脚本能够顺序执行。<blockquote><p>但是，实际开发中有时候很难完全遵守这条准则，那只能把能够放在最后的都放在最后。</p></blockquote></li></ul></li></ul><h3 id="16-优化规则-–-移除重复脚本"><a href="#16-优化规则-–-移除重复脚本" class="headerlink" title="16. 优化规则 – 移除重复脚本"></a><code>16. 优化规则 – 移除重复脚本</code></h3><p>必须为0，重复的脚本对增加HTTP 请求次数和脚本执行的时间。</p><h3 id="17-优化规则-–-避免CSS表达式"><a href="#17-优化规则-–-避免CSS表达式" class="headerlink" title="17. 优化规则 – 避免CSS表达式"></a><code>17. 优化规则 – 避免CSS表达式</code></h3><p>使用CSS 的expression()通常会造成多次运算。影响浏览器渲染时间。实际上，需要用到CSS表达式的地方，通常能够找到其他替代方案，所以避免使用CSS表达式。</p><h3 id="18-优化规则-–-优化图像"><a href="#18-优化规则-–-优化图像" class="headerlink" title="18. 优化规则 – 优化图像"></a><code>18. 优化规则 – 优化图像</code></h3><ul><li><p>尽量使用GIF和PNG</p></li><li><p>尽量使用png/gif格式的图片，png的图片优先，但是必须注意如要兼容IE6，则png使用一定要注意透明问题。</p></li><li><p>图片在使用前一定要先用工具压缩优化（png、jpg）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小结于&quot;&gt;&lt;a href=&quot;#小结于&quot; class=&quot;headerlink&quot; title=&quot;小结于&quot;&gt;&lt;/a&gt;小结于&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/XNGC.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
