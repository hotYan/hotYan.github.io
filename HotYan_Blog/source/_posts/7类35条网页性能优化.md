---
title: 7类35条网页性能优化
date: 2018-05-29 08:52:55
tags: 性能优化
categories: 换个角度看性能优化
---

## 小结于
>  [参考链接](https://developer.yahoo.com/performance/rules.html?guccounter=1#menu)

<!--more-->

# 7类35项网页性能优化  

### [一、内容](#内容)  
[`1. 减少HTTP请求次数` ](#减少http请求次数)   
[`2. 减少DNS查询次数`](#减少dns查询次数)   
[`3. 避免重定向`  ](#避免重定向)   
[`4. 使Ajax可缓存`](#使ajax可缓存)  
[`5. 延迟加载组件`](#延迟加载组件)   
[`6. 预加载组件`  ](#预加载组件)  
[`7. 减少DOM元素的数量`](#减少dom元素的数量)    
[`8. 拆分组件跨域`  ](#拆分组件跨域)  
[`9. 尽量减少iframe的数量`](#尽量减少iframe的数量)  
[`10. 避免404`](#避免404)
### [二、CSS](#css)
[`11. 将样式表放置在顶部`  ](#将样式表放置在顶部)  
[`12. 避免使用CSS表达式`  ](#避免使用css表达式)  
[`13. 用<link>替代@import`](#用link替代import)   
[`14. 避免过滤器Filters`](#避免过滤器filters)

### [三、JavaScript](#javascript)
[`15. 将脚本放在底部`  ](#将脚本放在底部)  
[`16. 使JavaScript和CSS在外部`](#使javascript和css在外部)    
[`17. 精简JavaScript和CSS`](#精简javascript和css)   
[`18. 删除重复的脚本`  ](#删除重复的脚本)  
[`19. 最小化DOM访问`  ](#最小化dom访问)  
[`20. 开发智能事件处理程序`](#开发智能事件处理程序)  
### [四、图片](#图片)
[`21. 优化图像`  ](#优化图像)  
[`22. 优化CSS精灵`  ](#优化css精灵)  
[`23. 不要在HTML中缩放图像`  ](#不要在html中缩放图像)  
[`24. 制作favicon.ico Small和Cacheable`](#制作faviconicosmall和cacheable) 
### [五、Cookie](#cookie)
[`25. 减小Cookie大小`  ](#减小cookie大小)  
[`26. 页面内容使用无Cookie域`](#页面内容使用无cookie域)  
### [六、服务器](#服务器)
[`27. 使用内容分发网络CDN`  ](#使用内容分发网络cdn)  
[`28. 添加Expires或Cache-Control标题`](#添加expires或cache-control标题)  
[`29. Gzip压缩传输文件`](#gzip压缩传输文件)  
[`30. 配置ETags`  ](#配置etags)  
[`31. 尽早flush输出`  ](#尽早flush输出)  
[`32. 使用GET获取AJAX请求`](#使用get获取ajax请求)  
[`33. 避免空图像src`  ](#避免空图像src)
### [七、手机](#手机)
[`34. 保持组件低于25K`  ](#保持组件低于25k)  
[`35. 将组件打包成多部分文档`](#将组件打包成多部分文档)

---------

##   内容
###  减少HTTP请求次数

终端用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像、样式表、脚本、Flash等。    
减少组件数量又会减少呈现页面所需的HTTP请求数量。这是更快页面的关键。

减少页面中组件数量的一种方法是简化页面的设计。但是，有没有办法构建更丰富的内容，同时实现快速响应时间？  

以下是一些减少HTTP请求数量的技术，同时还支持丰富的页面设计。

- `组合文件`是一种通过将所有脚本合并为一个脚本来减少HTTP请求数量的方法，同样也可以将所有CSS合并到一个样式表中。当脚本和样式表因页面而异时，将文件组合起来更具挑战性，但使发布过程的这一部分能够缩短响应时间。

- `CSS Sprites`是减少图片请求数量的首选方法。将背景图像组合成单个图像，并使用CSSbackground-image和background-position属性显示所需的图像片段。

- `图像映射`将多个图像组合成单个图像。整体大小大致相同，但减少HTTP请求的数量会加快页面的速度。仅当图像在页面中连续存在时（例如导航栏），图像映射才起作用。定义图像映射的坐标可能很乏味且容易出错。使用图像地图进行导航也无法访问，因此不推荐。

- `内联图像`使用data:URL方案将图像数据嵌入到实际页面中。这可以增加HTML文档的大小。将内嵌图像合并到缓存的样式表中是减少HTTP请求并避免增加页面大小的一种方法。所有主流浏览器都不支持内嵌图像。

减少页面中的HTTP请求数量是开始的地方。这是提高初次访问者性能的最重要指导方针。  

###  减少DNS查询次数


`域名系统（DNS）`将主机名映射到IP地址，就像电话本将人名映射到他们的电话号码一样。  
当您在浏览器中输入www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。  
DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。直到DNS查找完成后，浏览器才能从此主机名下载任何内容。

DNS查找缓存以获得更好的性能。这种高速缓存可以发生在用户的ISP或局域网维护的特殊高速缓存服务器上，但也可以在个人用户的计算机上进行高速缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器在自己的缓存中保存了一条DNS记录，它就不会打扰操作系统请求记录。

按照DnsCacheTimeout注册表设置的指定，Internet Explorer默认缓存DNS查找30分钟 。Firefox缓存DNS查找1分钟，由network.dnsCacheExpiration配置设置控制。（Fasterfox将此更改为1小时。）

当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。

减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间取得了很好的折衷。

###  避免重定向

重定向是使用301和302状态码完成的。
    
浏览器会自动将用户转到该Location字段中指定的URL 。重定向所需的所有信息都在标题中,响应的主体通常是空的。    

尽管名称不同，301和302响应在实践中都不会被缓存，除非额外的标头（例如Expires或Cache-Control）指示它应该是。  

元刷新标记和JavaScript是将用户引导到不同URL的其他方式，但是如果您必须执行重定向，首选方法是使用标准的3xx HTTP状态代码，主要是为了确保后退按钮正常工作。

要记住的重点是`重定向会减慢用户体验`。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。

将旧网站连接到新网站是重定向的另一个常见用途。

其他包括连接网站的不同部分，并根据特定条件（浏览器类型，用户帐户类型等）指导用户。  

使用重定向来连接两个网站很简单，只需要很少的附加编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。  

这种重定向的替代方案包括使用Alias和mod_rewrite如果两个代码路径托管在同一台服务器上。  

如果域名更改是使用重定向的原因，另一种方法是创建一个CNAME（一个DNS记录，用于创建一个别名从一个域名指向另一个域名）与Alias或mod_rewrite。

###  使Ajax可缓存

Ajax引用的好处之一是，它向用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待这些异步JavaScript和XML响应返回时扭动拇指。  

在许多应用程序中，用户是否在等待取决于如何使用Ajax。例如，在基于Web的电子邮件客户端中，用户将不断等待Ajax请求的结果，以查找与其搜索条件匹配的所有电子邮件。记住“异步”并不意味着“即时”。

为了提高性能，优化这些Ajax响应非常重要。  

提高Ajax性能的最重要方法是使响应可缓存，如`添加过期或缓存控制头`中所述。  

- 其他一些规则也适用于Ajax：
Gzip组件
减少DNS查找
缩小JavaScript
避免重定向
配置ETags

###   延迟加载组件

你可以仔细看看你的页面，并问自己：“为了最初呈现页面，绝对需要什么？”。其余的内容和组件可以等待。

JavaScript是在onload事件之前和之后进行分割的理想人选。  

例如，如果您有JavaScript代码和用于拖放和动画的库，则可以等待，因为在初始渲染之后拖动页面上的元素。其他要查找候选人进行后加载的地方包括隐藏内容（用户操作后显示的内容）和低于该对象的图像。


性能目标与其他Web开发最佳实践保持一致是很好的。在这种情况下，逐步增强的想法告诉我们，JavaScript在受支持的情况下可以改善用户体验，但是即使没有JavaScript，您也必须确保页面能够正常工作。  

因此，在确保页面正常工作后，您可以使用一些后期加载的脚本来增强它，从而为您提供更多的细节和哨音，例如拖放和动画。


###  预加载组件

预加载看起来可能与后加载相反，但它实际上有一个不同的目标。通过预加载组件，您可以利用浏览器闲置的时间以及将来需要的组件（如图像，样式和脚本）。通过这种方式，当用户访问下一页时，您可以将大部分组件都存储在缓存中，并且您的页面将为用户加载得更快。

实际上有几种类型的预加载：

- 无条件预加载:只要onload激活，您就可以继续并获取一些额外的组件。

- 有条件预加载:根据用户操作，您可以根据用户的行为猜测下一个用户前进的位置并相应地进行预加载。
- 预期的预加载:在启动重新设计之前提前预加载。它经常发生在重新设计之后，您会听到：“新网站很酷，但速度比以前慢”。部分问题可能在于用户使用完全缓存访问旧网站，但新网站总是空的缓存体验。您甚至可以在启动重新设计之前通过预加载某些组件来减轻这种副作用。您的旧网站可以使用浏览器闲置的时间，并请求将由新网站使用的图像和脚本


###   减少DOM元素的数量

复杂的页面意味着需要下载更多的字节，这也意味着JavaScript中的DOM访问速度较慢。例如，当您想要添加事件处理程序时，如果在页面上循环遍历500或5000个DOM元素，则会有所不同。

大量的DOM元素可能是一种症状，应该通过页面的标记来改善某些内容，而不必删除内容。

DOM元素的数量很容易测试，只需输入Firebug的控制台：
      document.getElementsByTagName('*').length


###  拆分组件跨域

拆分组件可让您最大限度地平行下载。由于DNS查找惩罚，请确保您使用的域不超过2-4个。

###  尽量减少iframe的数量

Iframe允许将HTML文档插入到父文档中。了解iframe如何工作以便可以有效使用非常重要。

- ``<iframe> ``优点：

  - 像徽章和广告等缓慢的第三方内容
  - 安全沙箱
  - 并行下载脚本
- ``<iframe> ``缺点：

  - 即使空白也很昂贵
  - 阻止页面载入
  - 非语义

###   避免404

HTTP请求很昂贵，因此提出HTTP请求并获得无用的响应（即404 Not Found）是完全没有必要的，并且会减慢用户体验而没有任何好处。

有些网站有帮助的404s“你的意思是X？”，这对用户体验很好，但也浪费了服务器资源（如数据库等）。特别糟糕的是，当到外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应正文，就好像它是JavaScript代码一样，试图找到可用的东西。


# CSS
###  将样式表放置在顶部

将样式表移动到文档HEAD中,页面显示加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。这改善了整体用户体验。

将样式表放在文档底部附近的问题:它禁止在许多浏览器（包括Internet Explorer）中进行渐进式呈现。这些浏览器会阻止渲染，以避免在样式更改时重新绘制页面元素。用户停留在查看空白页面。

没有任何替代方案，空白屏幕或无风格内容的闪光都值得冒这个风险。最佳解决方案是遵循HTML规范，并将样式表加载到文档HEAD中。


###   避免使用CSS表达式

CSS表达式是动态设置CSS属性的强大（也是危险的）方法。  
从版本5开始，它们在Internet Explorer中受支持，但从IE8开始已弃用。  

表达式的问题在于它们比大多数人期望的更频繁地进行评估。

减少CSS表达式评估次数的一种方法是使用一次性表达式，第一次评估表达式时，它将style属性设置为一个显式值，该值将替换CSS表达式。  

如果样式属性必须在页面的整个生命周期中动态设置，则使用事件处理程序而不是CSS表达式是一种替代方法。  

如果您必须使用CSS表达式，请记住它们可能会被评估数千次，并且可能会影响页面的性能。

###   用`<link>`替代@import


以前的最佳实践之一指出，为了允许渐进式渲染，CSS应该处于顶端。

在IE中的@import行为与<link>在页面底部使用的行为相同，因此最好不要使用它。


###   避免过滤器Filters

IE专有AlphaImageLoader过滤器旨在解决IE版本<7中的半透明真彩色PNG问题。该过滤器的问题在于，它会在图像下载时阻止渲染并冻结浏览器。它也增加了内存消耗，并且每个元素应用，而不是每个图像，因此问题倍增。

最好的方法是AlphaImageLoader完全避免使用PNG8而不是降级，这在IE中是很好的。如果您绝对需要AlphaImageLoader，请使用下划线黑客_filter来惩罚您的IE7 +用户。

# JavaScript
###   将脚本放在底部

脚本导致的问题是它们会阻止并行下载。  

在HTTP / 1.1规范建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以同时发生两个以上的下载。然而，当脚本正在下载时，浏览器将不会启动任何其他下载，即使是在不同的主机名上。

在某些情况下，将脚本移动到底部并不容易。例如，如果脚本用于document.write插入页面内容的一部分，则不能在页面中移动较小的内容。也可能存在范围问题。在很多情况下，有办法解决这些情况。

经常出现的另一个建议是使用延迟脚本。  
该DEFER属性指示该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该DEFER属性。在Internet Explorer中，该脚本可能会延迟，但不如预期的那么多。如果脚本可以被延期，它也可以被移动到页面的底部。这会让你的网页加载速度更快。

###  使JavaScript和CSS在外部

许多这些性能规则涉及如何管理外部组件。但是，在出现这些问题之前，您应该提出一个更基本的问题：JavaScript和CSS应该包含在外部文件中还是包含在页面本身中？

在现实世界中`使用外部文件通常会产生更快的页面`，因为浏览器会缓存JavaScript和CSS文件。

- 内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。
- JavaScript和CSS位于浏览器缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。

>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。

许多网站都处于这些指标的中间。对于这些网站，最好的解决方案通常是将JavaScript和CSS作为外部文件进行部署。首选内联的唯一例外是主页，例如雅虎的首页和My Yahoo! 。每个会话只有很少（可能只有一个）页面视图的主页可能会发现内嵌JavaScript和CSS可以缩短最终用户的响应时间。

对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少以及通过使用外部文件实现的缓存优点。其中一种方法是在首页内嵌JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已经在浏览器缓存中的外部文件。

###  精简JavaScript和CSS

- 在JavaScript的情况下，由于下载文件的大小减小，这提高了响应时间性能。
- 从代码中移除不必要的字符以减少其大小，减少加载时间。  
- 减少JavaScript 文件大小的有几种手段:  
  - 精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。

  - 混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。
  - 但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。 
  - 现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。  
  
###  删除重复的脚本

在一个页面中包含两次相同的JavaScript文件会使性能受损。

当它发生时，通过创建不必要的HTTP请求和浪费JavaScript执行，重复脚本会损害性能。

不必要的HTTP请求发生在Internet Explorer中，但不在Firefox中。  

在Internet Explorer中，如果外部脚本包含两次并且不可缓存，则会在加载页面期间生成两个HTTP请求。如果脚本可缓存，当用户重新加载页面时也会发生额外的HTTP请求。

除了生成浪费的HTTP请求之外，还会浪费多次时间评估脚本。无论脚本是否可缓存，此冗余JavaScript执行都会在Firefox和Internet Explorer中发生。

###  最小化DOM访问

使用JavaScript访问DOM元素很慢，所以为了获得更响应的页面，您应该：

- 缓存对访问元素的引用
- 更新节点“脱机”，然后将它们添加到树中
- 避免使用JavaScript修复布局


###  开发智能事件处理程序

有时由于过多的事件处理程序附加到DOM树的不同元素上，而这些事件处理程序过于频繁地执行，有时页面的响应速度会降低 这就是为什么使用事件授权是一个好方法。  

如果在a中有10个按钮div，则只将一个事件处理程序附加到div包装器，而不是每个按钮的一个处理程序。事件冒泡，所以你可以捕捉事件并找出它起源于哪个按钮。

您也不需要等待onload事件才能开始使用DOM树进行操作。通常你需要的是你想访问的元素在树中可用。您不必等待下载所有图像。   

DOMContentLoaded是您可能考虑使用而不是onload的事件.



# 图片

###   优化图像

- 减少图像周围的空白。 一些开发人员使用空白的填充这是万万要不得的。裁剪图像，删除图像周围任何空白，并使用CSS来填充。

- 使用正确的文件格式。如果你有图标，或者没有太多颜色的图形，可以保存为GIF这种较少颜色的图形。如果你有更详细的图形，可以使用JPG文件格式，降低质量保存图像。
- 以适当的尺寸保存图像。如果您正在使用HTML和CSS来调整您的图像，那么不要这样。以期望的大小保存你的图像，从而减少文件大小。  

> 恰当的图片格式：
>- PNG格式几乎一直优于GIF格式，尽管某些旧版浏览器只能为PNG格式提供部分支持。
>- 为较小或简单的图形（例如，小于10x10像素的图形或调色板小于3色的图形）以及包含动画的图片使用GIF格式。
>- 为所有摄影风格的图片使用JPG格式。
>- 请勿使用BMP格式或TIFF格式。



###  优化CSS精灵

一种网页图片应用处理方式。允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，再利用CSS的以下属性精确的定位出背景图片的位置。
>background-image  
background- repeat  
background-position 
  



###  不要在HTML中缩放图像

指定所有图片的宽度和高度可以加速渲染，因为省去了不必要的回流和重绘。


###  制作`favicon.icoSmall`和Cacheable

favicon.ico是保留在服务器根目录中的映像。这是一个必要的罪恶，因为即使你不关心它，浏览器仍然会请求它，所以最好不要回应404 Not Found。  

另外，由于它位于同一台服务器上，每次请求时都会发送Cookie。此图片还会干扰下载顺序，例如在IE中，当您在onload中请求额外的组件时，favicon会在这些额外的组件之前下载。

因此，要减轻拥有favicon.ico的缺点，请确保：

- 它很小，最好在1K以下。
- 设置过期标题与你感觉舒适（因为你不能重命名，如果你决定改变它）。您几乎可以在将来几个月安全地设置Expires标题。您可以查看您当前的favicon.ico的最后修改日期，以做出明智的决定。
- Imagemagick可以帮助您创建小型图标

# Cookie
###  减小Cookie大小

HTTP cookie由于各种原因（如身份验证和个性化）而被使用。有关cookie的信息在Web服务器和浏览器之间的HTTP标头中交换。尽可能降低cookies的大小以尽量减少对用户响应时间的影响，这一点很重要。

- 消除不必要的cookie
- 尽可能降低Cookie大小，以尽量减少对用户响应时间的影响
- 请注意在适当的域级别设置cookie，以便其他子域不受影响
- 适当设置过期日期。更早的过期日期或不更早删除cookie，提高用户响应时间


###  页面内容使用无Cookie域

当浏览器发出静态图像请求并将cookie与请求一起发送时，服务器对这些cookie没有任何用处。所以他们只是没有理由地创建网络流量。您应该确保使用无cookie请求来请求静态组件。创建一个子域，并在其中托管所有静态组件。

在无Cookie域上托管静态组件的另一个好处是，某些代理可能会拒绝缓存使用cookie请求的组件。

# 服务器
###  使用内容分发网络CDN

- 用户与Web服务器的距离对响应时间有影响。在多个地理位置分散的服务器上部署您的内容将使您的网页从用户的角度更快加载。但是你应该从哪里开始？

作为实现地理上分散的内容的第一步，不要尝试重新设计您的Web应用程序以在分布式架构中工作。根据应用程序的不同，更改体系结构可能包括艰巨的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与内容之间的距离可能会延迟或不能通过此应用程序体系结构步骤。

请记住，80-90％的最终用户响应时间用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是性能黄金法则。  

不要从重新设计应用程序体系结构的艰巨任务开始，最好先分散您的静态内容。这不仅实现了响应时间的更大缩短，而且由于内容交付网络，这更容易实现。

`内容传送网络（CDN）`是分布在多个位置的网络服务器的集合，以更高效地向用户传送内容。选择用于将内容递送给特定用户的服务器通常基于网络邻近度的度量。例如，选择网络跳数最少的服务器或响应时间最快的服务器。

一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如Akamai Technologies，EdgeCast或level3）具有成本效益。对于创业公司和私人网站来说，CDN服务的成本可能会很高，但随着您的目标受众不断扩大并变得更加全球化，CDN是实现快速响应所必需的。


###  添加Expires或`Cache-Control`标题

这条规则有两个方面：

- 对于静态组件：通过设置远期`Expires`标题实现“永不过期”策略
- 对于动态组件：使用适当的`Cache-Control`头文件来帮助浏览器提供有条件的请求

网页设计越来越丰富，这意味着更多的脚本，样式表，图像和Flash在页面中。  

首次访问您的页面可能需要发出多个HTTP请求，但通过使用Expires标头，可以使这些组件可缓存。这避免了后续页面浏览中不必要的HTTP请求。  

过期标头最常用于图像，但它们应该用于所有组件，包括脚本，样式表和Flash组件。

浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，使网页加载速度更快。  
Web服务器使用HTTP响应中的Expires标头告诉客户端可以缓存组件的时间。  

请记住，如果您使用远期未来的Expires头文件，则只要组件更改，就必须更改组件的文件名。

只有在用户已经访问过您的网站后，使用远期未来的Expires标题才会影响页面浏览。  

当用户第一次访问您的网站并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。  

因此，这种性能改进的影响取决于用户多久访问一次带有缓冲区的页面。（一个“准备好的缓存”已经包含了页面中的所有组件。）我们在Yahoo!上测试了这一点。并发现带有引导缓存的页面浏览量为75-85％。通过使用远期未来的Expires标题，您可以增加浏览器缓存的组件数量，并在后续页面浏览中重新使用，而无需在用户的Internet连接上发送单个字节。

###  Gzip压缩传输文件

通过网络传输HTTP请求和响应所需的时间可以通过前端工程师做出的决策大大减少。  

确实，最终用户的带宽速度，互联网服务提供商，邻近对等交换点等是超出了开发团队的控制范围。  

但还有其他一些影响响应时间的因素。  

压缩通过减少HTTP响应的大小来缩短响应时间。

从HTTP / 1.1开始，Web客户端通过HTTP请求中的Accept-Encoding标头指示对压缩的支持。  

      Accept-Encoding：gzip，deflate

如果Web服务器在请求中看到该头部，则可能使用客户端列出的方法之一压缩响应。  

Web服务器通过响应中的Content-Encoding标头通知Web客户端。

      内容编码：gzip

>Gzip是目前最流行和最有效的压缩方法。它由GNU项目开发并由RFC 1952标准化。您可能会看到的唯一的其他压缩格式是压缩，但效果不太好，不太受欢迎。Gzipping通常将响应大小减少约70％。目前大约90％的互联网流量都通过声称支持gzip的浏览器。

>浏览器和代理存在已知的问题，这些问题可能会导致浏览器期望的不匹配和接收到的有关压缩内容的不匹配。幸运的是，随着旧版浏览器的使用下降，这些边缘案例正在减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。

服务器根据文件类型选择要压缩的内容，但在决定压缩的内容时通常太有限。  

大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。  

图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。

尽可能多地缩放文件类型是减少页面重量和加速用户体验的简单方法。

###  配置ETags

实体标签（ETags）是Web服务器和浏览器用来确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（一个“实体”是另一个词“组件”：图像，脚本，样式表等）  

ETag被添加来提供一种机制来验证比上一次修改日期更灵活的实体。  

ETag是唯一标识组件特定版本的字符串。唯一的格式约束是字符串被引用。原始服务器使用ETag响应头指定组件的ETag 。

      HTTP / 1.1 200 OK
      Last-Modified：Tue，2006年12月12日03:03:59 GMT
      ETag：“10c24bc-4ab-457e1c1f”
      内容长度：12195

之后，如果浏览器必须验证组件，它将使用If-None-Match标头将ETag传递回原始服务器。如果ETags匹配，则返回一个304状态码，在此示例中将响应减少12195字节。

      GET /i/yahoo.gif HTTP / 1.1
      主持人：us.yimg.com
      If-Modified-Since：星期二，2006年12月12日03:03:59 GMT
      If-None-Match：“10c24bc-4ab-457e1c1f”
      HTTP / 1.1 304未修改

ETags的问题在于，它们通常使用属性来构建，这些属性使它们对托管站点的特定服务器是唯一的。  

当浏览器从一台服务器获取原始组件并稍后尝试在另一台服务器上验证该组件时，ETags将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。

虽然给定的文件可能位于多个服务器的相同目录中，并且具有相同的文件大小，权限，时间戳等，但其inode不同于一台服务器。

IIS 5.0和6.0与ETags有类似的问题。IIS上ETags的格式是Filetimestamp:ChangeNumber。A ChangeNumber是用于跟踪IIS配置更改的计数器。ChangeNumber在网站后面的所有IIS服务器上都不可能是相同的。

最终结果是由Apache和IIS生成的ETags完全相同的组件不会从一台服务器到另一台服务器进行匹配。如果ETags不匹配，用户不会收到ETags设计的小而快的304响应; 相反，他们会得到一个正常的200响应以及组件的所有数据。  

如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多台服务器托管您的网站，并且您使用的是默认的ETag配置的Apache或IIS，那么您的用户的页面速度会变慢，您的服务器的负载会更高，消耗的带宽也会更大，高效地缓存您的内容。即使你的组件有一个遥远的将来Expires头，当用户点击重新加载或刷新时，仍然会发出条件GET请求。

如果您没有充分利用ETags提供的灵活验证模型，最好完全删除ETag。  

该Last-Modified头验证基于对组件的时间戳。  

删除ETag可以减少响应和后续请求中HTTP头的大小。


###  尽早flush输出

当用户请求页面时，后端服务器可能需要200到500毫秒才能将HTML页面拼接在一起。在此期间，浏览器在等待数据到达时处于空闲状态。  

在PHP中，你有函数flush（）。  

它允许您将部分就绪的HTML响应发送到浏览器，以便浏览器可以在您的后端忙于HTML页面的其余部分时开始获取组件。好处主要出现在繁忙的后端或前端。
考虑刷新的好地方就在HEAD之后，因为头部的HTML通常更容易生成，并且允许您在浏览器中包含任何CSS和JavaScript文件，以便在后端仍在处理的同时开始并行读取。

###  使用GET获取AJAX请求

在使用时XMLHttpRequest，POST在浏览器中实现为两步：首先发送标题，然后发送数据。所以最好使用GET，它只需要一个TCP数据包发送（除非你有很多的cookie）。  

IE中最大的URL长度是2K，所以如果你发送的数据超过2K，你可能无法使用GET。

一个有趣的副作用是POST没有实际发布任何数据就像GET一样。  

基于HTTP规范，GET旨在用于检索信息，所以在您仅请求数据时使用GET（在语义上）是合理的，而不是将数据发送到服务器端存储。

###  避免空图像src

具有空字符串src属性的图像会发生超过一个人的预期。它以两种形式出现：

- ``<img src =“”>``  
- ``var img = new Image（）;  ``   
``img.src =“”;``
  
两种形式都会产生相同的效果：浏览器向您的服务器发出另一个请求

>Internet Explorer向该页面所在的目录发出请求。  
Safari和Chrome向实际页面本身发出请求。  
Firefox 3和更早版本的行为与Safari和Chrome相同，但版本3.5解决了此问题[错误444931]，不再发送请求。  
当遇到空图像src时，Opera不会执行任何操作。

为什么这种行为不好？

- 通过发送大量意外流量来瘫痪您的服务器，特别是对于每天获得数百万页面浏览量的页面。
- 浪费服务器计算周期生成一个永远不会被查看的页面。
- 可能损坏的用户数据。如果您通过Cookie或以其他方式跟踪请求中的状态，则可能会销毁数据。即使图像请求没有返回图像，浏览器也会读取并接受所有标题，包括所有的Cookie。虽然其余的反应被抛弃，但损害可能已经完成。

# 手机
###  保持组件低于25K

此限制与iPhone不会缓存大于25K的组件有关。请注意，这是未压缩的大小。这是缩小比例很重要的地方，因为gzip本身可能不够。


###  将组件打包成多部分文档

将组件打包成多部分文档就像带有附件的电子邮件一样，它可以帮助您用一个HTTP请求获取多个组件（记住：HTTP请求很贵）。当你使用这种技术时，首先检查用户代理是否支持它（iPhone不支持）。
