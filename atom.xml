<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HotYan&#39;s Blog</title>
  
  <subtitle>程序媛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hotkang.cn/"/>
  <updated>2018-12-05T13:59:20.606Z</updated>
  <id>https://hotkang.cn/</id>
  
  <author>
    <name>hotYan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes</title>
    <link href="https://hotkang.cn/2018/Notes/"/>
    <id>https://hotkang.cn/2018/Notes/</id>
    <published>2018-12-02T10:06:09.000Z</published>
    <updated>2018-12-05T13:59:20.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔记大全-持续完善"><a href="#笔记大全-持续完善" class="headerlink" title="笔记大全 [持续完善]"></a>笔记大全 <span style="font-size:.5em">[持续完善]</span></h2><a id="more"></a><p><br><br><br></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><hr><h3 id="1-InterviewMap"><a href="#1-InterviewMap" class="headerlink" title="1. InterviewMap"></a><a href="https://yuchengkai.cn/docs/zh/frontend/" target="_blank" rel="noopener">1. InterviewMap</a></h3><h3 id="2-木易杨’s-blog"><a href="#2-木易杨’s-blog" class="headerlink" title="2. 木易杨’s blog"></a><a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">2. 木易杨’s blog</a></h3><h3 id="3-amandakelake’s-blog"><a href="#3-amandakelake’s-blog" class="headerlink" title="3. amandakelake’s blog"></a><a href="https://github.com/amandakelake/blog" target="_blank" rel="noopener">3. amandakelake’s blog</a></h3><h3 id="4-一像素’s-bolg"><a href="#4-一像素’s-bolg" class="headerlink" title="4.一像素’s bolg"></a><a href="https://www.cnblogs.com/onepixel/" target="_blank" rel="noopener">4.一像素’s bolg</a></h3><h3 id="5-W3school"><a href="#5-W3school" class="headerlink" title="5.W3school"></a><a href="http://www.w3school.com.cn/index.html" target="_blank" rel="noopener">5.W3school</a></h3><h3 id="6-菜鸟教程"><a href="#6-菜鸟教程" class="headerlink" title="6.菜鸟教程"></a><a href="http://www.runoob.com/" target="_blank" rel="noopener">6.菜鸟教程</a></h3><p><br><br><br></p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><hr><blockquote><h3 id="HTML语义化？"><a href="#HTML语义化？" class="headerlink" title="HTML语义化？"></a>HTML语义化？</h3><p>根据内容的结构化(内容语义化),选择合适的标签(代码语义化)便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p></blockquote><p><br></p><blockquote><h3 id="为什么要语义化？"><a href="#为什么要语义化？" class="headerlink" title="为什么要语义化？"></a>为什么要语义化？</h3></blockquote><ol><li><strong>页面结构清晰</strong>：在没有CSS的情况下,页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看；</li><li><strong>利于SEO</strong>:和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li><strong>支持更多设备</strong>：方便其他设备解析(如屏幕阅读器、盲人阅读器、移动设备)，以有意义的方式来渲染网页；</li><li><strong>便于团队开发和维护</strong>:语义化更具可读性,团队遵循这个标准,可以减少差异化。</li><li><strong>用户体验</strong>:例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；</li></ol><p><br></p><blockquote><h3 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h3></blockquote><ol><li><p>根据页面选用最适合表达当前语义的标签，少使用无语义的标签 div 和 span；</p></li><li><p>在语义不明显,既可以使用div或p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</p></li><li>不要使用带有样式的标签，比如：b 、 u 、 font 等，改用 CSS 设置；</li><li>标题标签的使用应该根据重要性逐级递减，没有断层，并且一个页面只能有一个 h1；</li><li>提高关键词密度，如图像的替代文本 alt，提示文本 title；</li><li>正确使用内容容器，比如段落 p，列表 ul/li、 ol/li 、 dl/dt/dd;</li><li>需要强调的文本，可以使用 strong 或 em 标签,strong 默认样式是加粗(不用b)，em是斜体(不用i)；</li><li>表格注意使用，标题 caption，表头 thead，表格主体（正文）tbody，表注（页脚）tfoot。tr 定义表格行，th 定义表头，td 定义表格单元。</li><li>表单域使用 fieldset标签，并且legend 标签为 fieldset 定义标题；</li><li>每个 input 标签对应的说明文本都需要使用 label 标签，通过为 input 设置 id 属性，并且在 lable 标签中设置 for=id 使说明文本和对应的 input 关联。</li></ol><p>语义化标签:h1~h6、header、footer、nav、section、article、aside、figure、datalist、details</p><p><br></p><blockquote><h3 id="文档类型声明-lt-DOCTYPE-gt"><a href="#文档类型声明-lt-DOCTYPE-gt" class="headerlink" title="文档类型声明 &lt;!DOCTYPE&gt;"></a>文档类型声明 <code>&lt;!DOCTYPE&gt;</code></h3><p>html5，启用标准模式。<code>&lt;!DOCTYPE html&gt;</code></p><p>html4.01，告知 Web 浏览器,页面使用了哪种 HTML 版本。</p></blockquote><p>html5 不基于 SGML(标准通用标记语言)，文档类型声明不要求引用 DTD(文档类型定义)。html4.01 基于 SGML。文档类型声明需引用 DTD。DTD 指定了标记语言的规则，确保了浏览器能够正确渲染内容。</p><p><strong>SGML:</strong> (Standard Generalized Markup Language,标准通用标记语言)是现时常用的超文本格式的最高层次 <b>标准</b> ，是可以定义标记语言的元语言。</p><p><strong>DTD:</strong>（Document Type Definition,文档类型定义）可定义合法的XML文档构建模块。</p><p><strong>XML Schema:</strong> 可定义合法的XML文档构建模块，基于 XML 的 DTD 替代物。与 DTD 不同的是XML Schema支持数据类型和命名空间。XML Schema语言也可作为 XSD（XML Schema Definition）来引用。</p><p><br></p><blockquote><h3 id="目前浏览器的排版引擎有三种模式："><a href="#目前浏览器的排版引擎有三种模式：" class="headerlink" title="目前浏览器的排版引擎有三种模式："></a>目前浏览器的排版引擎有三种模式：</h3><p><strong>怪异模式(Quirks mode):</strong> 页面以<strong>宽松向后兼容</strong> 的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p><p>接近标准模式（Almost standards mode）:</p><p><strong>标准模式(Standards mode):</strong> 以该浏览器支持的 <strong>最高标准运行</strong>。</p></blockquote><p><strong>Browser一般用标准模式去解析和渲染现代规范的网页,使用怪异模式去渲染古老的网页。</strong> 而在IE的开发者工具中,你可以自定义改变文档模式,这在其他浏览器中是不行的.</p><p><br></p><h3 id="标准模式-怪异模式对渲染页面的影响"><a href="#标准模式-怪异模式对渲染页面的影响" class="headerlink" title="标准模式/怪异模式对渲染页面的影响"></a><a href="https://juejin.im/post/5a44aa4d518825146b10d69d" target="_blank" rel="noopener">标准模式/怪异模式对渲染页面的影响</a></h3><blockquote><h4 id="1-块级元素-盒子模型"><a href="#1-块级元素-盒子模型" class="headerlink" title="1.块级元素(盒子模型)"></a>1.块级元素(盒子模型)</h4><p>标准模式下，盒模型是<strong>标准盒模型</strong>，即width/height=content;</p><p>怪异模式下，盒模型是<strong>IE盒模型</strong>，即width/height=content+padding+border;</p><p><code>box-sizing:content-box(默认值)|border-box|inherit</code></p></blockquote><p><br></p><blockquote><h4 id="2-vertical-align"><a href="#2-vertical-align" class="headerlink" title="2.vertical-align"></a>2.vertical-align</h4><p>在标准模式下，display:inline|tablecell，属性verticle-aligh 默认取值是baseline,导致图片底部会有几像素留白;</p><p>当inline元素内只有图,并且处于怪异模式的时候,inline元素里的元素的vertical-aligh属性默认值是bottom,此时就不会有白条的效果;</p><p>了解更多<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener"><strong>vertical-aligh</strong> &gt;&gt;</a></p></blockquote><p><br></p><blockquote><h4 id="3-行内元素的尺寸"><a href="#3-行内元素的尺寸" class="headerlink" title="3.行内元素的尺寸"></a>3.行内元素的尺寸</h4><p>标准模式下,不能设置宽高的元素被称为non-replaced元素,例如span.</p><p>怪异模式下,即使是non-replaced元素也可以被设置元素的宽高.</p></blockquote><p>在标准模式下，行内元素分为replaced和non-replaced两类,replaced元素为可以设置宽高的行内元素，不能设置宽高的元素被称为non-replaced元素。replaced元素有 img、object、video 和表单元素(textarea、input)，某些元素只在一些特殊情况下表现为可替换元素，例如 audio 和 canvas 。</p><blockquote><p><strong>行内元素(display:inline)</strong>:margin、padding左右有效。设置高宽无效，高度取决于内部文字的行高。宽度取决于内部文字的多少。</p><p><strong>行内块级元素(diaplay:inline-block)</strong>:高宽边距有效，允许左右有其他元素;</p><p><strong>块级元素(display:block)</strong>:高宽边距有效，不允许左右有其他元素;</p><p>常见<strong>行内元素</strong>：br、a、span、button、i(斜体)、strike(中划线)、input、select、textarea、img…</p><p>常见<strong>块级元素</strong>：div、p、hr、h1~h6、ul、ol、form…</p><p>行内元素内嵌块元素:子元素决定height，父元素决定width;行内块元素内嵌块元素:子元素决定width、height;</p></blockquote><p><br></p><blockquote><h4 id="4-内部元素溢出处理"><a href="#4-内部元素溢出处理" class="headerlink" title="4.内部元素溢出处理"></a>4.内部元素溢出处理</h4><p>标准模式下,溢出的部分会超出盒子本身,在盒子外部继续显示.</p><p>怪异模式下,溢出的部分会扩展盒子本身,即外部盒子的大小不一定由css样式决定,会根据内部内容的大小自动调整.</p><p><strong>overflow: visible(默认) | hidden | scroll(auto) | inherit</strong></p></blockquote><p>了解更多<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow" target="_blank" rel="noopener"><strong>overflow属性</strong>&gt;&gt;</a></p><p><br></p><blockquote><h3 id="link-import"><a href="#link-import" class="headerlink" title="link? @import?"></a>link? @import?</h3></blockquote><p>同:都是外部引用CSS的方式</p><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:left">link</th><th style="text-align:left">@import</th></tr></thead><tbody><tr><td style="text-align:center">①</td><td style="text-align:left">XHTML标签,除了加载CSS外,还可以定义RSS等其他事务</td><td style="text-align:left">属于CSS范畴,只能加载CSS</td></tr><tr><td style="text-align:center">②</td><td style="text-align:left">引用CSS时,在页面载入时同时加载</td><td style="text-align:left">页面网页完全载入以后加载</td></tr><tr><td style="text-align:center">③</td><td style="text-align:left">XHTML标签,无兼容问题</td><td style="text-align:left">是在CSS2.1提出的,低版本的浏览器不支持</td></tr><tr><td style="text-align:center">④</td><td style="text-align:left">支持使用Javascript控制DOM去改变样式</td><td style="text-align:left">不支持</td></tr></tbody></table><p><br><br><br></p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><hr><blockquote><h3 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h3></blockquote><ul><li>新标签(header、nav、section、footer)、新属性(input type属性新值)</li><li>完全支持 CSS3</li><li>Video 和 Audio</li><li>2D/3D 制图(Canvas、SVG)</li><li>本地存储(localStorage、sessionStroage)</li><li>本地 SQL 数据(Web SQL)</li><li>Web 应用</li></ul><p><br></p><blockquote><h3 id="1-Canvas"><a href="#1-Canvas" class="headerlink" title="1.Canvas?"></a>1.<a href="http://www.runoob.com/html/html5-canvas.html" target="_blank" rel="noopener">Canvas?</a></h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial" target="_blank" rel="noopener">MDN canvas&gt;&gt;</a></li></ul></blockquote><p><br></p><blockquote><h3 id="2-内联SVG"><a href="#2-内联SVG" class="headerlink" title="2.内联SVG?"></a>2.<a href="http://www.runoob.com/html/html5-svg.html" target="_blank" rel="noopener">内联SVG?</a></h3><p>可缩放矢量图形，是万维网联盟的标准，使用XML格式定义用于网络的基于矢量的图形,图像在放大或改变尺寸的情况下质量都不会损失；</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial" target="_blank" rel="noopener">MDN SVG&gt;&gt;</a></p></blockquote><p><br></p><blockquote><h3 id="SVG优势-jpeg、gif、png"><a href="#SVG优势-jpeg、gif、png" class="headerlink" title="SVG优势(jpeg、gif、png)?"></a>SVG优势(jpeg、gif、png)?</h3></blockquote><ol><li>可通过文本编辑器创建和修改</li><li>可被搜索、索引、脚本化、压缩</li><li>可缩放</li><li>可在任何分辨率下被高质量打印</li><li>可在图像质量不下降的情况下被放大</li></ol><p><br></p><blockquote><h3 id="Canvas-与-SVG-区别"><a href="#Canvas-与-SVG-区别" class="headerlink" title="Canvas 与 SVG 区别?"></a>Canvas 与 SVG 区别?</h3></blockquote><ol><li><p>Canvas 通过 JavaScript 来绘制 2D 图形，Canvas 是逐 像素进行渲染的；在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注；如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p></li><li><p>SVG 是一种使用 XML 描述 2D 图形的语言；SVG 基于 XML，意味着 SVG DOM 中的每个元素都是可用的，可以为某个元素附加 JavaScript 事件处理器；在 SVG 中，每个被绘制的图形均被视为对象，如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p></li></ol><p><br></p><blockquote><h3 id="Canvas-与SVG-比较？"><a href="#Canvas-与SVG-比较？" class="headerlink" title="Canvas 与SVG 比较？"></a>Canvas 与SVG 比较？</h3></blockquote><table><thead><tr><th style="text-align:center">比较</th><th style="text-align:left">Canvas</th><th style="text-align:left">SVG</th></tr></thead><tbody><tr><td style="text-align:center">①</td><td style="text-align:left">依赖分辨率</td><td style="text-align:left">不依赖分辨率</td></tr><tr><td style="text-align:center">②</td><td style="text-align:left">不支持事件处理器</td><td style="text-align:left">支持事件处理器</td></tr><tr><td style="text-align:center">③</td><td style="text-align:left">弱的文本渲染能力</td><td style="text-align:left">最适合带有大型渲染区域的应用程序（比如谷歌地图）</td></tr><tr><td style="text-align:center">④</td><td style="text-align:left">能够以 .png 或 .jpg 格式保存结果图像</td><td style="text-align:left">复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快</td></tr><tr><td style="text-align:center">⑤</td><td style="text-align:left">最适合图像密集型的游戏，其中的许多对象会被频繁重绘</td><td style="text-align:left">不适合游戏应用</td></tr></tbody></table><p><br></p><blockquote><h3 id="3-MathML"><a href="#3-MathML" class="headerlink" title="3.MathML"></a>3.<a href="http://www.runoob.com/html/html5-mathml.html" target="_blank" rel="noopener">MathML</a></h3><p>数学标记语言，是一种基于XML的标准，用来在互联网上书写数学符号和公式的置标语言。</p></blockquote><p><br></p><blockquote><h3 id="4-Drag-和-Drop"><a href="#4-Drag-和-Drop" class="headerlink" title="4.Drag 和 Drop"></a>4.<a href="http://www.runoob.com/html/html5-draganddrop.html" target="_blank" rel="noopener">Drag 和 Drop</a></h3></blockquote><p><br></p><blockquote><h3 id="5-Geolocation-地理定位"><a href="#5-Geolocation-地理定位" class="headerlink" title="5.Geolocation(地理定位)"></a>5.<a href="http://www.runoob.com/html/html5-geolocation.html" target="_blank" rel="noopener">Geolocation(地理定位)</a></h3></blockquote><p><br></p><blockquote><h3 id="6-video、audio"><a href="#6-video、audio" class="headerlink" title="6.video、audio"></a>6.video、audio</h3><ul><li><a href="http://www.runoob.com/html/html5-video.html" target="_blank" rel="noopener">Video &gt;&gt;</a></li><li><a href="http://www.runoob.com/html/html5-audio.html" target="_blank" rel="noopener">Audio &gt;&gt;</a><br><br></li></ul></blockquote><blockquote><h3 id="8-input新类型"><a href="#8-input新类型" class="headerlink" title="8.input新类型"></a>8.<a href="http://www.runoob.com/html/html5-form-input-types.html" target="_blank" rel="noopener">input新类型</a></h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//html5前</span><br><span class="line">type:button|text|checkbox|password|radio|submit|reset|hidden|file|image|</span><br><span class="line">//html5新增加</span><br><span class="line">type:color|date|datetime|datetime-local|email|month|number|range|search|tel|time|url|week</span><br></pre></td></tr></table></figure><p><br></p><blockquote><h3 id="9-新的表单标签"><a href="#9-新的表单标签" class="headerlink" title="9.新的表单标签"></a>9.<a href="http://www.runoob.com/html/html5-form-elements.html" target="_blank" rel="noopener">新的表单标签</a></h3></blockquote><ul><li><strong>datalist</strong>:定义input 选项列表。定义 input 可能的值;</li><li><strong>keygen</strong>:用于表单的密钥对生成器字段;</li><li><strong>output</strong>:标签定义不同类型的输出，比如脚本的输出;</li></ul><p><br></p><blockquote><h3 id="10-新的表单属性"><a href="#10-新的表单属性" class="headerlink" title="10.新的表单属性"></a>10.<a href="http://www.runoob.com/html/html5-form-attributes.html" target="_blank" rel="noopener">新的表单属性</a></h3></blockquote><p><strong><code>&lt;form&gt;</code></strong></p><ul><li>autocomplete:on|off，是否拥有自动完成功能</li><li>novalidate:布尔值，不验证</li></ul><p><strong><code>&lt;input&gt;</code></strong></p><ul><li>autocomplete</li><li>autofocus:布尔值，在页面加载时，域自动地获得焦点。</li><li>form:formName设置输入域属于哪个表单</li><li>formaction</li><li>formenctype</li><li>formmethod</li><li>formnovalidate</li><li>formtarget</li><li>height 与 width</li><li>list</li><li>min 与 max</li><li>multiple</li><li>pattern (regexp)</li><li>placeholder</li><li>required</li><li>step</li></ul><p><br></p><blockquote><h3 id="11-新的语义化标签"><a href="#11-新的语义化标签" class="headerlink" title="11.新的语义化标签"></a>11.<a href="http://www.runoob.com/html/html5-semantic-elements.html" target="_blank" rel="noopener">新的语义化标签</a></h3></blockquote><ul><li>header</li><li>nav</li><li>section</li><li>article</li><li>aside</li><li>figcaption(非块元素)</li><li>figure</li><li>footer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//处理浏览器兼容问题</span><br><span class="line">header, section, footer, aside, nav, article, figure&#123; </span><br><span class="line">    display: block; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="12-Web存储-localStorage、sessionStorage"><a href="#12-Web存储-localStorage、sessionStorage" class="headerlink" title="12.Web存储(localStorage、sessionStorage)"></a>12.<a href="http://www.runoob.com/html/html5-webstorage.html" target="_blank" rel="noopener">Web存储(localStorage、sessionStorage)</a></h3></blockquote><p><strong>localStorage/sessionStorage API</strong></p><ul><li>setItem(key,value)</li><li>getItem(key)</li><li>removeItem(key)</li><li>Key(index)</li><li>clear()</li></ul><p><strong>使用场景:</strong></p><ul><li>利用本地数据，减少网络传输</li><li>弱网络环境下，高延迟，低带宽，尽量把数据本地化</li></ul><blockquote><h3 id="13-Web-SQL"><a href="#13-Web-SQL" class="headerlink" title="13. Web SQL"></a>13. <a href="http://www.runoob.com/html/html5-web-sql.html" target="_blank" rel="noopener">Web SQL</a></h3></blockquote><blockquote><h3 id="14-Application-Cache"><a href="#14-Application-Cache" class="headerlink" title="14.Application Cache"></a>14.<a href="http://www.runoob.com/html/html5-app-cache.html" target="_blank" rel="noopener">Application Cache</a></h3></blockquote><p><br><br><br></p><p><br></p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><hr><blockquote><h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3></blockquote><p><strong>content、padding、border、margin</strong><br>标准盒模型:</p><pre><code>content.width = content </code></pre><p>IE盒模型:</p><pre><code>content.width = content + padding + border </code></pre><p>切换盒模型：</p><pre><code>box-sizing:content-box | border-box;</code></pre><p><br></p><blockquote><h3 id="CSS定位-position"><a href="#CSS定位-position" class="headerlink" title="CSS定位(position)"></a>CSS定位(position)</h3></blockquote><table><thead><tr><th style="text-align:center">定位</th><th style="text-align:left">参考元素</th><th style="text-align:left">脱离文档流</th></tr></thead><tbody><tr><td style="text-align:center">相对定位relative</td><td style="text-align:left">自身</td><td style="text-align:left">不脱离文档流</td></tr><tr><td style="text-align:center">绝对定位absolute</td><td style="text-align:left">最近父元素非static</td><td style="text-align:left">脱离文档流</td></tr><tr><td style="text-align:center">固定定位fixed</td><td style="text-align:left">根元素html</td><td style="text-align:left">脱离文档流</td></tr></tbody></table><blockquote><h3 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h3></blockquote><ul><li>绝对单位： cm mm in pt pc</li><li>相对单位：<ul><li><strong>px</strong> ：不考虑分辨率，当做绝对单位对待</li><li>% ：</li><li><strong>em</strong> ：相对当前元素（首行缩进用text-indent：2em；）</li><li><strong>rem</strong> ：相对于根元素(常用于移动端)</li></ul></li><li>视窗单位：<ul><li>vh :视窗高度的百分比</li><li>vw</li><li>vmin ：vw vh中较小的一个</li><li>vmax ：vw vh中较大的一个</li></ul></li><li>% 相对于谁：<ul><li>以父元素容器 <strong>宽</strong> 为基准：padding、margin、width</li><li>以父元素容器 <strong>高</strong> 为基准：height 、定位元素</li><li>以自身：translate<br><br><br></li></ul></li></ul><blockquote><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3></blockquote><ul><li><p>行内元素</p><pre><code>父级 { text-align: center; }   </code></pre></li><li><p>块级元素</p><pre><code>当前元素 { margin: 0 auto ;}</code></pre></li><li><p>子元素浮动</p><pre><code>父级 {    width:fit-content;      margin:0 auto;}  </code></pre></li><li><p>定宽 + 绝对定位 + 负值</p><pre><code>子元素 {      left:50%;      margin-left:-0.5*宽度;  }   </code></pre></li><li><p>定宽 + 绝对定位</p><pre><code>子元素 {      left:0;      right:0;      margin:0 auto;  }</code></pre></li><li><p>flex 2012</p><pre><code>子元素 {      display:flex;      justify-content:center; }  </code></pre></li><li><p>绝对定位 + transform</p><pre><code>子元素 {      position:absolute;      left:50%;      transform:translate（-50% ,0）;  }  </code></pre></li></ul><p><br></p><blockquote><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3></blockquote><ul><li><p>单行文本</p><pre><code>当前元素 {       line-height:父级元素高度 ; }</code></pre></li><li><p>行内块级元素</p><pre><code>父级元素:after 当前元素{      display: inline-block;      vertical-align: middle;  }  </code></pre></li><li><p>元素高度不定</p><pre><code>父元素: {      display:table;  }  当前元素 {      display: table-cell;    vertical-align:middle;  }  //元素内容不会被截断 </code></pre></li><li><p>元素高度固定</p><pre><code>父级{      position:relative;  }  当前元素{      height:固定;      position:absolute;      top:50%;      margin-top:-0.5*高度；  }|{      height:固定;     position:absolute;       top:0;      bottom:0;      margin: auto 0;  }</code></pre></li><li><p>Flex 2012</p><pre><code>父级元素{      display:flex;      algin-items:center;  } </code></pre></li><li><p>transform</p><pre><code>父级{      position:relative;  }   当前元素{      position:absolute;      top:50%;      transform:translate(-50% , -50%);  }</code></pre></li></ul><p><br></p><blockquote><h3 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h3></blockquote><ul><li>伪类：效果可以通过添加<strong>实际类</strong>实现，只要不是互斥可以叠加使用，优先级与类相同</li><li>伪元素：效果可以通过添加<strong>实际元素</strong>来实现，在一个选择器中只能出现一次，且只能出现在末尾，优先级与标签相同</li><li>本质区别：是否抽象创造了新元素</li></ul><p>了解更多<a href="https://segmentfault.com/a/1190000000484493" target="_blank" rel="noopener">伪类和伪元素&gt;&gt;</a></p><p><br></p><blockquote><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li>clear:both,一定程度上消除块级元素浮动</li><li>BFC</li><li>overflow</li></ul></blockquote><ol><li><p>父级div定义 height</p><pre><code>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 建议：不推荐使用，只建议高度固定的布局时使用 </code></pre></li><li><p>结尾处加空div标签 clear:both</p><pre><code>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 优点：简单、代码少、浏览器支持好、不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 </code></pre></li><li><p>父级div定义 伪类:after 和 zoom</p><pre><code>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 建议：推荐使用，建议定义公共类，以减少CSS代码。</code></pre></li><li><p>父级div定义 overflow:hidden</p><pre><code>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 优点：简单、代码少、浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。 </code></pre></li><li><p>父级div定义 overflow:auto</p><pre><code>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 优点：简单、代码少、浏览器支持好 缺点：内部宽高超过父级div时，会出现滚动条。 建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。</code></pre></li></ol><p><br></p><blockquote><h3 id="CSS前缀"><a href="#CSS前缀" class="headerlink" title="CSS前缀"></a>CSS前缀</h3></blockquote><ul><li>-webkit- (谷歌, Safari, 新版Opera浏览器等)</li><li>-moz- (火狐浏览器)</li><li>-o- (旧版Opera浏览器等)</li><li>-ms- (IE浏览器 和 Edge浏览器)</li></ul><p>了解更多<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix" target="_blank" rel="noopener">Browser引擎前缀</a></p><p><br></p><blockquote><h3 id="CSS媒体查询"><a href="#CSS媒体查询" class="headerlink" title="CSS媒体查询"></a>CSS媒体查询</h3></blockquote><pre><code>@media </code></pre><p>了解更多<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" target="_blank" rel="noopener">CSS媒体查询</a></p><p><br></p><blockquote><h3 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h3></blockquote><ul><li>内联样式: 1000</li><li>ID: 100</li><li>类、属性、伪类:10</li><li>标签、伪元素: 1</li></ul><p><br></p><blockquote><h3 id="引入CSS样式及优先级"><a href="#引入CSS样式及优先级" class="headerlink" title="引入CSS样式及优先级"></a>引入CSS样式及优先级</h3></blockquote><pre><code>内联样式 &gt; 内部样式 &gt; 外部样式(link) &gt; 导入样式(@import)  </code></pre><p><br></p><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><hr><blockquote><h3 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h3></blockquote><ul><li>边框</li><li>背景</li><li>渐变</li><li>文本效果</li><li>字体</li><li>2D/3D转换</li><li>过渡</li><li>动画</li><li>多列</li><li>用户界面</li><li>分页</li><li>flex</li><li>@media</li></ul><p><br><br><br></p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><hr><blockquote><h3 id="JS定义"><a href="#JS定义" class="headerlink" title="JS定义"></a>JS定义</h3></blockquote><ul><li>JavaScript是一种弱类型、动态的、解释型的脚本语言</li><li>JavaScript是客户端和服务器端脚本语言</li><li>JavaScript也是面向对象编程语言</li></ul><p><br></p><blockquote><h3 id="JS组成"><a href="#JS组成" class="headerlink" title="JS组成"></a>JS组成</h3></blockquote><ol><li>ECMAScript</li><li>DOM:文档对象模型</li><li>BOM:浏览器对象模型</li></ol><p><br></p><blockquote><h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3></blockquote><ol><li>基本类型:string、number、boolean、nudefined、null</li><li>复杂数据类型（引用数据类型）：<a href="https://hotkang.cn/2018/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%BA%8C/#Object%E7%B1%BB%E5%9E%8B">Object</a> 、<a href="https://hotkang.cn/2018/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%80/#Function%E7%B1%BB%E5%9E%8B">Function</a> 、Array、Data、RegExp…</li><li>typeof:判断基本数据类型</li><li>Object.prototype.toString.call():判断对象属于哪种内置对象类型</li><li>instanceof:判断构造函数原型</li></ol><p><br></p><blockquote><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3></blockquote><ol><li><p>JavaScript是一种弱类型、动态的、解释型的脚本语言</p><pre><code>强/弱类型:类型检查 严格/不严格，偏向于 不容忍/容忍 隐式转换动态类型：运行的时候执行类型检查静态类型：编译的时候就知道每个变量的类型解释型：不需要编译，在运行的时候才翻译成机器语言，执行一次翻译一次，故效率低，跨平台性好；编译型：需编译为机器语言的文件，运行时直接使用编译的结果；标记语言：被动，不具备与访问者互动的能力；脚本语言：编程语言：</code></pre></li><li><p>js代码解析原则</p><pre><code>第一个步骤是解释，先通篇扫描所有的Js代码，然后把所有变量声明提升到该作用域顶端第二个步骤是执行</code></pre></li><li><p>函数提升在变量提升之上</p></li></ol><p><br></p><blockquote><h3 id="typeof返回哪些数据类型"><a href="#typeof返回哪些数据类型" class="headerlink" title="typeof返回哪些数据类型"></a>typeof返回哪些数据类型</h3></blockquote><ul><li>Object(null)</li><li>number</li><li>function</li><li>boolean</li><li>undefind</li></ul><p><br></p><blockquote><h3 id="3种强制类型转换"><a href="#3种强制类型转换" class="headerlink" title="3种强制类型转换"></a>3种强制类型转换</h3></blockquote><ul><li>parseInt</li><li>parseFloat</li><li>number</li></ul><p><br></p><blockquote><h3 id="2种隐式转换"><a href="#2种隐式转换" class="headerlink" title="2种隐式转换"></a>2种隐式转换</h3></blockquote><ul><li>==</li><li>===</li></ul><p><br></p><blockquote><h3 id="IE和DOM事件流的区别"><a href="#IE和DOM事件流的区别" class="headerlink" title="IE和DOM事件流的区别"></a>IE和DOM事件流的区别</h3></blockquote><ul><li>执行顺序不一样、</li><li>参数不一样</li><li>事件加不加on</li><li>this指向问题</li></ul><p><br></p><blockquote><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3></blockquote><ul><li><p>NULL</p><ul><li>null是一个表示”无”的对象，转为数值时为0;</li><li>null表示”没有对象”，即该处不应该有值;<ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul></li></ul></li><li><p>undefined</p><ul><li>undefined是一个表示”无”的原始值，转为数值时为NaN。</li><li><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</p><ul><li>变量被声明了，但没有赋值时，就等于undefined。</li></ul></li><li><p>调用函数时，应该提供的参数没有提供，该参数等于undefined。</p></li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ul></li></ul><p><br></p><blockquote><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>进入”严格模式”的标志，老版本的浏览器会把它当作一行普通字符串，加以忽略</p></blockquote><ul><li><p>引用</p><ul><li>将”use strict”放在<strong>脚本文件的第一行</strong>，则整个脚本都将以”严格模式”运行。</li><li><p>将”use strict”放在<strong>函数体的第一行</strong>，则整个函数以”严格模式”运行</p><p>因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将<strong>整个脚本文件放在一个立即执行的匿名函数之中</strong></p></li></ul></li><li><p>作用</p><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li></ul></li></ul><p><br></p><blockquote><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3></blockquote><ol><li>执行对象查找时，永远不会去查找原型</li><li>用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。</li><li>该方法属于Object对象，由于所有的对象都”继承”了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。</li></ol><p><br></p><blockquote><h3 id="时间格式化YYY-MM-DD"><a href="#时间格式化YYY-MM-DD" class="headerlink" title="时间格式化YYY-MM-DD"></a>时间格式化YYY-MM-DD</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">now: function () &#123;</span><br><span class="line">  var time = new Date(),</span><br><span class="line">      Y = time.getFullYear(),</span><br><span class="line">      M = time.getMonth()+1,   </span><br><span class="line">      D = time.getDate();</span><br><span class="line"></span><br><span class="line">      M = M &lt; 10? &apos;0&apos;+M : M;</span><br><span class="line">      D = D &lt; 10? &apos;0&apos;+D :D;</span><br><span class="line">  return Y +&apos;-&apos;+ M +&apos;-&apos;+ D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><h3 id="任意时间"><a href="#任意时间" class="headerlink" title="任意时间"></a>任意时间</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">date: function (Day) &#123;</span><br><span class="line">    var time = new Date();</span><br><span class="line">        time.setDate(time.getDate() + Day);</span><br><span class="line"></span><br><span class="line">    var Y = time.getFullYear(),</span><br><span class="line">        M = (time.getMonth()+1) &lt; 10 ? &quot;0&quot;+ (time.getMonth() + 1) : (time.getMonth() + 1),    </span><br><span class="line">        D = time.getDate() &lt; 10 ? &quot;0&quot; + time.getDate() : time.getDate();</span><br><span class="line"></span><br><span class="line">    return Y + &quot;-&quot; + M + &quot;-&quot; + D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3></blockquote><ol><li>可以访问其他函数内部作用域的函数,在有函数嵌套的情况下,子函数用到了父函数的参数或者局部变量.</li><li>作用：具有封闭性，保护变量；避免污染全局变量</li><li>缺点：内存泄漏</li></ol><p><br></p><blockquote><h3 id="call、apply、bind的区别"><a href="#call、apply、bind的区别" class="headerlink" title="call、apply、bind的区别"></a>call、apply、bind的区别</h3></blockquote><ol><li><h4 id="call、apply"><a href="#call、apply" class="headerlink" title="call、apply"></a>call、apply</h4><ul><li>改变函数体内部 this 的指向。</li><li>作用完全一样，接受参数的方式不太一样</li><li>call:把参数按顺序传递进去</li><li>apply:把参数放在数组里。　　</li></ul></li><li><h4 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h4><ul><li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li><li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li><li>apply 、 call 、bind 三者都可以利用后续参数传参；</li><li>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li></ul></li><li><p><a href="http://www.cnblogs.com/coco1s/p/4833199.html" target="_blank" rel="noopener">more&gt;&gt;</a></p></li></ol><p><br></p><blockquote><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3></blockquote><ol><li><p>对象的<strong>属性和方法</strong>，定义在<strong>自身</strong>或定义在<strong>它的原型对象上</strong>。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。</p></li><li><p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。而Object.prototype对象的原型就是没有任何属性和方法的null对象，而null对象没有自己的原型。</p></li><li><p>读取对象的某个属性时:</p><ul><li>JavaScript 引擎先寻找对象本身的属性</li><li>到它的原型去找,</li><li>到原型的原型去找。</li><li>直到最顶层的Object.prototype还是找不到?则返回undefined。</li></ul></li><li><p>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p></li><li><p>需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">more&gt;&gt;</a></p></li></ol><p><br><br><br></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><hr><blockquote><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var Arr = arr.filter(function(item, index, arr)&#123;</span><br><span class="line">        return arr.indexOf(item) === index;</span><br><span class="line">    &#125;);</span><br><span class="line">    return Arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 1, &apos;1&apos;, &apos;1&apos;];</span><br><span class="line">console.log(unique(arr));       // [1, &quot;1&quot;]</span><br></pre></td></tr></table></figure><p><br></p><blockquote><h3 id="ES6数组去重"><a href="#ES6数组去重" class="headerlink" title="ES6数组去重"></a>ES6数组去重</h3></blockquote><p>集合这个数据结构最大的特点就是，集合内部的元素都是唯一的，ES6标准给我们提供了Set集合，利用这个新的数据结构我们可以很容易的实现数组去重，容易到什么程度呢? 一行..就够了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;</span><br><span class="line">    return Array.from(new Set( arr ));</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 2, 1, 1, &apos;1&apos;];</span><br><span class="line">console.log(unique(arr));   // [1, 2,&quot;1&quot;]</span><br></pre></td></tr></table></figure><p></p><p>这才是真正的简单粗暴，将数组转为集合，抛弃多余数值 ，最后利用ES6的新数组方法Array.from将集合转为数组返回。<br>甚至可以再简化下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    return [...new Set(arr)];</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 2, 1, 1, &apos;1&apos;];</span><br><span class="line">console.log(unique(arr));   // [1, 2,&quot;1&quot;]</span><br></pre></td></tr></table></figure><p></p><p>还可以再简化下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var unique = (arr) =&gt; [...new Set(arr)]</span><br><span class="line">var arr = [1, 2, 1, 1, &apos;1&apos;];</span><br><span class="line">console.log(unique(arr));   // [1, 2,&quot;1&quot;]</span><br></pre></td></tr></table></figure><p></p><p><br><br><br></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><hr><blockquote><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a><a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">状态码</a></h3></blockquote><blockquote><h3 id="http头"><a href="#http头" class="headerlink" title="http头"></a><a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">http头</a></h3></blockquote><p><br><br><br></p><h2 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h2><hr><blockquote><h3 id="浏览器分层"><a href="#浏览器分层" class="headerlink" title="浏览器分层"></a>浏览器分层</h3></blockquote><ul><li>结构层:HTML,实现页面结构</li><li>表示层:CSS,完成页面的表现与风格</li><li>行为层:JavaScript,实现一些客户端的功能与业务</li></ul><p><br></p><blockquote><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3></blockquote><p><br></p><blockquote><h3 id="HTML5-存储"><a href="#HTML5-存储" class="headerlink" title="HTML5 存储"></a>HTML5 存储</h3></blockquote><p><strong>关于存储</strong></p><ul><li>cache</li><li>磁盘文件</li><li>数据库</li><li>内存(频繁使用的数据)</li></ul><p><strong>本地存储可以存什么？</strong></p><ul><li>数组(序列号为字符串)</li><li>json数据</li><li>图片</li><li>脚本(ajax)</li><li>样式文件(ajax)</li></ul><p><strong>html5前如何实现存储？</strong></p><ul><li>cookies?http请求头携带、4k、主domain污染、安全问题(购物车、身份验证)</li><li>userdata?只有IE支持，存放XML文件</li></ul><p><strong>html5存储目标？</strong></p><ul><li>解决4k？</li><li>解决请求头常带存储信息，不安全，请越来越慢</li><li>解决关系型存储的问题</li><li>跨浏览器</li></ul><p><strong>html5常见存储方式？</strong></p><ul><li>本地存储(localStroage、sessionStroage)</li><li>离线缓存（application cache）?</li><li>客户端数据库（indexedDB、Web SQL）？</li></ul><p><strong>html5 存储实例？</strong></p><ul><li>如何把图片存在客户端？</li><li>如何实现跨域共享客户端缓存？</li><li>如何离线访问web应用</li><li>如何实现一个客户端的数据库？</li></ul><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">生命周期</th><th style="text-align:center">存储数据大小</th><th style="text-align:center">与服务端通信</th></tr></thead><tbody><tr><td style="text-align:center">cookie</td><td style="text-align:center">一般由服务器生成，可以设置过期时间</td><td style="text-align:center">4k</td><td style="text-align:center">每次都携带在header中，影响请求性能</td></tr><tr><td style="text-align:center">localStroage</td><td style="text-align:center">除非被清理，一直存在</td><td style="text-align:center">5M</td><td style="text-align:center">不参与</td></tr><tr><td style="text-align:center">sessionStroage</td><td style="text-align:center">页面关门就清理</td><td style="text-align:center">5M</td><td style="text-align:center">不参与</td></tr><tr><td style="text-align:center">indexedDB</td><td style="text-align:center">除非被清理，一直存在</td><td style="text-align:center">5M</td><td style="text-align:center">不参与</td></tr></tbody></table><blockquote><h3 id="cookies-sessionStorage-localStorage"><a href="#cookies-sessionStorage-localStorage" class="headerlink" title="cookies? sessionStorage? localStorage?"></a>cookies? sessionStorage? localStorage?</h3><ul><li><p>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</p></li><li><p>sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据。其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据,也就是说只要这个浏览器窗口没有关闭,即使刷新页面或进入同源另一页面,数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的。</p></li><li><p>cookies会发送到服务器端。其余两个不会。</p></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/07/html5-indexeddb-js-example/" target="_blank" rel="noopener">indexedDB</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="noopener">应用程序缓存</a></li></ul></blockquote><p><br><br><br></p><blockquote><h3 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h3></blockquote><p><br><br><br></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><hr><ul><li><a href="https://hotkang.cn/2018/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B%E6%9D%A5%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">从浏览器请求和响应过程来谈性能优化</a></li><li><a href="https://hotkang.cn/2018/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%9714%E6%9D%A1%E8%A7%84%E5%88%99/">高性能网站建设指南14条规则</a></li></ul><p><br><br><br></p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><hr><blockquote><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3></blockquote><blockquote><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3></blockquote><p><br><br><br></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><hr><ul><li><a href="https://blog.csdn.net/cc1949/article/details/79063439" target="_blank" rel="noopener">OSI七层模型</a></li></ul><p><br><br><br></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><hr><p><br><br><br></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><hr><blockquote><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3></blockquote><ul><li><p><a href="https://juejin.im/post/57dcd394a22b9d00610c5ec8" target="_blank" rel="noopener">十大经典排序算法总结（JavaScript描述）</a></p></li><li><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></p></li></ul><p><br><br><br></p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><hr><p><br><br><br></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr><blockquote><h3 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL??"></a>WebGL??</h3><p>WebGL（Web Graphics Library ）是一种 3D 绘图标准。</p></blockquote><p>允许把 JavaScript 和 OpenGL ES 2.0 结合在一起,通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定,WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染,这样 Web 开发人员就可以借助系统显卡在浏览器里更流畅地展示 3D 场景和模型,还能创建复杂的导航和数据视觉化。</p><p>显然,WebGL 技术标准免去了开发网页专用渲染插件的麻烦,可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。WebGL完美地解决了现有的 Web 交互式三维动画的两个问题：①它通过HTML脚本本身实现 Web 交互式三维动画的制作，无需任何浏览器插件支持 ;②它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;笔记大全-持续完善&quot;&gt;&lt;a href=&quot;#笔记大全-持续完善&quot; class=&quot;headerlink&quot; title=&quot;笔记大全 [持续完善]&quot;&gt;&lt;/a&gt;笔记大全 &lt;span style=&quot;font-size:.5em&quot;&gt;[持续完善]&lt;/span&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="CSS" scheme="https://hotkang.cn/tags/CSS/"/>
    
      <category term="Notes" scheme="https://hotkang.cn/tags/Notes/"/>
    
      <category term="JS" scheme="https://hotkang.cn/tags/JS/"/>
    
      <category term="HTML" scheme="https://hotkang.cn/tags/HTML/"/>
    
      <category term="HTTP" scheme="https://hotkang.cn/tags/HTTP/"/>
    
      <category term="面试" scheme="https://hotkang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JS数据类型</title>
    <link href="https://hotkang.cn/2018/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://hotkang.cn/2018/JS数据类型/</id>
    <published>2018-08-28T03:06:55.000Z</published>
    <updated>2018-11-30T14:42:27.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览-完结"><a href="#概览-完结" class="headerlink" title="概览[完结]"></a>概览<span style="font-size:.5em">[完结]</span></h2><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>Object类型</li><li>Array类型</li><li>Date类型</li><li>RegExp类型</li><li>Function类型</li><li>基本包装类型</li><li>单体内置对象</li></ul><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>JavaScript高级程序设计</p></blockquote><p><br><br><br></p><h2 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><hr><h3 id="一、typeof操作符"><a href="#一、typeof操作符" class="headerlink" title="一、typeof操作符"></a>一、typeof操作符</h3><p>检测给定变量的数据类型，将返回下列某个字符串：</p><ul><li><code>&quot;undefined&quot;</code> ____值未定义</li><li><code>&quot;boolean&quot;</code> ____布尔值</li><li><code>&quot;string&quot;</code> ____字符串</li><li><code>&quot;number&quot;</code> ____数值</li><li><code>&quot;object&quot;</code> ____对象|null</li><li><code>&quot;function&quot;</code> ____函数</li></ul><p>typeof操作符可以是变量，也可以是数组字面量。typeof不是一个函数，圆括号不是必需的。例：</p><pre><code>var message = &quot;some string&quot;;console.log(typeof(message));   //stringconsole.log(typeof message);    //stringconsole.log(typeof 95);         //number</code></pre><p><br></p><h3 id="二、undefined类型"><a href="#二、undefined类型" class="headerlink" title="二、undefined类型"></a>二、undefined类型</h3><p>变量只声明未定义时，值为undefined。</p><pre><code>var message;//  var age;//  console.log(age);            //报错console.log(message);           // undefinedconsole.log(typeof message);    //undefinedconsole.log(typeof age);        //undefined</code></pre><p><br></p><h3 id="三、null类型"><a href="#三、null类型" class="headerlink" title="三、null类型"></a>三、null类型</h3><p>逻辑角度，null值表示一个空对象指针，所以typeof检测null值时返回object。保存对象的变量还没有真正的保存对象时，就应该明确的让该变量保存null值。</p><p><br></p><h3 id="四、Boolean类型"><a href="#四、Boolean类型" class="headerlink" title="四、Boolean类型"></a>四、Boolean类型</h3><p>两个字面量：<code>true</code>、<code>false</code>；与数字值不是一回事，true不一定等于1，false不一定等于0；且区分大小写。</p><blockquote><p>Boolean()：将一个值转换为对应的Boolean值</p></blockquote><p>转换规则对理解流控语句【if语句、while语句等】自动执行相应的Boolean转换非常重要。</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:left">转换为true值</th><th style="text-align:left">转换为false值</th></tr></thead><tbody><tr><td style="text-align:center">Boolean</td><td style="text-align:left">true</td><td style="text-align:left">false</td></tr><tr><td style="text-align:center">String</td><td style="text-align:left">任何非空字符串</td><td style="text-align:left">“”(空字符串)</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:left">任何非0数字值(包括无穷大)</td><td style="text-align:left">0、NaN</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:left">任何对象</td><td style="text-align:left">null</td></tr><tr><td style="text-align:center">undefined</td><td style="text-align:left">N/A</td><td style="text-align:left">undefined</td></tr></tbody></table><p><br></p><h3 id="五、Number类型"><a href="#五、Number类型" class="headerlink" title="五、Number类型"></a>五、Number类型</h3><blockquote><p>数值范围[ -Infinity, Infinity ]</p></blockquote><p>想要确定一个数值是不是有穷，即是不是位于最小和最大之间，可以使用<code>isFinite()</code>函数:</p><pre><code>var result = Number.MAX_VALUE + Number.MIN_VALUE;console.log(isFinite(result));          //true</code></pre><p><br></p><blockquote><p>NaN:非数值（Not a Number）</p></blockquote><p>用于表示一个本来要返回数值的操作数未返回数值的情况（这样不会抛出错误）。</p><p>两个特点：</p><ol><li><p>任何涉及NaN的操作（NaN/10、10/NaN）都会返回NaN；在其他编程语言，任何数值除以非数值都会导致错误。</p></li><li><p>NaN与任何值都不相等，包括NaN本身。</p></li></ol><p><code>isNaN()</code>:接收一个任何类型的参数，判断参数是否“不是数值”；会尝试将参数转换为数值，将不是数值的值直接转换为数值，任何不能被转换为数值的值都会返回true；</p><pre><code>console.log(isNaN(NaN));    //trueconsole.log(isNaN(10));     //false_10是数值console.log(isNaN(&apos;10&apos;));   //false_可以转换成数值10console.log(isNaN(&quot;blue&quot;)); //true_不能转换成数值console.log(isNaN(true));   //false_可以被转换成数值1</code></pre><p><br></p><blockquote><p>数值转换:非数值转换成数值</p></blockquote><p><code>Number()</code>用于任何数据类型；<code>parseInt()</code>和<code>parseFloat()</code>专门用于把字符串转换成数组；同样的输入会有不同的结果。</p><p>Number()转换规则：</p><ul><li><p>数值，简单传入返回;</p></li><li><p>Boolean值，true-&gt;1,false-&gt;0;</p></li><li><p>null-&gt;返回0;</p></li><li><p>undefined-&gt;返回NaN;</p></li><li><p>string，遵循规则如下：</p><ul><li><p>只包含数字-&gt;转换为十进制数值，’1’-&gt;1,’01’-&gt;1;</p></li><li><p>包含有效浮点格式-&gt;对应的浮点数值（前导0被忽略）；</p></li><li><p>包含有效十六进制格式-&gt;转换为相同大小的十进制整数值；</p></li><li><p>字符串为空-&gt;0;</p></li><li><p>包含上述格式之外的字符-&gt;NaN.</p></li></ul></li><li><p>对象，调用valueOf(),依照上面规则转换返回的值；若未NaN，则调用toString(),依照前面规则转换返回的字符串值。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number(&quot;hello world&quot;));     //NaN_不包含任何有意义的数值</span><br><span class="line">console.log(Number(&quot;&quot;));                //0 _空字符串</span><br><span class="line">console.log(Number(&quot;000011&quot;));          //11_忽略前导0</span><br><span class="line">console.log(Number(true));              //1</span><br></pre></td></tr></table></figure><p><br></p><p><code>parseInt()</code>:忽略字符串前面的空格，直至找到第一个非空字符。如果第一个字符不是数字或者负号，返回NaN；因此，parseInt()转换空字符串返回NaN（<code>Number()</code>对空字符串返回0）。提供第二个参数：转换时使用的基数。</p><pre><code>console.log(parseInt(&quot;10&quot;,2));  //2  按二进制解析console.log(parseInt(&quot;10&quot;,8));  //8  按八进制解析console.log(parseInt(&quot;10&quot;,10)); //10  按十进制解析console.log(parseInt(&quot;10&quot;,16)); //16  按十六进制解析</code></pre><p><br></p><p><code>parseFloat()</code>:忽略前导0，解析直至遇到一个无效的浮点数字字符为止；①只有第一个小数点有效，第二个小数点无效；②十六进制格式字符串始终会被转换成0；③若字符串包含一个可解析的整数（没有小数点，或者小数点后都是0)，返回整数：</p><pre><code>console.log(parseFloat(&quot;22.34.5&quot;));     //22.34 console.log(parseFloat(&quot;0908.5&quot;));      //908.5console.log(parseFloat(&quot;0xA&quot;));         //0   console.log(parseFloat(&quot;1234bule&quot;));    //1234  console.log(parseFloat(&quot;1234.000&quot;));    //1234  console.log(parseFloat(&quot;22.5&quot;));        //22.5  console.log(parseFloat(&quot;3.215e7&quot;));     //32150000 </code></pre><p><br></p><h3 id="六、String类型"><a href="#六、String类型" class="headerlink" title="六、String类型"></a>六、String类型</h3><p>string类型包含一些特殊的字符字面量-转义序列；用于表示非打印字符或其他用途；字符串一旦创建值是不可变得，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值得字符串填充该变量；</p><blockquote><p>转换为字符串</p></blockquote><p>把一个数字转为一个字符串有两种方式。①<code>toString()</code>:返回相应值得字符串表现;数值、布尔值、对象、字符都有toString()方法并返回字符串的一个副本，但null和undefined没有toString()方法。</p><pre><code>console.log((11).toString());   //字符串&quot;11&quot;console.log((true).toString());   //字符串&quot;true&quot;</code></pre><p>多数情况下，不用传参，但在调用数值的toString()方法时，可以传递一个参数：输出数值的基数；</p><pre><code>console.log((11).toString());   //十进制字符串&quot;11&quot;console.log((11).toString(8));   //八进制字符串&quot;13&quot;console.log((11).toString(16));   //十六进制字符串&quot;b&quot;</code></pre><p>②<code>String()</code>:在不知道要转换的值是null或者undefined的情况下可以使用，能将任何类型的值转换为字符串；</p><ol><li>值有toString()方法，调用该方法并返回相应结果；</li><li>null，返回”null”;</li><li>undefined,返回”undefined”;</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(String(11));        //字符串&quot;11&quot;</span><br><span class="line">console.log(String(true));      //字符串&quot;true&quot;</span><br><span class="line">console.log(String(null));      //字符串&quot;null&quot;</span><br><span class="line">console.log(String(undefined)); //字符串&quot;undefined&quot;</span><br></pre></td></tr></table></figure><p><a href="http://www.w3school.com.cn/jsref/jsref_obj_string.asp" target="_blank" rel="noopener">more&gt;&gt;</a></p><p><br><br><br></p><h2 id="引用类型-1"><a href="#引用类型-1" class="headerlink" title="引用类型"></a>引用类型</h2><hr><h3 id="一、Object类型"><a href="#一、Object类型" class="headerlink" title="一、Object类型"></a>一、Object类型</h3><p><a href="https://hotkang.cn/2018/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%BA%8C/#Object%E7%B1%BB%E5%9E%8B">more&gt;&gt;</a></p><p><br></p><h3 id="二、-Array类型"><a href="#二、-Array类型" class="headerlink" title="二、 Array类型"></a>二、 Array类型</h3><h4 id="①创建"><a href="#①创建" class="headerlink" title="①创建"></a>①创建</h4><blockquote><p>Arrary构造函数</p></blockquote><pre><code>var hotyan = new Array(3);    //创建一个包含3项的数值var hotyan = new Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);    //创建一个包含三个字符串的数值var hotyan = Array(3);      //可以省略new操作符var hotyan = Array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);    </code></pre><p><br></p><blockquote><p>数组字面量表示法</p></blockquote><pre><code>var hotyan = []; //创建一个空数组var hotyan = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]; //创建一个包含三个字符串的数组</code></pre><p><br></p><blockquote><p>length属性</p></blockquote><p>不是只读，可以从数组的末尾移除项或向数组添加新项；将length的属性设置为小于数组项数的值，被移除的项显示为undefined；反之，新增的项也是undefined；由于数组最后一项的索引始终是length-1，因此下一个新项的位置就是length：</p><pre><code>var colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];    //创建一个包含3个字符串的数组colors[colors.length] = &apos;black&apos;;    //在数组最后，即位置4添加新项</code></pre><p><br></p><h4 id="②检测"><a href="#②检测" class="headerlink" title="②检测"></a>②检测</h4><blockquote><p>instanceof</p></blockquote><blockquote><p>Array.isArray()</p></blockquote><p><br></p><h4 id="③转换方法"><a href="#③转换方法" class="headerlink" title="③转换方法"></a>③转换方法</h4><blockquote><p>valueOf():返回数组本身</p></blockquote><blockquote><p>toString():返回以”,“隔开，每个值字符串形式拼接而成的字符串</p></blockquote><blockquote><p>toLocalString()：</p></blockquote><blockquote><p>join()：使用不同的分隔符，返回包含所有数组项的字符串</p></blockquote><p><br></p><h4 id="④栈方法"><a href="#④栈方法" class="headerlink" title="④栈方法"></a>④栈方法</h4><blockquote><p>push()：接收任意数量参数，逐个添加到数组末尾，返回修改后 <strong>数组长度</strong>。</p><p>pop()：移除数组末尾最后一项，减少数组的length值，返回 <strong>移除的项</strong>。</p></blockquote><p><br></p><h4 id="⑤队列方法"><a href="#⑤队列方法" class="headerlink" title="⑤队列方法"></a>⑤队列方法</h4><blockquote><p>push()：向数组末端添加项，返回修改后 <strong>数组长度</strong></p></blockquote><p>例：在数组 arr 中，查找值与 item 相等的元素出现的所有位置</p><pre><code>function findAllOccurrences(arr, target) {    var Arr =[];    for(var i = 0;i&lt;arr.length;i++)        if(arr[i]==target)            Arr.push(i);    console.log(Arr);    return Arr;}findAllOccurrences(&apos;abcdefabc&apos;,&apos;a&apos;);   // [0, 6]</code></pre><p><br></p><blockquote><p>pop()：移除数组末端项并返回 <strong>被删除的项</strong></p></blockquote><blockquote><p>shift()：移除数组第一项并返回 <strong>该项</strong>，数组长度减1</p></blockquote><p><br></p><blockquote><p>unshift()：在数组前端添加任意个项并返回 <strong>新数组长度</strong></p></blockquote><p>例：在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组：</p><pre><code>function prepend(arr, item) {    var Arr = arr.concat();     //复制一个新数组    Arr.unshift(item);      //开头添加一位后返回    return Arr;  }prepend([1,2,3,4],10);      //[10,1,2,3,4]</code></pre><p><br></p><h4 id="⑥重排序方法"><a href="#⑥重排序方法" class="headerlink" title="⑥重排序方法"></a>⑥重排序方法</h4><blockquote><p>reverse()：反转数组</p></blockquote><pre><code>var arr = [1,2,3,4,5];arr.reverse();alert(arr);     //[5，4，3，2，1]</code></pre><p><br></p><blockquote><p>sort()：默认升序，调用toString()方法，比较的是 <strong>字符串</strong></p></blockquote><pre><code>var arr = [0,1,5,10,15];arr.sort();alert(arr);     //0,1,10,15,5_不正确</code></pre><p><br></p><blockquote><p>compare()：比较函数</p></blockquote><pre><code>function compare(a,b){    if(a &lt; b){        return -1;    }       else if(a &gt; b){        return 1;    }         else{        return 0;    }      }var arr = [0,1,5,10,15];arr.sort(compare);alert(arr);     //0,1,5,10,15_正确</code></pre><p><br></p><blockquote><p>valueOf()：数组类型或返回数组类型的对象类型</p></blockquote><pre><code>function compare(a,b){    return b-a;}</code></pre><p><br></p><h4 id="⑦操作方法"><a href="#⑦操作方法" class="headerlink" title="⑦操作方法"></a>⑦操作方法</h4><blockquote><p>concat()：基于当前数组的所有项创建一个新数组</p></blockquote><p>先创建当前数组的一个副本，将接收到的参数添加到这个副本末尾。没有参数即复制当前数组内容并返回副本，传递的参数可以不是数组、一个或多个数组。</p><pre><code>var a = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;];var b = a.concat(&quot;a&quot;,[&quot;b&quot;,&quot;c&quot;]);alert(a);       //A,B,C,Dalert(b);       //A,B,C,D,a,b,c</code></pre><p>例：在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组</p><pre><code>function append(arr, item) {    return arr.concat(item);}append([1,2,3,4],10);//[1, 2, 3, 4, 10]</code></pre><p>例：合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组：</p><pre><code>function concat(arr1, arr2) {    return arr1.concat(arr2);}</code></pre><p><br></p><blockquote><p>slice(起始位置，结束位置)：基于当前数组中的一或多个项创建一个新数组</p></blockquote><p>可以接收两个参数（要返回项的起始位置，结束位置）；</p><ul><li>一个参数时：返回该参数指定位置到当前数组末尾的所有项；</li><li>两个参数时：返回起始位置和结束位置（不包括结束位置）之间的项。</li><li>若参数为负，用数组长度加上该数来确定相应的位置；</li><li>若结束位置小于起始位置，返回空数组。</li></ul><p>例：删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组：</p><pre><code>function truncate(arr) {    return arr.slice(0,(arr.length)-1);}truncate([1,2,3,4]);    //[1, 2, 3]</code></pre><p>例：删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组</p><pre><code>function curtail(arr) {    return arr.slice(1);//返回除第一个的新数组}</code></pre><p><br></p><blockquote><p>splice()：主要用途是向数组的中部插入项</p></blockquote><ul><li>删除：删除任意数量的项，接收两个参数（要删除的第一项的位置，删除项数）</li><li>插入：向指定位置插入任意数量的项，需提供三个参数（起始位置，0：要删除的项数，要插入的项）</li><li>替换：向指定位置插入任意数量的项，且同时删除任意数量的项，三个参数（起始位置，要删除的项数，要插入的任意数量的项）</li></ul><p>例：在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组：</p><pre><code>function insert(arr, item, index) {    var Arr = arr.concat();    Arr.splice(index-1,0,item);    console.log(Arr);    return Arr;}insert([1,2,3,4],&apos;z&apos;,2);    //</code></pre><p><br></p><h4 id="⑧位置方法"><a href="#⑧位置方法" class="headerlink" title="⑧位置方法"></a>⑧位置方法</h4><p>都接收两个参数【要查找的项,（可选）查找起点位置的索引】；都返回要查找的项在数组中的<strong>位置</strong>，没有找到的情况下返回-1；</p><blockquote><p><code>indexOf()</code>：从数组的开头（位置0）开始向后查找。返回位置。</p></blockquote><p>例：找出元素 item 在给定数组 arr 中的位置,如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1：</p><pre><code>function indexOf(arr, item) {    return arr.indexOf(item);}indexOf([1,2,3,4],3);   //2</code></pre><p>例：找出数组 arr 中重复出现过的元素</p><pre><code>function duplicates(arr) {    var Arr = [];    for(var i = 0;i&lt;arr.length;i++)        for(var j = i+1;j&lt;arr.length;j++)            if((arr[i]==arr[j])&amp;&amp;(Arr.indexOf(i)==-1))                Arr.push(arr[i]);          return Arr.sort();}duplicates([1, 2, 4, 4, 3, 3, 1, 5, 3]);  //[ 1, 3, 4 ]</code></pre><blockquote><p><code>lastIndexOf()</code>：从数组的末尾开始向前查找。</p></blockquote><p><br></p><h4 id="⑨迭代方法"><a href="#⑨迭代方法" class="headerlink" title="⑨迭代方法"></a>⑨迭代方法</h4><p>最相似的是every()和some()，都用于查询数组中的项是否满足某个条件；filter()用于查询满足某个条件的所有数组项；map()用于创建包含项与另一个数组一一对应的数组；forEach()本质上与for循环迭代数组一样。均不影响原数组。</p><blockquote><p><code>every()</code>：对数组中每一项运行给定函数，函数对每一项都为true时 <strong>返回true</strong></p></blockquote><blockquote><p><code>some()</code>：对数组中每一项运行给定函数，函数对任一项为true时 <strong>返回true</strong></p></blockquote><blockquote><p><code>filter()</code> ：对数组中每一项运行给定函数，返回<strong>函数会返回true的项组成的数组</strong></p></blockquote><p>例如：移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组</p><pre><code>function remove(arr, item) {    return arr.filter(function(items,index,arr){        return (items!=item);    });}remove([1,2,3,4,2],2);      //[1,3,4]</code></pre><p>例如：移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回：</p><pre><code>function removeWithoutCopy(arr, item) {    for(var i = 0;i &lt; arr.length;i++){        if(arr[i] == item){            arr.splice(i,1);            i--;        }    }    return arr;}removeWithoutCopy([1,2,2,3,4,2,2],2);//</code></pre><p><br></p><blockquote><p><code>forEach()</code> ：对数组中每一项运行给定函数，没有返回值</p></blockquote><p>例：统计数组 arr 中值等于 item 的元素出现的次数</p><pre><code>function count(arr, item) {    var count = 0;    arr.forEach(function(items,index,arr){        if(items == item)            count+=1;    });    console.log(count);    return count;}count([1,2,4,4,3,4,3],4);//3</code></pre><p><br></p><blockquote><p><code>map()</code> ：对数组中每一项运行给定函数，返回<strong>每次函数调用的结果组成的数组</strong></p></blockquote><p>例：为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组</p><pre><code>function square(arr) {    return arr.map(function(item,index,arr){        return item*item;      });}square([1, 2, 3, 4]);//[1, 4, 9, 16]</code></pre><p><br></p><h4 id="10-归并方法"><a href="#10-归并方法" class="headerlink" title="10.归并方法"></a>10.归并方法</h4><p>都会迭代数组的每一项，构建一个最终返回的值；用于求数组中的所有值之和；方法都接收两个参数（在每一项上调用的函数，可选的作为归并基础的初始值）；传给reduce()和reduceRight()的函数接收4个参数（前一个值，当前值，项的索引，数组对象）。</p><blockquote><p><code>reduce()</code>：从第一项开始遍历</p></blockquote><p>例如：计算给定数组 arr 中所有元素的总和：</p><pre><code>function sum(arr) {    return arr.reduce(function(prev,cur,index,arr){        return prev+cur;    });}sum([1,2,3,4]);</code></pre><p><br></p><blockquote><p><code>reduceRight()</code>：从最后一项开始遍历</p></blockquote><p><br><br><br></p><h3 id="三、-Date类型"><a href="#三、-Date类型" class="headerlink" title="三、 Date类型"></a>三、 Date类型</h3><p><a href="https://hotkang.cn/2018/Effects/">more&gt;&gt;</a></p><p><br></p><h3 id="四、-RegExp类型"><a href="#四、-RegExp类型" class="headerlink" title="四、 RegExp类型"></a>四、 RegExp类型</h3><h4 id="1-创建正则表达式"><a href="#1-创建正则表达式" class="headerlink" title="1. 创建正则表达式"></a>1. 创建正则表达式</h4><blockquote><p>正则表达式字面量</p></blockquote><pre><code>/*    /pattern/flags*/    const regex = /ab+c/;    const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;</code></pre><blockquote><p>调用RegExp对象的构造函数</p></blockquote><pre><code>/*     new RegExp(pattern [, flags])*/let regex = new RegExp(&quot;ab+c&quot;);let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, &quot;gi&quot;);let regex = new RegExp(&quot;^[a-zA-Z]+[0-9]*\\W?_$&quot;, &quot;gi&quot;);</code></pre><p><br></p><h3 id="五、-Function类型"><a href="#五、-Function类型" class="headerlink" title="五、 Function类型"></a>五、 Function类型</h3><p><a href="https://hotkang.cn/2018/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%80/#Function%E7%B1%BB%E5%9E%8B">more&gt;&gt;</a></p><p><br></p><h3 id="六、基本包装类型"><a href="#六、基本包装类型" class="headerlink" title="六、基本包装类型"></a>六、基本包装类型</h3><h4 id="1-Boolean类型-建议永远不要使用"><a href="#1-Boolean类型-建议永远不要使用" class="headerlink" title="1.Boolean类型(建议永远不要使用)"></a>1.Boolean类型(建议永远不要使用)</h4><h4 id="2-Number类型"><a href="#2-Number类型" class="headerlink" title="2.Number类型"></a>2.Number类型</h4><blockquote><p>toFixed()</p></blockquote><blockquote><p>toExponential()</p></blockquote><blockquote><p>toPrecision()</p></blockquote><p><br></p><h4 id="3-String类型"><a href="#3-String类型" class="headerlink" title="3.String类型"></a>3.String类型</h4><blockquote><p>字符方法</p></blockquote><blockquote><p>字符串操作方法</p></blockquote><blockquote><p>字符串位置方法</p></blockquote><blockquote><p>trim()方法</p></blockquote><blockquote><p>字符串大小写转换方法</p></blockquote><blockquote><p>字符串的模式匹配方法</p></blockquote><blockquote><p>localCompare()方法</p></blockquote><blockquote><p>formCharCode()方法</p></blockquote><blockquote><p>HTML方法</p></blockquote><p><br></p><h3 id="七、单体内置对象"><a href="#七、单体内置对象" class="headerlink" title="七、单体内置对象"></a>七、单体内置对象</h3><h4 id="1-Global对象"><a href="#1-Global对象" class="headerlink" title="1.Global对象"></a>1.Global对象</h4><p><br></p><h4 id="2-Math对象"><a href="#2-Math对象" class="headerlink" title="2.Math对象"></a>2.Math对象</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览-完结&quot;&gt;&lt;a href=&quot;#概览-完结&quot; class=&quot;headerlink&quot; title=&quot;概览[完结]&quot;&gt;&lt;/a&gt;概览&lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;h4 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;Undefined&lt;/li&gt;&lt;li&gt;Null&lt;/li&gt;&lt;li&gt;Boolean&lt;/li&gt;&lt;li&gt;Number&lt;/li&gt;&lt;li&gt;String&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;引用类型&quot;&gt;&lt;a href=&quot;#引用类型&quot; class=&quot;headerlink&quot; title=&quot;引用类型&quot;&gt;&lt;/a&gt;引用类型&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;Object类型&lt;/li&gt;&lt;li&gt;Array类型&lt;/li&gt;&lt;li&gt;Date类型&lt;/li&gt;&lt;li&gt;RegExp类型&lt;/li&gt;&lt;li&gt;Function类型&lt;/li&gt;&lt;li&gt;基本包装类型&lt;/li&gt;&lt;li&gt;单体内置对象&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="Notes" scheme="https://hotkang.cn/tags/Notes/"/>
    
      <category term="JS" scheme="https://hotkang.cn/tags/JS/"/>
    
      <category term="数据类型" scheme="https://hotkang.cn/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Effects</title>
    <link href="https://hotkang.cn/2018/Effects/"/>
    <id>https://hotkang.cn/2018/Effects/</id>
    <published>2018-08-18T16:57:07.000Z</published>
    <updated>2018-08-29T07:22:42.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果概览-持续完善"><a href="#效果概览-持续完善" class="headerlink" title="效果概览 [持续完善]]"></a>效果概览 <span style="font-size:.5em">[持续完善]]</span></h2><ol><li><h3 id="AboutTime"><a href="#AboutTime" class="headerlink" title="AboutTime"></a>AboutTime</h3>…</li></ol><p><br><br><br></p><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p><a href="https://github.com/hotYan/Effects" target="_blank" rel="noopener">源码链接</a></p></blockquote><p><br><br><br></p><h2 id="AboutTime-1"><a href="#AboutTime-1" class="headerlink" title="AboutTime"></a>AboutTime</h2><hr><h3 id="1-Date-方法"><a href="#1-Date-方法" class="headerlink" title="1.Date()方法"></a>1.Date()方法</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">getTime()</td><td style="text-align:left">返回日期的毫秒数，与valueOf()返回值相同</td></tr><tr><td style="text-align:center">getFullYear()</td><td style="text-align:left">取得4位数的年份</td></tr><tr><td style="text-align:center">getMonth()</td><td style="text-align:left">返回0~11月</td></tr><tr><td style="text-align:center">getDate()</td><td style="text-align:left">返回1~31天</td></tr><tr><td style="text-align:center">getDay()</td><td style="text-align:left">返回星期0~6，0表示星期日</td></tr><tr><td style="text-align:center">getHours()</td><td style="text-align:left">返回小时数0~23</td></tr><tr><td style="text-align:center">getMinutes()</td><td style="text-align:left">返回分钟数0~59</td></tr><tr><td style="text-align:center">getSeconds()</td><td style="text-align:left">返回秒数0~59</td></tr><tr><td style="text-align:center">setDate()</td><td style="text-align:left">设置日期中的天数</td></tr></tbody></table><p><a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp" target="_blank" rel="noopener">more&gt;&gt;</a></p><p><br><br><br></p><h3 id="2-Math对象"><a href="#2-Math对象" class="headerlink" title="2.Math对象"></a>2.Math对象</h3><blockquote><h4 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h4></blockquote><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">Math.E</td><td style="text-align:left">自然对数的底数，即常量e的值</td></tr><tr><td style="text-align:center">Math.LN10</td><td style="text-align:left">10的自然对数</td></tr><tr><td style="text-align:center">Math.LN2</td><td style="text-align:left">2的自然对数</td></tr><tr><td style="text-align:center">Math.LOG2E</td><td style="text-align:left">以2为底e的对数</td></tr><tr><td style="text-align:center">Math.LOG10E</td><td style="text-align:left">以10为底e的对数</td></tr><tr><td style="text-align:center">Math.PI</td><td style="text-align:left">π的值</td></tr><tr><td style="text-align:center">Math.SQRT_2</td><td style="text-align:left">1/2的平方根</td></tr><tr><td style="text-align:center">Math.SQRT2</td><td style="text-align:left">2的平方根</td></tr></tbody></table><p><br></p><blockquote><h4 id="min-和-max"><a href="#min-和-max" class="headerlink" title="min() 和 max()"></a>min() 和 max()</h4></blockquote><p>确定数值数组中的最大(小)值：</p><pre><code>var max = Math.max(3,54,32,16);alert(max);         //54var min = Math.min(3,54,32,16);alert(min);         //3var arr = [1,2,3,4,5,6,7,8];var max = Math.max.apply(Math,arr);console.log(max);       //8</code></pre><p><br></p><blockquote><h4 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h4></blockquote><p>Math.ceil()：向上取最接近的整数；Math.round()：正常的四舍五入；Math.floor()：向下去最接近的整数：</p><pre><code>console.log(Math.ceil(25.9));       //26   console.log(Math.ceil(25.5));       //26 console.log(Math.ceil(25.1));       //26 console.log(Math.round(25.9));      //26 console.log(Math.round(25.5));      //26 console.log(Math.round(25.1));      //25 console.log(Math.floor(25.9));      //25 console.log(Math.floor(25.5));      //25 console.log(Math.floor(25.1));      //25</code></pre><p><br></p><blockquote><h4 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h4></blockquote><p>Math.random()方法返回[0,1)的一个随机数。因为返回的总是一个小数值，所以用到Math.floor()方法：</p><blockquote><blockquote><p>值 = Math.floor(Math.random()* 可能的总数 + 第一个可能的值 )</p></blockquote></blockquote><pre><code>console.log(Math.floor(Math.random()*10+1));console.log(Math.floor(Math.random()*9+2));</code></pre><p><a href="http://www.w3school.com.cn/js/jsref_obj_math.asp" target="_blank" rel="noopener">more&gt;&gt;</a></p><p><br><br><br></p><h3 id="3-setTimeout-和-setInterval"><a href="#3-setTimeout-和-setInterval" class="headerlink" title="3.setTimeout() 和 setInterval()"></a>3.setTimeout() 和 setInterval()</h3><ul><li><p><a href="http://www.w3school.com.cn/htmldom/met_win_settimeout.asp" target="_blank" rel="noopener">参考资料1</a></p></li><li><p><a href="https://wangdoc.com/javascript/async/timer.html" target="_blank" rel="noopener">参考资料2</a></p></li></ul><p><br><br><br></p><h3 id="4-功能预览"><a href="#4-功能预览" class="headerlink" title="4.功能预览"></a>4.功能预览</h3><blockquote><p>显示当前时间：XXXX 年 XX 月 XX 日 星期X XX:XX:XX</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">showTime: function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        var date = new Date();</span><br><span class="line">        var year = date.getFullYear(),</span><br><span class="line">            month = format(date.getMonth() + 1),</span><br><span class="line">            day = format(date.getDate()),</span><br><span class="line">            week = date.getDay(),//星期</span><br><span class="line">            H = format(date.getHours()),</span><br><span class="line">            M = format(date.getMinutes()),</span><br><span class="line">            S = format(date.getSeconds());</span><br><span class="line">        //①用【Array构造函数】创建数组</span><br><span class="line">        //var weeks = new Array(&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;);</span><br><span class="line">        //②用【数组字面量】创建数组 </span><br><span class="line">        var weeks = [&quot; 星期日 &quot;, &quot; 星期一 &quot;, &quot; 星期二 &quot;, &quot; 星期三 &quot;, &quot; 星期四 &quot;, &quot; 星期五 &quot;, &quot; 星期六 &quot;];</span><br><span class="line">        document.getElementById(&quot;showTime&quot;).innerHTML = year + &quot; 年 &quot; + month + &quot; 月 &quot; + day + &quot; 日 &quot; + weeks[week] + H + &quot; : &quot; + M + &quot; : &quot; + S;</span><br><span class="line">        setTimeout(arguments.callee,500);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>高考倒计时：剩余 XXX 天</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">deadLine: function () &#123;</span><br><span class="line">    var nowdate = new Date();</span><br><span class="line">    var deadline = new Date(&apos;2020,6,6&apos;),</span><br><span class="line">        lefttime = Math.ceil((deadline.getTime() - nowdate.getTime()) / (24 * 60 * 60 * 1000));</span><br><span class="line">    if (lefttime &gt; 0) &#123;</span><br><span class="line">        document.getElementById(&quot;deadLine&quot;).innerHTML = &apos;剩余  &apos; + lefttime + &apos;  天&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        document.getElementById(&apos;deadLine&apos;).innerHTML = &apos;倒计已结束&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>限时抢购： 剩余 XX 天 XX 时 XX 分 XX 秒</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">limitedTime: function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        var nowtime = new Date(),</span><br><span class="line">            endtime = new Date(&apos;2020,6,6,12:00:00&apos;),</span><br><span class="line">            lefttime = (endtime.getTime() - nowtime.getTime()) / 1000,</span><br><span class="line">            day = parseInt(lefttime / (60 * 60 * 24)),</span><br><span class="line">            H = format(parseInt(lefttime / (60 * 60) % 24)),</span><br><span class="line">            M = format(parseInt(lefttime / 60 % 60)),</span><br><span class="line">            S = format(parseInt(lefttime % 60));</span><br><span class="line">        if (lefttime &gt; 0) &#123;</span><br><span class="line">            document.getElementById(&quot;limitedTime&quot;).innerHTML = &apos;剩余  &apos; + day + &apos;  天 &apos; + H + &apos; 时  &apos; + M + &apos; 分 &apos; + S + &apos; 秒 &apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            document.getElementById(&apos;limitedTime&apos;).innerHTML = &apos;限时抢已结束&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(arguments.callee, 500);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>某一天（过去或将来）：XXXX 年 XX 月 XX 日</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">oneDay: function (num) &#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">        date.setDate(date.getDate() + num);</span><br><span class="line">    var year = date.getFullYear(),</span><br><span class="line">        month = format(date.getMonth() + 1),</span><br><span class="line">        day = format(date.getDate());</span><br><span class="line">    document.getElementById(&quot;oneDay&quot;).innerHTML = year + &quot; 年 &quot; + month + &quot; 月 &quot; + day + &quot; 日 &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="选项卡切换"><a href="#选项卡切换" class="headerlink" title="选项卡切换"></a>选项卡切换</h2><hr><p><br><br><br></p><h2 id="图片轮播"><a href="#图片轮播" class="headerlink" title="图片轮播"></a>图片轮播</h2><hr><p>[待完善]…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;效果概览-持续完善&quot;&gt;&lt;a href=&quot;#效果概览-持续完善&quot; class=&quot;headerlink&quot; title=&quot;效果概览 [持续完善]]&quot;&gt;&lt;/a&gt;效果概览 &lt;span style=&quot;font-size:.5em&quot;&gt;[持续完善]]&lt;/span&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;h3 id=&quot;AboutTime&quot;&gt;&lt;a href=&quot;#AboutTime&quot; class=&quot;headerlink&quot; title=&quot;AboutTime&quot;&gt;&lt;/a&gt;AboutTime&lt;/h3&gt;…&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Effects" scheme="https://hotkang.cn/categories/Effects/"/>
    
    
      <category term="Effects_JS" scheme="https://hotkang.cn/tags/Effects-JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象编程三</title>
    <link href="https://hotkang.cn/2018/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89/"/>
    <id>https://hotkang.cn/2018/JavaScript面向对象编程三/</id>
    <published>2018-07-26T07:05:40.000Z</published>
    <updated>2018-10-25T05:40:25.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解继承-完结"><a href="#理解继承-完结" class="headerlink" title="理解继承 [完结]"></a>理解继承 <span style="font-size:.5em">[完结]</span></h2><p>JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋给另一个构造函数的原型实现的。这样,子类就能访问超类的所有属性和方法,这一点跟基于类的继承很相似。原型链不适宜单独使用,对象实例共享所有继承的属性和方法。可借用构造函数,即在子类型构造函数的内部调用超类型构造函数,每个实例都具有自己的属性同时保证只使用构造函数模式来定义类型。组合继承模式使用最多,即用原型链继承共享的属性和方法,用构造函数继承实例属性。<br><a id="more"></a></p><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>JavaScript高级程序设计(第3版)P162-P174</p></blockquote><p><br><br><br></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><blockquote><p>接口继承</p></blockquote><p>只继承 <strong>方法签名</strong>。由于函数没有签名,在ECMAScript中无法实现接口继承。</p><blockquote><p>实现继承</p></blockquote><p>继承 <strong>实际的方法</strong>。ECMAScript只支持实现继承,主要依靠 <strong>原型链</strong>来实现。</p><p><br></p><h2 id="一、原型链"><a href="#一、原型链" class="headerlink" title="一、原型链"></a>一、原型链</h2><p>基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><ol><li><h5 id="构造函数、原型、实例的关系"><a href="#构造函数、原型、实例的关系" class="headerlink" title="构造函数、原型、实例的关系:"></a>构造函数、原型、实例的关系:</h5><ul><li><p>每个 <strong><code>构造函数</code></strong> 都有一个 <strong><code>原型对象</code></strong> ,构造函数都包含一个指向其原型对象的指针(<code>prototype</code>)</p></li><li><p><strong><code>实例对象</code></strong> 都包含一个指向 <strong><code>原型对象</code></strong> 的内部指针(<code>[[Prototype]]</code>)</p></li><li><p><strong><code>原型对象</code></strong> 都包含一个指向 <strong><code>构造函数</code></strong> 的指针(<code>constructor</code>)</p></li></ul></li></ol><p><br></p><ol start="2"><li><h5 id="实现原型链的基本模式"><a href="#实现原型链的基本模式" class="headerlink" title="实现原型链的基本模式:"></a>实现原型链的基本模式:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;       //构造函数定义property属性</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;     //原型定义getSuperValue方法</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;          //构造函数定义subproperty属性</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType(); //创建SuperType实例并赋给SubType的原型来实现继承</span><br><span class="line"></span><br><span class="line">Subtype.prototype.getSubTypeValue = function()&#123;     //原型定义getSubTypeValue方法</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());        //true</span><br></pre></td></tr></table></figure><p>调用instance.getSuperValue()会经历三个搜索步骤:搜索实例 -&gt; 搜索Subtype.prototype -&gt; 搜索SuperType.prototype,最后才找到该方法</p><p>关系图:</p><p><img src="/img/YXL.png" alt=""></p></li></ol><p><br></p><ol start="3"><li><h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><blockquote><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5></blockquote><pre><code>alert(instance instanceof Object);       //truealert(instance instanceof SuperType);    //truealert(instance instanceof SubType);      //true</code></pre><blockquote><h5 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h5></blockquote><p>只要是原型链中出现过的原型,都可以说是该原型链所派生的实例的原型:</p><pre><code>alert(Object.prototype.isPrototypeOf(instance));        //truealert(SuperType.prototype.isPrototypeOf(instance));     //truealert(SubType.prototype.isPrototypeOf(instance));        //true</code></pre></li></ol><p><br></p><ol start="3"><li><h5 id="谨慎的定义方法"><a href="#谨慎的定义方法" class="headerlink" title="谨慎的定义方法"></a>谨慎的定义方法</h5><ul><li>添加新方法或重写超类类型中的方法,代码一定要放在替换原型的语句之后。</li><li>通过原型链实现继承，不能使用对象字面量创建原型方法。</li></ul></li><li><h5 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h5><ul><li>原型中定义的属性和方法将被所有实例共享。</li><li>创建子类型实例时，不能向超类型的构造函数传递参数。</li></ul></li></ol><p><br></p><h2 id="二、借用构造函数-伪造对象-经典继承"><a href="#二、借用构造函数-伪造对象-经典继承" class="headerlink" title="二、借用构造函数(伪造对象/经典继承)"></a>二、借用构造函数(伪造对象/经典继承)</h2><p>在子类的构造函数内部调用超类型构造函数，使用apply()和call()方法在新创建的对象上执行构造函数:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);        //&quot;red,blue,green,black&quot;</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors);        //&quot;red,blue,green&quot;</span><br></pre></td></tr></table></figure><p></p><ol><li><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>相对于原型链而言，构造函数可以在子类型构造函数中向超类型构造函数传递参数:</p><pre><code>function SuperType(){    this.name = name;}function SubType(){    SuperType.call(this, &quot;hotyan&quot;);     //继承了SuperType,同时还传递了参数    this.age = 18;      //实例属性}var instance = new SubType();alert(instance.name);       //&quot;hotyan&quot;alert(instance.age);         //18</code></pre></li><li><h5 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h5><p>方法都在构造函数中定义，函数无法复用。</p></li></ol><p><br></p><h2 id="三、组合继承-伪经典继承"><a href="#三、组合继承-伪经典继承" class="headerlink" title="三、组合继承(伪经典继承)"></a>三、组合继承(伪经典继承)</h2><p>使用原型链实现对原型属性和方法的继承，使用构造函数来实现对实例属性的继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;hotyan&quot;,18);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors);        //&quot;red,blue,green,black&quot;</span><br><span class="line">insyance1.sayNme();             //&quot;hotyan&quot;</span><br><span class="line">instance1.sayAge();             //18</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(&quot;hotyann&quot;,28);</span><br><span class="line">alert(instance2.colors);        //&quot;red,blue,green&quot;</span><br><span class="line">insyance2.sayNme();             //&quot;hotyann&quot;</span><br><span class="line">instance2.sayAge();             //28</span><br></pre></td></tr></table></figure><p>最常用的继承模式，能正常使用instanceof 和 isPrototypeOf()。</p><p><br></p><h2 id="四、原型式继承"><a href="#四、原型式继承" class="headerlink" title="四、原型式继承"></a>四、原型式继承</h2><p>借助原型可以基于原有的对象创建新对象，同时不必因此创建自定义类型。本质上讲，object()对传入其中的对象执行了一次浅复制。</p><p>原型式继承要求必须有一个对象作为另一个对象的基础，再根据需求对得到的对象加以修改：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function object(O)&#123;</span><br><span class="line">    function F()&#123;&#125;          //创建一个临时性的构造函数</span><br><span class="line">    F.prototype = o;        //将传入对象作为这个构造函数的原型</span><br><span class="line">    return new F();         //返回临时类型的新实例</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;hotyan&quot;,</span><br><span class="line">    friends:[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var hotyan1 = object(person);   //新对象讲person作为原型</span><br><span class="line">hotyan1.name = &quot;hotyan1&quot;;</span><br><span class="line">hotyan1.friends.push(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">var hotyan2 = object(person);</span><br><span class="line">hotyan2.name = &quot;hotyan2&quot;;</span><br><span class="line">hotyan2.friends.push(&quot;DD&quot;);</span><br><span class="line"></span><br><span class="line">alert(person.friends);      //&quot;A,B,C,D,DD&quot;</span><br></pre></td></tr></table></figure><p></p><p>person.friends不仅属于person所有,而且也会被hotyan1和hotyan2共享。实际上,相当于创建了person对象的两个副本。</p><p>ES5新增Object.create()方法规范化了原型式继承。接受两个参数： <strong>作为新对象原型</strong>的的对象、<strong>一个为新对象定义额外属性</strong>的对象。</p><p>在传入一个参数的情况下，Object.creat()与object()方法的行为相同。</p><p>Object.creat()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同（每个属性都是通过自己的描述符定义的）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;hotyan&quot;,</span><br><span class="line">    friends:[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var hotyan1 = Object.create(person, &#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        value: &quot;hotyan1&quot;        //将覆盖原型上的同名属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);  </span><br><span class="line">alert(hotyan1.name);      //&quot;hotyan1&quot;</span><br></pre></td></tr></table></figure><p></p><p>原型式继承完全可以胜任只想让一个对象与另一个对象保持类似的情况。</p><p><br></p><h2 id="五、寄生式继承"><a href="#五、寄生式继承" class="headerlink" title="五、寄生式继承"></a>五、寄生式继承</h2><p>思路与寄生构造函数、工厂模式类似：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后像真的是它做了所有工作一样返回对象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(o)&#123;</span><br><span class="line">    var f = object(o);          //通过调用函数来创建一个新对象</span><br><span class="line">    f.sayHi = function()&#123;       //以某种方式来增强这个对象</span><br><span class="line">        alert(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;hotyan&quot;,</span><br><span class="line">    friends:[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var hotyan1 = creatAnother(person);     //新对象不仅有person的所有属性和方法,而且还有自己的sayHi()方法</span><br><span class="line">hotyan1.sayHi();        //&quot;hi&quot;</span><br></pre></td></tr></table></figure><p></p><p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率(与构造函数模式类似)。</p><p><br></p><h2 id="六、寄生组合式继承"><a href="#六、寄生组合式继承" class="headerlink" title="六、寄生组合式继承"></a>六、寄生组合式继承</h2><p>组合继承模式最大的问题就是无论在什么情况下都会调用两次超类型的构造函数:创建子类型原型的时候,子类型构造函数内部。</p><p>子类型最终会包含超类型对象的全部实例，但我们不得不在调用子类型构造函数时重写这些属性：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">    SuperType.call(this, name);         //第二次调用SuperType()</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();     //第一次调用SuperType()</span><br><span class="line">    this.age = age;</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>所谓寄生组合式继承就是 <strong>通过借用构造函数来继承属性，通过原型链的混成形式来继承方法</strong>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType,superType)&#123;</span><br><span class="line">    var prototype = object(superType.prototype);        //创建超类型原型的一个副本</span><br><span class="line">    prototype.constructor = subType;                //为创建的副本添加constructor属性(重写原型导致默认属性constructor失去)</span><br><span class="line">    subType.prototype = prototype;              //将创建的副本赋值给子类型的原型</span><br><span class="line">&#125;</span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">    SuperType.call(this, name);         //第二次调用SuperType()</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>高效率体现在只调用了一次SuperType构造函数；</p><p>与此同时，原型链保持不变；</p><p>能正常使用instanceof 和 isPrototypeOf()。</p><p>是引用类型最理想的继承范式。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解继承-完结&quot;&gt;&lt;a href=&quot;#理解继承-完结&quot; class=&quot;headerlink&quot; title=&quot;理解继承 [完结]&quot;&gt;&lt;/a&gt;理解继承 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋给另一个构造函数的原型实现的。这样,子类就能访问超类的所有属性和方法,这一点跟基于类的继承很相似。原型链不适宜单独使用,对象实例共享所有继承的属性和方法。可借用构造函数,即在子类型构造函数的内部调用超类型构造函数,每个实例都具有自己的属性同时保证只使用构造函数模式来定义类型。组合继承模式使用最多,即用原型链继承共享的属性和方法,用构造函数继承实例属性。&lt;br&gt;
    
    </summary>
    
      <category term="面向对象编程" scheme="https://hotkang.cn/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="继承" scheme="https://hotkang.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象编程二</title>
    <link href="https://hotkang.cn/2018/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%BA%8C/"/>
    <id>https://hotkang.cn/2018/JavaScript面向对象编程二/</id>
    <published>2018-07-26T07:05:31.000Z</published>
    <updated>2018-10-25T05:40:42.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解并创建对象-完结"><a href="#理解并创建对象-完结" class="headerlink" title="理解并创建对象 [完结]"></a>理解并创建对象 <span style="font-size:.5em">[完结]</span></h2><p>ECMAScript 支持面向对象(OO)编程,但不使用类或者接口。对象可以在代码执行过程中创建和增强,因此具有动态性而非严格定义的实体。在没有类的情况下,可以采用下列模式创建对象。</p><ul><li><p>工厂模式: 使用简单的函数创建对象,为对象添加属性和方法并返回对象。(后被构造函数模式取代)</p></li><li><p>构造函数模式: 创建自定义引用类型,像创建内置对象实例一样使用new操作符。每个成员无法得到复用。</p></li><li>原型模式:使用构造函数的prototype属性来指定共享属性和方法。组合使用构造函数模式和原型模式,即用构造函数定义实例属性,用原型定义共享的属性和方法。<a id="more"></a><br><br><br></li></ul><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>JavaScript高级程序设计(第3版)P144-P162</p></blockquote><p><br><br><br></p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><hr><blockquote><p>Object构造函数</p></blockquote><pre><code>var hotyan = new Object();hotyan.name = hotyan;hotyan.age = 18;      //永远18...</code></pre><p><br></p><blockquote><p>对象字面量</p></blockquote><pre><code>var hotyan = {  name : &quot;hotyan&quot;,  age : 18};</code></pre><p>属性名也可以使用字符串</p><pre><code>var hotyan = {  &quot;name&quot; : &quot;hotyan&quot;,  &quot;age&quot; : 18,  5 : true       //数字属性名自动转换为字符串};</code></pre><p><br></p><blockquote><p>访问对象属性【点方法/方括号表示法】</p></blockquote><pre><code>alert(hotyan.name);       //&quot;hotyan&quot;alert(hotyan[&quot;name&quot;]);    //&quot;hotyan&quot;</code></pre><p>功能上没有区别,但<span id="inline-green">方括号表示法</span>可以通过变量来访问属性</p><pre><code>var propertyName = &quot;name&quot;;alert(hotyan[propertyName]);    //&quot;hotyan&quot;</code></pre><p>属性名使用的是<span id="inline-purple">关键字</span>、<span id="inline-blue">保留字</span>或包含会导致语法错误的字符、非字母非数字时可使用方括号表示法</p><pre><code>hotyan[&quot;first name&quot;] = &quot;hotyan&quot;;    //&quot;first name&quot;包含一个空格,不能使用点方法</code></pre><p>通常,除非必须使用变量来访问属性,否则建议用点方法。</p><p><br><br><br></p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><hr><h2 id="一、原始模式"><a href="#一、原始模式" class="headerlink" title="一、原始模式"></a>一、原始模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var hotyan1 = &#123;&#125;;    //与new Object() 相同</span><br><span class="line">hotyan1.name = &quot;hotyan1&quot;;</span><br><span class="line">hotyan1.age = 18;</span><br><span class="line"></span><br><span class="line">var hotyan2 =&#123;&#125;;</span><br><span class="line">hotyan2.name = &quot;hotyan2&quot;;</span><br><span class="line">hotyan2.age = 28;</span><br></pre></td></tr></table></figure><p>最 <strong>简单</strong>的封装,把两个属性封装在一个对象里面。<br>缺点:</p><ol><li>使用同一个接口创建很多对象(创建多个实例),会产生大量 <strong>重复代码</strong>。</li><li>实例与原型之间,看不出任何联系。</li></ol><p><br></p><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><p>工厂模式是广为人知的设计模式,抽象了创建具体对象的过程。</p><p>用函数来封装 <strong>以特定接口创建对象</strong>的细节:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o =new Object();    //显示的创建对象</span><br><span class="line">    o.name = name;          </span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = createPerson(&quot;hotyan1&quot;,18,&quot;Student&quot;);</span><br><span class="line">var hotyan2 = createPerson(&quot;hotyan2&quot;,28,&quot;Engineer&quot;);</span><br></pre></td></tr></table></figure><p></p><p>解决了创建多个相似对象的问题(即解决代码重复的问题)。<br>不足:</p><ol><li><p>没有解决对象识别问题(即不知道对象的类型)</p></li><li><p>实例之间没有内在的联系,不能反映出它们是同一个原型对象的实例</p></li></ol><p><br></p><h2 id="三、构造函数模式"><a href="#三、构造函数模式" class="headerlink" title="三、构造函数模式"></a>三、构造函数模式</h2><p>构造函数本身就是一个函数,出于 <strong>创建新对象</strong>的目的而定义的。</p><p>内部使用了 <strong><code>this</code></strong> 变量,使用 <strong><code>new</code></strong> 运算符就能生成实例,并且 <strong><code>this</code></strong> 变量会绑定在实例对象上。</p><p>构造函数的函数名始终都应该以一个大写字母开头,非构造函数则应该以一个小写字母开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;  </span><br><span class="line">    /*直接将属性和方法赋给this对象*/</span><br><span class="line">    this.name = name;       </span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line"></span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;,18,&quot;Student&quot;);</span><br><span class="line">var hotyan2 = new Person(&quot;hotyan2&quot;,28,&quot;Engineer&quot;);</span><br></pre></td></tr></table></figure><p><strong><code>hotyan1</code></strong> 和 <strong><code>hotyan2</code></strong> 都有一个 <strong><code>constructor</code>(构造函数)属性</strong>,该属性指向 <strong><code>Person</code></strong> :</p><pre><code>alert(hotyan1.constructor == Person);   //truealert(hotyan2.constructor == Person);   //true</code></pre><p>对象的 <strong><code>constructor</code></strong> 属性最初是用来标识对象类型的。</p><p>但是提到检测对象类型,还是 <strong><code>instanceof</code></strong> 操作符更可靠一些:</p><pre><code>alert(hotyan1 instanceof Object);   //truealert(hotyan2 instanceof Object);   //truealert(hotyan1 instanceof Person);   //truealert(hotyan2 instanceof Person);   //true</code></pre><p>创建的对象既是Object的实例,也是Person的实例。验证了实例与原型之间的关系(即反映出它们是同一个原型对象的实例)。</p><p><br></p><blockquote><p>将构造函数当作函数</p></blockquote><p>构造函数与其他函数的唯一区别就是调用它们的方式不同。前面定义的Person()函数可以通过下列任何一种方式来调用:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1.当作构造函数使用</span><br><span class="line">var hotyan = new Person(&quot;hotyan&quot;,18,&quot;Student&quot;);</span><br><span class="line">hotyan.sayName();   //&quot;hotyan&quot;</span><br><span class="line"></span><br><span class="line">//2.作为普通函数使用</span><br><span class="line">Person(&quot;hotyan&quot;,18,&quot;Student&quot;);  //添加到window</span><br><span class="line">window.sayName();   //&quot;hotyan&quot;</span><br><span class="line"></span><br><span class="line">//3.在另一个对象的作用域中调用</span><br><span class="line">var O = new Object();</span><br><span class="line">Person.call(O, &quot;hotyan&quot;, 18, &quot;Student&quot;);</span><br><span class="line">O.sayName();   //&quot;hotyan&quot;</span><br></pre></td></tr></table></figure><p></p><ol><li>构造函数的典型用法,用new操作符来创建一个新对象。</li><li>不使用new操作符调用Person(),属性和方法都被添加window</li><li>使用call()或者apply()在某个特殊对象的作用域中调用Person()函数,O就拥有了所有属性和方法。</li></ol><p><br></p><blockquote><p>构造函数的问题</p></blockquote><p>主要问题:</p><pre><code>每个方法都要在每个实例上重新创建一遍。  </code></pre><p>不同实例上的同名函数是不相等的:</p><pre><code>alert(hotyan1.sayName == hotyan2.sayName);  //false</code></pre><p>尝试通过把函数定义转移到构造函数外部来解决问题:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = sayName; //将sayName属性设置成等于全局的sayName函数 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayName()&#123;     </span><br><span class="line">    alert(this.name);   </span><br><span class="line">&#125;                       </span><br><span class="line"></span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;,18,&quot;Student&quot;);</span><br><span class="line">var hotyan2 = new Person(&quot;hotyan2&quot;,28,&quot;Engineer&quot;);</span><br></pre></td></tr></table></figure><p></p><p><strong><code>sayName</code></strong> 包含的是一个指向函数的指针,因此 <strong><code>hotyan1</code></strong> 和 <strong><code>hotyan2</code></strong> 对象就共享了在全局作用域中定义的同一个 <strong><code>sayName()</code></strong> 函数。确实解决了两个函数做同一件事情的问题,可是新问题又来了:</p><ol><li><p>在全局作用域中定义的函数实际上只能被某个对象调用,这让全局作用域有点名不副实。</p></li><li><p>如果对象需要定义很多方法,就将定义很多个全局函数,使得自定义的引用类型丝毫没有封装性可言。</p></li></ol><p>这些问题可以通过原型模式解决！</p><p><br></p><h2 id="四、原型模式"><a href="#四、原型模式" class="headerlink" title="四、原型模式"></a>四、原型模式</h2><p>我们创建的每一个构造函数都有一个 <strong><code>prototype</code></strong> 属性,这个属性是一个 <strong>指针</strong>,指向一个 <strong>原型对象</strong>。这个原型对象的所有属性和方法，都会被构造函数的实例继承。</p><p>不必在构造函数中定义对象实例的信息,直接将信息添加到原型对象中:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">////////////后面将用...代替这部分代码/////////</span><br><span class="line">    function Person()&#123;&#125;</span><br><span class="line">    Person.prototype.name = &quot;hotyan&quot;;</span><br><span class="line">    Person.prototype.age = 18;</span><br><span class="line">    Person.prototype.job = &quot;Student&quot;;</span><br><span class="line">    Person.prototype.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">///////////到此处结束///////////////////////</span><br></pre></td></tr></table></figure><p></p><p>仍然可以通过调用构造函数来创建新对象,新对象的属性和方法是由所有实例共享的。</p><p>即 <strong><code>hotyan1</code></strong> 和 <strong><code>hotyan2</code></strong> 访问的都是同一组属性和同一个 <strong><code>sayName()</code></strong> 函数:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">hotyan1.sayName();  //&quot;hotyan&quot;</span><br><span class="line"></span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line">hotyan1.sayName();  //&quot;hotyan&quot;</span><br><span class="line"></span><br><span class="line">alert(hotyan1.sayName == hotyan2.sayName);  //true</span><br></pre></td></tr></table></figure><p></p><p>要理解原型模式的工作原理必须先理解ECMAScript中原型对象的性质。</p><p><br></p><blockquote><p>理解原型对象</p></blockquote><p>默认情况下,所有原型对象都会自动获得一个 <strong><code>constructor</code>(构造函数)属性</strong>,这个属性是一个 <strong>指针</strong>,指向 <strong><code>prototype</code>属性所在函数</strong>。</p><p>当调用构造函数创建一个新实例,内部包含一个内部属性 <strong>[[<code>Prototype</code>]]</strong>,这个属性是一个 <strong>指针</strong>,指向 <strong>构造函数的原型对象</strong>。</p><p><img src="/img/YX.png" alt=""></p><p>虽然在所有现实中都无法访问到 <strong>[[<code>Prototype</code>]]</strong>,可以通过 <strong><code>isPrototypeOf()</code></strong> 来确定对象之间是否存在这种关系:</p><pre><code>alert(Person.prototype.isPrototypeOf(hotyan1));     //truealert(Person.prototype.isPrototypeOf(hotyan2));     //true</code></pre><p>ECMAScript 5新增<code>Object.getPrototypeOf()</code>,返回[[<code>Prototype</code>]]的值:</p><pre><code>alert(Object.getPrototypeOf(hotyan1) == Person.prototype);  //truealert(Object.getPrototypeOf(hotyan1).name);  //&quot;hotyan&quot;</code></pre><p><br></p><blockquote><p>属性屏蔽</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">hotyan1.name = &quot;hotyanhotyan&quot;;  //为对象实例添加name属性,将屏蔽原型对象中的同名属性。</span><br><span class="line">alert(hotyan1.name);    //&quot;hotyanhotyan&quot; --来自实例</span><br><span class="line">alert(hotyan2.name);    //&quot;hotyan&quot; --来自原型</span><br></pre></td></tr></table></figure><p>在实例中添加<code>name</code>属性只会 <strong>阻止</strong>我们访问原型中的同名属性,即使将<code>name</code>属性设置为<code>null</code>,也只会在实例中设置属性值为<code>null</code>,而不会恢复其指向原型的连接。必须使用 <strong><code>delete</code>操作符</strong>完全删除实例属性才能重新访问原型中的属性:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">hotyan1.name = &quot;hotyanhotyan&quot;;  //为对象实例添加name属性,将屏蔽原型对象中的同名属性。</span><br><span class="line">alert(hotyan1.name);    //&quot;hotyanhotyan&quot; --来自实例</span><br><span class="line">alert(hotyan2.name);    //&quot;hotyan&quot; --来自原型</span><br><span class="line"></span><br><span class="line">delete hotyan1.name;    //!!!!!!!!!!!</span><br><span class="line">alert(hotyan1.name);    //&quot;hotyan&quot; --来自原型</span><br></pre></td></tr></table></figure><p></p><p>使用 <strong><code>hasOwnPrototype()</code></strong> 方法可检测一个属性存在于实例还是原型。存在实例时返回true:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line"></span><br><span class="line">hotyan1.name = &quot;hotyanhotyan&quot;;  //重写name属性</span><br><span class="line">alert(hotyan1.name);            //&quot;hotyanhotyan&quot;--来自实例</span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //true</span><br><span class="line"></span><br><span class="line">alert(hotyan2.name);            //&quot;hotyan&quot;--来自原型</span><br><span class="line">alert(hotyan2.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line"></span><br><span class="line">delete hotyan1.name;</span><br><span class="line">alert(hotyan1.name);            //&quot;hotyan&quot;--来自原型</span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //false</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><p>原型与in操作符</p></blockquote><p>单独使用时, <strong>in操作符</strong>会在通过对象能够访问给定属性时返回true:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line">alert(&quot;name&quot; in hotyan1);       //true</span><br><span class="line"></span><br><span class="line">hotyan1.name = &quot;hotyanhotyan&quot;;  //重写name属性</span><br><span class="line">alert(hotyan1.name);            //&quot;hotyanhotyan&quot;--来自实例</span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //true</span><br><span class="line">alert(&quot;name&quot; in hotyan1);       //true</span><br><span class="line"></span><br><span class="line">alert(hotyan2.name);            //&quot;hotyan&quot;--来自原型</span><br><span class="line">alert(hotyan2.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line">alert(&quot;name&quot; in hotyan2);       //true</span><br><span class="line"></span><br><span class="line">delete hotyan1.name;</span><br><span class="line">alert(hotyan1.name);            //&quot;hotyan&quot;--来自原型</span><br><span class="line">alert(hotyan1.hasOwnPrototype(&quot;name&quot;));     //false</span><br><span class="line">alert(&quot;name&quot; in hotyan1);       //true</span><br></pre></td></tr></table></figure><p></p><p>无论该属性存在于实例中还是存在于原型中,始终都返回true。</p><p>同时使用 <strong><code>hasOwnPrototype()</code></strong> 方法和 <strong>in操作符</strong>,就可以确定该属性是存在于对象中,还是存在于原型中:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hasPrototypePrototy(object,name)&#123;</span><br><span class="line">    return !object.hasOwnProperty(name) &amp;&amp; (name in object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>name in object</code>–通过对象能访问到属性时返回true;</p><p><code>hasOwnPrototype()</code>–属性存在于实例中时返回true;</p><p><code>!hasOwnPrototype()</code>–属性存在于原型中时返回true;</p><p>因此,只要 <strong><code>hasPrototypePrototy()</code></strong> 返回 <strong><code>true</code></strong> ,可以确定属性存在于 <strong>原型</strong>:</p><pre><code>...var hotyan1 = new Person();alert(hasPrototyprPrototy(hotyan1, &quot;name&quot;));    //truehotyan1.name = &quot;hotyanhotyan&quot;;//重写name属性alert(hasPrototyprPrototy(hotyan1, &quot;name&quot;));    //false</code></pre><p><br></p><blockquote><p>更简单的原型语法</p></blockquote><p>每添加一个属性或方法,就要重复一遍 <strong><code>Person.prototype</code></strong>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.name = &quot;hotyan&quot;;</span><br><span class="line">Person.prototype.age = 18;</span><br><span class="line">Person.prototype.job = &quot;Student&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>减少不必要输入的同时,从视觉上更好的封装整个原型,用对象字面量来 <strong>重写</strong>整个原型对象:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;hotyan&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Student&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><strong><code>Person.prototype</code></strong> 等于一个以对象字面量形式创建的新对象,结果相同。</p><p>但是 <strong><code>constructor</code>属性</strong>不再指向 <strong><code>Person</code></strong> (指向 <strong><code>Object</code>构造函数</strong>):</p><pre><code>...var hotyan1 = new Person();alert(hotyan1.constructor == Person);   //falsealert(hotyan1.constructor == Object);   //true</code></pre><p>如果 <strong><code>constructor</code>的值</strong> 真的非常重要,可以特意设置回适当的值:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,   //值设为Person</span><br><span class="line">    name : &quot;hotyan&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Student&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p><br></p><blockquote><p>原型的动态性</p></blockquote><p>对原型对象所做的任何修改都可以立即从实例对象上反映出来,即使是 <strong>先创建实例后修改原型对象</strong>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">var hotyan1 = new Person();     //新建Person实例保存在hotyan1中</span><br><span class="line">Person.prototype.sayHi = function()&#123;    //给原型对象新添sayHi()方法</span><br><span class="line">    alert(&quot;hi&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">hotyan1.sayHi();    //&quot;hi&quot;--仍然可以访问sayHi()方法</span><br></pre></td></tr></table></figure><p></p><p>其原因归结于 <strong>实例与原型之间的松散连接关系</strong>。</p><p>但是如果是重写整个原型对象,情况就不一样了:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">var hotyan1 = new Person();     //新建Person实例保存在hotyan1中</span><br><span class="line">Person.prototype = &#123;            //重写整个原型对象</span><br><span class="line">    constructor : Person,       //值设为Person</span><br><span class="line">    name : &quot;hotyan&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Student&quot;,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">hotyan1.sayName();      //error</span><br></pre></td></tr></table></figure><p></p><p>重写原型对象</p><p>切断了构造函数与最初原型之间的联系(即构造函数指向了重写的新原型),</p><p>切断了之前已经存在的实例与新原型之间的关系(即之前已经存在的实例仍然指向最初的原型)。</p><p><img src="/img/RWYX.png" alt=""></p><p><br></p><blockquote><p>原生对象的原型</p></blockquote><p>原型模式的重要性不仅体现在 <strong>创建自定义类型</strong>,所有原生的引用类型(<code>Object、Array、String...</code>)都采用原型模式创建。</p><p>通过原生对象的原型,不仅可以 <strong>取得所有默认方法的引用</strong>,而且可以 <strong>定义新方法</strong>。(但不推荐！)</p><p><br></p><blockquote><p>原型对象的问题</p></blockquote><ol><li><p>省略了为构造函数传递的初始化参数,导致所有实例在默认情况下拥有相同的属性值。(不是最大问题)</p></li><li><p>原型中的属性和方法是被所有实例共享的,对于函数非常适合,对于包含基本值得属性倒也说的过去(可以重写属性),对于包含引用类型值得属性来说,问题比较突出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;hotyan&quot;,</span><br><span class="line">    age : 18,</span><br><span class="line">    job : &quot;Student&quot;,</span><br><span class="line">    friends :[&quot;A&quot;, &quot;B&quot;],</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var hotyan1 = new Person();</span><br><span class="line">var hotyan2 = new Person();</span><br><span class="line"></span><br><span class="line">hotyan1.friends.push(&quot;C&quot;);      //向hotyan1添加了好友C</span><br><span class="line">alert(hotyan1.friends);     //&quot;A,B,C&quot;</span><br><span class="line">alert(hotyan2.friends);     //&quot;A,B,C&quot;--结果hotyan2也一同被修改</span><br><span class="line">alert(hotyan1.friends === hotyan2.friends);//true</span><br></pre></td></tr></table></figure></li></ol><pre><code>这个问题也是我们很少看见有人 **单独使用原型模式**的原因所在！！</code></pre><p><br></p><h2 id="五、构造函数和原型混合模式"><a href="#五、构造函数和原型混合模式" class="headerlink" title="五、构造函数和原型混合模式"></a>五、构造函数和原型混合模式</h2><p>是创建自定义类型最常见的方式。构造函数模式:定义实例属性;原型模式:定义共享属性和方法。</p><p>还支持向构造函数传递参数,可谓集两种模式之长:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;A&quot;, &quot;B&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;, 18, &quot;Student&quot;);</span><br><span class="line">var hotyan2 = new Person(&quot;hotyan2&quot;, 28, &quot;Engineer&quot;);</span><br><span class="line"></span><br><span class="line">hotyan1.friends.push(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">alert(hotyan1.friends);     //&quot;A,B,C&quot;</span><br><span class="line">alert(hotyan2.friends);     //&quot;A,B&quot;</span><br><span class="line">alert(hotyan1.friends === hotyan2.friends);     //false</span><br><span class="line">alert(hotyan1.sayName === hotyan2.sayName);     //true</span><br></pre></td></tr></table></figure><p></p><p>这种构造函数与原型混成的模式,是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说是用来 <strong>定义引用类型的一种默认模式</strong>。</p><p><br></p><h2 id="六、动态原型模式"><a href="#六、动态原型模式" class="headerlink" title="六、动态原型模式"></a>六、动态原型模式</h2><p>把所有信息都封装到构造函数中,通过在构造函数中初始化原型(必要情况下)。</p><p>保存了同时使用构造函数和原型的优点:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line"></span><br><span class="line">    if(typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;, 18, &quot;Student&quot;);</span><br><span class="line">hotyan1.sayName();      //&quot;hotyan1&quot;</span><br></pre></td></tr></table></figure><p></p><p>使用动态原型模式时,不能使用对象字面量重写原型对象(重写原型会切断现有实例与新原型之间的联系,即现有实例仍然指向最初的原型)。</p><p><br></p><h2 id="七、寄生构造函数模式"><a href="#七、寄生构造函数模式" class="headerlink" title="七、寄生构造函数模式"></a>七、寄生构造函数模式</h2><p>基本思想是创建一个函数,函数作用仅仅是封装创建对象的代码,然后返回新创建的对象:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = new Person(&quot;hotyan1&quot;, 18, &quot;Student&quot;);</span><br><span class="line">hotyan1.sayName();      //&quot;hotyan1&quot;</span><br></pre></td></tr></table></figure><p></p><p>除了使用 <strong><code>new</code>操作符</strong> 创建实例并把封装函数叫做构造函数外,这个模式跟工厂模式一模一样。</p><p>不能依赖 <strong><code>insatnceof</code>操作符</strong> 来确定对象类型(返回的对象与构造函数或者够着函数的原型属性之间没有关系,即返回的对象相对于在构造函数外部创建的对象),能使用其他模式的情况下,就不使用寄生构造函数模式。</p><p><br></p><h2 id="八、稳妥构造函数模式"><a href="#八、稳妥构造函数模式" class="headerlink" title="八、稳妥构造函数模式"></a>八、稳妥构造函数模式</h2><p>所谓稳妥对象,指没有公共属性,方法也不引用this对象。与寄生构造函数类似,但有两点不同:</p><ol><li><p>新创建对象的实例方法不引用this;</p></li><li><p>不使用new操作符调用构造函数(来创建实例)。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var hotyan1 = Person(&quot;hotyan1&quot;, 18, &quot;Student&quot;);</span><br><span class="line">hotyan1.sayName();      //&quot;hotyan1&quot;</span><br></pre></td></tr></table></figure><p>不能依赖 <strong><code>insatnceof</code>操作符</strong>来确定对象类型(返回的对象与构造函数或者够着函数的原型属性之间没有关系,即返回的对象相对于在构造函数外部创建的对象),稳妥构造函数提供的安全性非常适合在某些安全执行环境(ADsafe、Caja)下使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解并创建对象-完结&quot;&gt;&lt;a href=&quot;#理解并创建对象-完结&quot; class=&quot;headerlink&quot; title=&quot;理解并创建对象 [完结]&quot;&gt;&lt;/a&gt;理解并创建对象 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;ECMAScript 支持面向对象(OO)编程,但不使用类或者接口。对象可以在代码执行过程中创建和增强,因此具有动态性而非严格定义的实体。在没有类的情况下,可以采用下列模式创建对象。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;工厂模式: 使用简单的函数创建对象,为对象添加属性和方法并返回对象。(后被构造函数模式取代)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;构造函数模式: 创建自定义引用类型,像创建内置对象实例一样使用new操作符。每个成员无法得到复用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;原型模式:使用构造函数的prototype属性来指定共享属性和方法。组合使用构造函数模式和原型模式,即用构造函数定义实例属性,用原型定义共享的属性和方法。
    
    </summary>
    
      <category term="面向对象编程" scheme="https://hotkang.cn/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="封装" scheme="https://hotkang.cn/tags/%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象编程一</title>
    <link href="https://hotkang.cn/2018/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%80/"/>
    <id>https://hotkang.cn/2018/JavaScript面向对象编程一/</id>
    <published>2018-07-26T07:04:41.000Z</published>
    <updated>2018-10-25T05:40:18.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解面向对象编程-完结"><a href="#理解面向对象编程-完结" class="headerlink" title="理解面向对象编程 [完结]"></a>理解面向对象编程 <span style="font-size:.5em">[完结]</span></h2><p>JS的面向对象编程和其它大多数语言如Java、C#的面向对象编程都不太一样。JS不区分类和实例的概念,而是通过原型（prototype）来实现面向对象编程。JS的原型链和Java的Class区别在于JS没有“Class”的概念,所有对象都是实例,所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>JavaScript高级程序设计(P110~P118)</p><p>JavaScript设计模式(P11~P18)</p></blockquote><p><br><br><br></p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><hr><ol><li><h5 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h5><p>大概就是下面说的这样:</p><blockquote><p>面向对象是相对于面向过程的,比如你要充话费,你会想,下个支付宝,注册并登录,绑定银行卡,充值。这种种过程。但是对于你女朋友就不一样了,她是面向“对象”的,她会想,谁会充话费呢？当然是你了,她就给你电话,然后你把之前的做了一遍,然后她收到充值成功的短信,说了句,么么哒。这就是面向对象！女的思维大部分是面向“对象”的！她不关心处理的细节,只关心谁可以,和结果!</p></blockquote></li></ol><ol start="2"><li><h5 id="两个基本概念"><a href="#两个基本概念" class="headerlink" title="两个基本概念"></a>两个基本概念</h5><blockquote><p>类</p></blockquote><p><strong>类是对象的类型模板</strong>。例如:定义Student类来表示学生,类本身是一种类型,Student表示学生类型,但不表示任何具体的某个学生。</p><blockquote><p>实例</p></blockquote><p><strong>实例是根据类创建的对象</strong>。例如:根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例,每个实例表示一个具体的学生,他们全都属于Student类型。</p></li></ol><ol start="3"><li><h5 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h5><blockquote><p>封装</p></blockquote><p>把客观事物封装成抽象的类,并且类可以把自己的数据和方法只让可信的类或者对象操作,对不可信的进行信息隐藏。</p><blockquote><p>继承</p></blockquote><p>指这样一种能力:它可以使用现有类的所有功能,并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><blockquote><p>多态</p></blockquote><p>允许将子类类型的指针赋值给父类类型的指针。实现多态:覆盖、重载。</p><p><a href="https://www.jianshu.com/p/50999d81eeb5" target="_blank" rel="noopener">查看更多&gt;&gt;</a></p></li></ol><p><br><br><br></p><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><hr><p>每个函数都是Function类型的实例,都与其他引用类型一样具有属性和方法。函数实际上是对象,函数名实际上是一个指向函数对象的指针,不会与某个函数绑定。</p><ol><li><h5 id="定义函数的三种方式"><a href="#定义函数的三种方式" class="headerlink" title="定义函数的三种方式"></a>定义函数的三种方式</h5><blockquote><p><strong>函数声明:</strong></p></blockquote><pre><code>function sum (num1, num2){    return num1 + num2;}</code></pre><blockquote><p><strong>函数表达式:</strong></p></blockquote><pre><code>var sum = function(num1, num2){    return num1 + num2;};  //注意此处有分号</code></pre><blockquote><p><strong>Function构造函数:</strong></p></blockquote><pre><code>var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);</code></pre><p>不推荐!！因为构造函数定义导致 <strong>解析两次代码</strong>影响性能:</p><ul><li><p>第一次是解析常规ECMAScript代码;</p></li><li><p>第二次是解析传入构造函数中的字符串。</p></li></ul></li></ol><ol start="2"><li><h5 id="一个函数可能有多个名字"><a href="#一个函数可能有多个名字" class="headerlink" title="一个函数可能有多个名字"></a>一个函数可能有多个名字</h5><p><strong>函数名仅仅是指向函数的指针</strong>,函数名与 <strong>包含对象指针的</strong>其他变量没有什么不同:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2)&#123;      //定义一个sum()函数用于求两盒个值得和</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(10,10));  //20</span><br><span class="line"></span><br><span class="line">var anotherSum = sum;       //声明变量anotherSum,设置其与sum相等(即他们都指向了同一个函数)。</span><br><span class="line">alert(anotherSum(10,10));   //20--正常调用anotherSum()</span><br><span class="line"></span><br><span class="line">sum = null;                 //将sum设置为null,让它与函&quot;数断绝关系&quot;</span><br><span class="line">alert(anotherSum(10,10));   //20--正常调用anotherSum()</span><br></pre></td></tr></table></figure></li><li><h5 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h5><p>其他语言(如Java)可以为一个函数编写两个定义,只要两个定义的 <strong>签名(参数的类型和数量)</strong> 不同即可。ECMAScript函数的参数是 <strong>0或多个值的数组</strong>,故没有函数签名。没有函数签名,真正的重载是不可能做到的。</p><p>声明了两个同名函数,结果则是后面的函数覆盖了前面的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addSum(num)&#123;</span><br><span class="line">    return num + 100;</span><br><span class="line">&#125;</span><br><span class="line">function addSum(num)&#123;</span><br><span class="line">    return num + 200;</span><br><span class="line">&#125;</span><br><span class="line">var result = addSum(100);   //300</span><br></pre></td></tr></table></figure><p>将函数名想象为指针有助于理解为什么ECMAScript中没有函数重载概念。</p></li></ol><ol start="4"><li><h5 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h5><p>解析器在执行环境中加载数据时,对函数声明和函数表达式并非一视同仁。解析器会率先读取 <strong><code>函数声明</code></strong>,并使其在执行任何代码之前可用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(10, 10));     //20</span><br><span class="line">function sum(sum1, sum2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码开始执行前,解析器就通过 <strong>函数声明提升</strong>读取并将函数声明添加到执行环境中。对代码求值时,JS引擎在第一遍会声明函数并将它们放到源代码树的顶部。<strong><code>函数表达式</code></strong> 必须等到解析器执行到它所在的代码行才会真正被解释执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(10, 10));     //&quot;unexpected identifier&quot;(意外标识符)错误</span><br><span class="line">var sum = function(sum1, sum2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除了什么时候可以通过变量访问函数这一点区别外,函数声明和函数表达式的语法是等价的！</strong></p></li></ol><ol start="5"><li><h5 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h5><p>ECMAScript中函数名本身就是变量,所以函数也可以作为值来使用。即不仅可以像传递参数一样把一个函数传递给另一个函数,而且可以将函数作为另一个函数的结果返回。</p><p>要访问函数的指针而不执行函数的话,必须去掉函数名后面的那对大括号。</p></li></ol><ol start="6"><li><h5 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h5><p>函数内部有两个特殊的对象: <strong><code>arguments</code></strong> 和 <strong><code>this</code></strong>。</p><blockquote><p><strong><code>arguments</code>:</strong></p></blockquote><p>类数组对象,保存函数参数。可使用 <strong>方括号语法</strong>访问它的每个元素。可用length属性来确定传递参数的个数。可与命名参数一起使用。值永远与对应命名参数的值保持同步。<code>arguments</code>有一个<code>callee</code>指针属性,指向拥有这个<code>arguments</code>对象的函数。</p><p>经典的阶乘函数,在函数有名字且以后不会改变的情况下,这样定义没有问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1) </span><br><span class="line">        return 1;</span><br><span class="line">    else </span><br><span class="line">        return num * factorial(num-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个函数的执行与函数<code>factorial</code>紧紧耦合在了一起。可使用<code>arguments.callee</code>来消除紧密耦合现象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if(num &lt;= 1) </span><br><span class="line">        return 1;</span><br><span class="line">    else </span><br><span class="line">        return num * arguments.callee(num-1);</span><br><span class="line">&#125;</span><br><span class="line">var trueFactorial = factorial;</span><br><span class="line"></span><br><span class="line">factorial = function()&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(trueFactorial(5));    //120</span><br><span class="line">alert(factorial(5));        //0</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>this</code>:</strong></p></blockquote><p><code>this</code>引用的是函数执行的环境对象(即<code>this</code>值)。当在网页的全局作用域中调用函数时,<code>this</code>对象引用的就是<code>window</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color : &quot;blue&quot;&#125;;</span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();     //&quot;red&quot;--引用对象是window</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();       //&quot;blue&quot;--引用对象是o</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>caller</code>:</strong></p></blockquote><p>ECMAScript 5规范化了的一个函数对象属性。保存着 <strong>调用当前函数</strong> 的 <strong>函数的引用</strong>。如果是在全局作用域中调用当前函数,它的值为null。</p><blockquote><p>定义<code>arguments.callee</code>属性是为了分清<code>arguments.caller</code>和函数的<code>caller</code>属性。</p><p>严格模式下,访问<code>arguments.callee</code>会导致错误。访问<code>arguments.caller</code>(ECMAScript 5定义)也会导致错误,非严格模式下,<code>arguments.caller</code>属性始终是<code>undefined</code>。</p><p>严格模式还有一个限制:不能为函数<code>caller</code>属性赋值,否则会导致错误。</p></blockquote></li></ol><ol start="7"><li><h5 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h5><blockquote><p>属性:<code>length</code></p></blockquote><p>每个函数都包含两个属性:<code>length</code>和<code>prototype</code>。<code>length</code>属性表示函数希望接收的命名参数的个数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayName(name)&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">    alert(&quot;Hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">alert(sayName.length);  //1</span><br><span class="line">alert(sum.length);  //2</span><br><span class="line">alert(sayHi.length);  //0</span><br></pre></td></tr></table></figure><blockquote><p>方法:<code>apply()</code></p></blockquote><p>每个函数都包含两个非继承而来的方法: <strong><code>apply()</code></strong> 和 <strong><code>call()</code></strong> 。可在特定的作用域中调用函数(即设置函数体内<code>this</code>对象的值)。</p><p><code>apply()</code>方法接收两个参数:①在其中运行函数的的作用域:<code>this</code>的引用对象;②参数数组:<code>Array</code>实例、<code>arguments</code>对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function applySum1(num1, num2)&#123;</span><br><span class="line">    return sum.apply(this, arguments);      //传入arguments</span><br><span class="line">&#125;</span><br><span class="line">function applySum2(num1, num2)&#123;</span><br><span class="line">    return sum.apply(this, [num1, num2]);       //传入数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(applySum1(10, 10));        //20</span><br><span class="line">alert(applySum2(10, 15));        //25</span><br></pre></td></tr></table></figure><blockquote><p>方法:<code>call()</code></p></blockquote><p><code>call()</code>和<code>apply()</code>方法作用相同,区别在于接收参数方式不同。<code>call()</code>传递给函数的参数必须逐个列举出来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum(num1, num2)&#123;</span><br><span class="line">    return sum.call(this, num1, num2);      </span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(10, 10));        //20</span><br></pre></td></tr></table></figure><p>传递参数并非<code>call</code>和<code>apply</code>的真正用武之地,真正强大的地方是能够扩充函数赖以运行的作用域:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color : &quot;blue&quot;&#125;;</span><br><span class="line"></span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();     //&quot;red&quot;--window.color</span><br><span class="line"></span><br><span class="line">sayColor().call(this);       //&quot;red&quot;</span><br><span class="line">sayColor().call(window);       //&quot;red&quot;</span><br><span class="line">sayColor().call(o);       //&quot;blue&quot;</span><br></pre></td></tr></table></figure><p>扩充作用域的最大好处:对象不需要与方法有任何耦合关系。可省去此步骤: <code>o.sayColor = sayColor;</code></p><blockquote><p>方法:<code>bind()</code></p></blockquote><p>调用<code>bind()</code>会创建一个函数实例,其this值会被绑定到 <strong>传给bind()函数</strong>的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = &quot;red&quot;;</span><br><span class="line">var o = &#123;color : &quot;blue&quot;&#125;;</span><br><span class="line"></span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();       //&quot;blue&quot;</span><br></pre></td></tr></table></figure></li></ol><p><br><br><br></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><hr><ol><li><h5 id="创建一个类"><a href="#创建一个类" class="headerlink" title="创建一个类"></a>创建一个类</h5><p>声明一个函数(类)保存在一个变量里,一般将这个代表类的变量名首字母大写。在函数(类)的内部通过this(函数内部自带的一个变量,用于指向当前这个对象)变量添加属性和方法来实现对函数(类)添加属性和方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Book = function(id,name,price)&#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.price = price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可通过在类的原型上添加属性和方法:</p><pre><code>//一一为原型对象属性赋值Book.prototype.display = function(){    //.....}//将一个对象赋值给类的原型对象Book.prototype = {    display : function(){}};</code></pre><p>用new操作符来实例化新对象,通过点方法访问实例化对象的属性和方法:</p><pre><code>var book = new Book(10,&quot;Javascript设计模式&quot;, 50);alert(book.id);   //10</code></pre></li><li><h5 id="属性与方法封装"><a href="#属性与方法封装" class="headerlink" title="属性与方法封装"></a>属性与方法封装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//私有属性和私有方法,特权方法,对象公有属性和公有方法,构造器</span><br><span class="line">var Book = function(id, name, price)&#123;</span><br><span class="line"></span><br><span class="line">    var num = 1;    //私有属性</span><br><span class="line">    function checkId()&#123;&#125;;   //私有方法</span><br><span class="line"></span><br><span class="line">    this.getName = function()&#123;&#125;;    //特权方法</span><br><span class="line">    this.getPrice = function()&#123;&#125;;</span><br><span class="line">    this.setName = function()&#123;&#125;;</span><br><span class="line">    this.setPrice = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    this.id = id;   //公有属性</span><br><span class="line">    this.copy = function()&#123;&#125;;   //公有方法</span><br><span class="line"></span><br><span class="line">    this.setName(name);     //构造器</span><br><span class="line">    this.setPrice(price);</span><br><span class="line">&#125;;</span><br><span class="line">Book.isChinese = true;  //静态公有属性(对象不能访问)</span><br><span class="line">Book.resetTime = function()&#123;    //静态公有方法(对象不能访问)</span><br><span class="line">    alert(&quot;New Time&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">Book.prototype = &#123;</span><br><span class="line">    isBook : false,     //公有属性</span><br><span class="line">    display : function()&#123;&#125;      //  公有方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有属性和方法、静态公有属性和方法在通过New操作符创建的book对象里是访问不到的:</p><pre><code>var book = new Book(10,&quot;Javascript设计模式&quot;, 50);alert(book.num);   //undefinedalert(book.isJSBook);   //false</code></pre><p>可以通过点方法访问到公有属性和方法:</p><pre><code>alert(book.id);   //10alert(book.isChinese);   //undefined</code></pre><p>静态公有属性和方法可以通过类的自身访问:</p><pre><code>alert(Book.isChinese);   //trueBook.resertTime();      //&quot;New Time&quot;</code></pre></li></ol><ol start="3"><li><h5 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h5><p>闭包是有权访问另一个函数作用域中变量的函数,即在一个函数内部创建另一个函数。将闭包作为创建对象的构造函数,又是闭包又是可实例对象的函数,即可访问到类函数作用域中的变量。</p><p>将类的静态变量通过闭包来实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Book = (function()&#123;</span><br><span class="line">    var bookNum = 0;    //静态私有变量</span><br><span class="line">    function checkBook(name)&#123;&#125;  //静态私有方法</span><br><span class="line"></span><br><span class="line">    return function(newId, newName, newPrice)&#123;</span><br><span class="line">        var name, price;        //私有变量</span><br><span class="line">        fucntion checkID(id)&#123;&#125;  //私有方法</span><br><span class="line"></span><br><span class="line">        this.getName = function()&#123;&#125;;    //特权方法</span><br><span class="line">        this.getPrice = function()&#123;&#125;;</span><br><span class="line">        this.setName = function()&#123;&#125;;</span><br><span class="line">        this.setPrice = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        this.id = id;   //公有属性</span><br><span class="line">        this.copy = function()&#123;&#125;;   //公有方法</span><br><span class="line"></span><br><span class="line">        bookNum++;</span><br><span class="line">        if(bookNum &gt; 100)</span><br><span class="line">            throw new Error(&quot;我们仅出版了100本书&quot;);</span><br><span class="line"></span><br><span class="line">        this.setName(name);     //构造器</span><br><span class="line">        this.setPrice(price);</span><br><span class="line">    &#125; </span><br><span class="line">    _book.prototype = &#123; //构建原型</span><br><span class="line">        isJSBook : false,       //静态公有属性</span><br><span class="line">        display : function()&#123;&#125;  //静态公有方法</span><br><span class="line">    &#125;;</span><br><span class="line">    retuen _book;   //返回类</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><h5 id="创建对象的安全模式"><a href="#创建对象的安全模式" class="headerlink" title="创建对象的安全模式"></a>创建对象的安全模式</h5><p>监测是否忘记New操作符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Book = function(title, time, type)&#123;</span><br><span class="line">    if(this instanceof Book)&#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.time = time;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return new Book(title, time, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解面向对象编程-完结&quot;&gt;&lt;a href=&quot;#理解面向对象编程-完结&quot; class=&quot;headerlink&quot; title=&quot;理解面向对象编程 [完结]&quot;&gt;&lt;/a&gt;理解面向对象编程 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;JS的面向对象编程和其它大多数语言如Java、C#的面向对象编程都不太一样。JS不区分类和实例的概念,而是通过原型（prototype）来实现面向对象编程。JS的原型链和Java的Class区别在于JS没有“Class”的概念,所有对象都是实例,所谓继承关系不过是把一个对象的原型指向另一个对象而已。&lt;/p&gt;
    
    </summary>
    
      <category term="面向对象编程" scheme="https://hotkang.cn/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="继承" scheme="https://hotkang.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="https://hotkang.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="封装" scheme="https://hotkang.cn/tags/%E5%B0%81%E8%A3%85/"/>
    
      <category term="多态" scheme="https://hotkang.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>GitHub修改邮箱后</title>
    <link href="https://hotkang.cn/2018/GitHub%E4%BF%AE%E6%94%B9%E9%82%AE%E7%AE%B1%E5%90%8E/"/>
    <id>https://hotkang.cn/2018/GitHub修改邮箱后/</id>
    <published>2018-07-23T08:05:18.000Z</published>
    <updated>2018-08-09T16:51:23.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改邮箱后。。。-待完善"><a href="#修改邮箱后。。。-待完善" class="headerlink" title="修改邮箱后。。。 [待完善]"></a>修改邮箱后。。。 <span style="font-size:.5em">[待完善]</span></h2><blockquote><p>有一天突然发现自己的提交记录变少了？？？？绿色少的可怜？？于是我就回想自己干了嘛！！！！<br>恩…前几天换了个邮箱…并且毫不犹豫的把旧邮箱删除了…</p><p>把旧邮箱重新添加回来,绿色也回来了！！！<br>但是我强迫症,不想把旧邮箱留着…</p></blockquote><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><ul><li><a href="http://blog.51cto.com/dangzhiqiang/1657864" target="_blank" rel="noopener">参考链接</a></li><li><a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">Changing author info</a>。</li></ul></blockquote><p><br><br><br></p><h2 id="全局Git设置"><a href="#全局Git设置" class="headerlink" title="全局Git设置"></a>全局Git设置</h2><hr><ol><li><h5 id="全局设置用户及邮箱"><a href="#全局设置用户及邮箱" class="headerlink" title="全局设置用户及邮箱"></a>全局设置用户及邮箱</h5><pre><code>$ git config --global user.name &quot;hotyan&quot;$ git config --global user.email &quot;hotyann@163.com&quot;</code></pre></li></ol><p><br></p><ol start="2"><li><h5 id="命令行查看全局设置"><a href="#命令行查看全局设置" class="headerlink" title="命令行查看全局设置"></a>命令行查看全局设置</h5><pre><code>$ git config  user.name #hotyan$ git config  user.email #hotyann@163.com</code></pre><p>补救措施只对以后的 commit 起效。（解决了修改邮箱后的绿色~）</p><p>如果想修改之前的作者信息(删除旧邮箱的前提下拯救之前的绿色),Github 给出了可靠的官方指南：<a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">Changing author info</a>。</p></li></ol><p><br></p><ol start="3"><li><h5 id="取消全局设置用户及邮箱"><a href="#取消全局设置用户及邮箱" class="headerlink" title="取消全局设置用户及邮箱"></a>取消全局设置用户及邮箱</h5><pre><code>$ git config --global --unset user.name $ git config --global --unset user.email </code></pre></li></ol><h2 id="修改密码后"><a href="#修改密码后" class="headerlink" title="修改密码后"></a>修改密码后</h2><p>博客push将失败,需要重新添加SSH。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;修改邮箱后。。。-待完善&quot;&gt;&lt;a href=&quot;#修改邮箱后。。。-待完善&quot; class=&quot;headerlink&quot; title=&quot;修改邮箱后。。。 [待完善]&quot;&gt;&lt;/a&gt;修改邮箱后。。。 &lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;有一天突然发现自己的提交记录变少了？？？？绿色少的可怜？？于是我就回想自己干了嘛！！！！&lt;br&gt;恩…前几天换了个邮箱…并且毫不犹豫的把旧邮箱删除了…&lt;/p&gt;&lt;p&gt;把旧邮箱重新添加回来,绿色也回来了！！！&lt;br&gt;但是我强迫症,不想把旧邮箱留着…&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://hotkang.cn/categories/GitHub/"/>
    
    
  </entry>
  
  <entry>
    <title>基于GitHubIssue的评论功能</title>
    <link href="https://hotkang.cn/2018/%E5%9F%BA%E4%BA%8EGitHubIssue%E7%9A%84%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <id>https://hotkang.cn/2018/基于GitHubIssue的评论功能/</id>
    <published>2018-07-19T11:45:13.000Z</published>
    <updated>2018-10-25T05:41:14.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加评论功能-完结"><a href="#添加评论功能-完结" class="headerlink" title="添加评论功能   [完结]"></a>添加评论功能 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>可以手动添加issue，这样非常简单，但是如果文章越来越多，手动添加肯定不现实。因此可以写脚本来实现自动创建issue。由于本人并不想把别人的脚本直接搬过来，所以自动创建issue暂时被搁置…</p></blockquote><a id="more"></a><p><br><br><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://wingjay.com/2017/06/08/rebuild-personal-blog/" target="_blank" rel="noopener">参考链接1</a></li><li><a href="https://hydroecology.net/using-github-to-host-blog-comments/" target="_blank" rel="noopener">参考链接2</a></li><li><a href="http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html" target="_blank" rel="noopener">参考链接3</a></li></ul><p>参考链接1&amp;2都是参考的链接3,建议先看一遍链接3,了解大概流程后再细看每个链接。具体代码参考的链接1。</p></blockquote><p><br><br><br></p><h2 id="实现评论功能"><a href="#实现评论功能" class="headerlink" title="实现评论功能"></a>实现评论功能</h2><hr><ol><li><h5 id="手动创建Issue"><a href="#手动创建Issue" class="headerlink" title="手动创建Issue"></a>手动创建Issue</h5><blockquote><p>进入Github博客仓库</p></blockquote><blockquote><p>单击 <span id="inline-green">Issues</span></p></blockquote><blockquote><p>单击 <span id="inline-green">New issue</span></p></blockquote><blockquote><p>编辑Title、Leave a comment</p></blockquote><blockquote><p>单击 <span id="inline-green">Submit new issue</span>完成</p></blockquote><blockquote><p>获得 commentIssueId 值</p></blockquote></li></ol><p><br></p><ol start="2"><li><h5 id="文章添加commentIssueId字段"><a href="#文章添加commentIssueId字段" class="headerlink" title="文章添加commentIssueId字段"></a>文章添加commentIssueId字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我是置顶博文</span><br><span class="line">date: 2018-07-18 21:30:35</span><br><span class="line">tags: 留言板</span><br><span class="line">categories: hotYan_博客之路</span><br><span class="line">top: 100</span><br><span class="line">commentIssueId: 1    </span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="3"><li><h5 id="添加-github-comments-swig-文件"><a href="#添加-github-comments-swig-文件" class="headerlink" title="添加 github_comments.swig 文件"></a>添加 github_comments.swig 文件</h5><p>在/themes/next/layout/_partials文件下新添github_comments.swig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">/*内容如下*/</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;div id=&quot;comments&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;post-header bg-&#123;&#123;site.default_post_color&#125;&#125;&quot;&gt;</span><br><span class="line">            &lt;h1 &gt;留言区&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;本站留言区搭建在 Github Issue 上,请点击下面按钮进行留言。&lt;/p&gt;</span><br><span class="line">            &lt;hr/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function loadComments(data) &#123;</span><br><span class="line">            var commentUrl = &quot;window.open(&apos;https://github.com/hotyan/hotyan.github.io/issues/&#123;&#123; page.commentIssueId &#125;&#125;&apos;)&quot;</span><br><span class="line">            $(&quot;#comments&quot;).append(&apos;&lt;div class=&quot;submit-comment&quot; style=&quot;text-align: center&quot;&gt;&lt;button onclick=&apos; + commentUrl + &apos; class=&quot;btn btn-primary&quot;&gt;留&amp;nbsp;言&lt;/button&gt;&lt;/div&gt;&apos;)</span><br><span class="line"></span><br><span class="line">            for (var i=0; i&lt;data.length; i++) &#123;</span><br><span class="line">                var cuser = data[i].user.login;</span><br><span class="line">                var cuserlink = data[i].user.html_url;</span><br><span class="line">                var avatarlink = data[i].user.avatar_url;</span><br><span class="line">                var clink = data[i].html_url;</span><br><span class="line">                var cbody = data[i].body_html;</span><br><span class="line">                var cavatarlink = data[i].user.avatar_url;      </span><br><span class="line">                var cdate = new Date(data[i].created_at);</span><br><span class="line">                var dopts = &#123; month: &apos;short&apos;, day: &apos;numeric&apos;, year: &apos;numeric&apos; &#125;</span><br><span class="line"></span><br><span class="line">                $(&quot;#comments&quot;).append(&apos;&lt;div class=&quot;timeline-comment-wrapper&quot;&gt;&lt;div class=&quot;avatar-parent-child timeline-comment-avatar&quot;&gt;&lt;a href=&quot;&apos; + cuserlink +&apos;&quot;&gt;&lt;img width=&quot;44&quot; height=&quot;44&quot; class=&quot;avatar rounded-1&quot; src=&quot;&apos; + avatarlink + &apos;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;timeline-comment current-user&quot;&gt;&lt;div class=&quot;timeline-comment-header&quot;&gt;&lt;h3 class=&quot;timeline-comment-header-text text-normal f5&quot;&gt;&lt;strong&gt;&apos; + cuser + &apos;&lt;/strong&gt;&lt;span class=&quot;post-meta&quot;&gt;&apos; + cdate.toLocaleDateString(&quot;en&quot;, dopts) + &apos;&lt;/span&gt;&lt;/h3&gt;&lt;/div&gt;&lt;div style=&quot;display: block !important; padding: 15px;&quot;&gt;&lt;article class=&quot;post-content&quot;&gt;&apos; + cbody + &apos;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $.ajax(&quot;https://api.github.com/repos/hotyan/hotyan.github.io/issues/&#123;&#123; page.commentIssueId &#125;&#125;/comments&quot;, &#123;</span><br><span class="line">            headers: &#123;Accept: &quot;application/vnd.github.v3.html+json&quot;&#125;,</span><br><span class="line">            dataType: &quot;json&quot;,</span><br><span class="line">            success: function(msg)&#123;</span><br><span class="line">                console.log(msg);</span><br><span class="line">                loadComments(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .timeline-comment-wrapper &#123;</span><br><span class="line">        margin-top: 0;</span><br><span class="line">        position: relative;</span><br><span class="line">        padding-left: 60px;</span><br><span class="line">        margin-top: 15px;</span><br><span class="line">        margin-bottom: 15px;</span><br><span class="line">        border-top: 2px solid #fff;</span><br><span class="line">        border-bottom: 2px solid #fff;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-avatar &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        margin-left: -60px;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .avatar-parent-child &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-wrapper a &#123;</span><br><span class="line">        color: #0366d6;</span><br><span class="line">        text-decoration: none;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-wrapper .avatar &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        line-height: 1;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-wrapper .rounded-1 &#123;</span><br><span class="line">        border-radius: 3px !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment.current-user &#123;</span><br><span class="line">        border-color: #c0d3eb;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">        border: 1px solid #d1d5da;</span><br><span class="line">        border-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment.current-user .timeline-comment-header &#123;</span><br><span class="line">        background-color: #f1f8ff;</span><br><span class="line">        border-bottom-color: #c0d3eb;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-header &#123;</span><br><span class="line">        padding-right: 15px;</span><br><span class="line">        padding-left: 15px;</span><br><span class="line">        color: #586069;</span><br><span class="line">        background-color: #f6f8fa;</span><br><span class="line">        border-bottom: 1px solid #d1d5da;</span><br><span class="line">        border-top-left-radius: 3px;</span><br><span class="line">        border-top-right-radius: 3px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-header-text &#123;</span><br><span class="line">        padding-top: 10px;</span><br><span class="line">        padding-bottom: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-header h3 &#123;</span><br><span class="line">        margin-top: 0px;</span><br><span class="line">        margin-bottom: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment-header-text .post-meta &#123;</span><br><span class="line">        margin-left: 6px;</span><br><span class="line">    &#125;</span><br><span class="line">    .timeline-comment article p &#123;</span><br><span class="line">        margin: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">    .text-normal &#123;</span><br><span class="line">        font-weight: normal !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .f5 &#123;</span><br><span class="line">        font-size: 14px !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .submit-comment .btn &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        padding: 6px 12px;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">        font-weight: 600;</span><br><span class="line">        line-height: 20px;</span><br><span class="line">        white-space: nowrap;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">        -webkit-user-select: none;</span><br><span class="line">        -moz-user-select: none;</span><br><span class="line">        -ms-user-select: none;</span><br><span class="line">        user-select: none;</span><br><span class="line">        background-repeat: repeat-x;</span><br><span class="line">        background-position: -1px -1px;</span><br><span class="line">        background-size: 110% 110%;</span><br><span class="line">        border: 1px solid rgba(27,31,35,0.2);</span><br><span class="line">        border-radius: 0.25em;</span><br><span class="line">        -webkit-appearance: none;</span><br><span class="line">        -moz-appearance: none;</span><br><span class="line">        appearance: none;</span><br><span class="line">    &#125;</span><br><span class="line">    .submit-comment .btn-primary &#123;</span><br><span class="line">        color: #fff;</span><br><span class="line">        background-color: #28a745;</span><br><span class="line">        background-image: -webkit-linear-gradient(270deg, #34d058 0%, #28a745 90%);</span><br><span class="line">        background-image: linear-gradient(-180deg, #34d058 0%, #28a745 90%);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="4"><li><h5 id="修改-themes-next-layout-macro-post-swig"><a href="#修改-themes-next-layout-macro-post-swig" class="headerlink" title="修改/themes/next/layout/_macro/post.swig"></a>修改/themes/next/layout/_macro/post.swig</h5><p>在文件最后<code>&lt;/footer&gt;</code>前引入github_comments.swig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer class=&quot;post-footer&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &#123;% if page.commentIssueId %&#125;</span><br><span class="line">        &#123;% include &apos;../_partials/github_comments.swig&apos; %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="5"><li><h5 id="修改-themes-next-layout-partials-head-swig"><a href="#修改-themes-next-layout-partials-head-swig" class="headerlink" title="修改/themes/next/layout/_partials/head.swig"></a>修改/themes/next/layout/_partials/head.swig</h5><p>文件最后引入JQuery</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.commentIssueId %&#125;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ol><p><br><br><br></p><h2 id="总有一个适合你"><a href="#总有一个适合你" class="headerlink" title="总有一个适合你"></a>总有一个适合你</h2><hr><h3 id="选择真的太多了-先大概了解一下有哪些"><a href="#选择真的太多了-先大概了解一下有哪些" class="headerlink" title="选择真的太多了,先大概了解一下有哪些"></a>选择真的太多了,先大概了解一下有哪些</h3><ol><li><p>hexo已提供的选择</p><pre><code># Duoshuo ShortName  //多说...# Disqus ...# Hypercomments ...# changyan  //畅言...# Valine...#youyan_uid //友言...#livere_uid...# Gitment </code></pre></li></ol><p><br></p><ol start="2"><li><p>其他选择</p><p>网易云跟帖<br>来必力<br>Gitalk<br>Gitter<br>…</p></li></ol><p><a href="https://blog.shuiba.co/comment-systems-recommendation" target="_blank" rel="noopener">了解各种评论系统的利弊和效果预览&gt;&gt;</a></p><p><strong>But</strong>上面提到的个人都不太钟意~</p><p>一直在寻找!直到发现了<a href="http://wingjay.com/2017/06/08/rebuild-personal-blog/" target="_blank" rel="noopener"><strong>他</strong></a>！！是自己想要的效果！！</p><p><br><br><br></p><h2 id="独立Comments板块"><a href="#独立Comments板块" class="headerlink" title="独立Comments板块"></a>独立Comments板块</h2><hr><p>因为我的blog有背景图片，个人比较喜欢独立出来的效果，花了点时间满足自己的强迫症，<del>是自己瞎捉摸出来的</del>,不是唯一的办法。</p><ol><li><h5 id="修改-themes-next-layout-macro-post-swig-1"><a href="#修改-themes-next-layout-macro-post-swig-1" class="headerlink" title="修改/themes/next/layout/_macro/post.swig"></a>修改/themes/next/layout/_macro/post.swig</h5><p>删除之前引入github_comments.swig文件的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*删除*/</span><br><span class="line">&#123;% if page.commentIssueId %&#125;</span><br><span class="line">&#123;% include &apos;../_partials/github_comments.swig&apos; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">/*删除结束*/</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="2"><li><h5 id="新建GitHub-Issue-swig"><a href="#新建GitHub-Issue-swig" class="headerlink" title="新建GitHub_Issue.swig"></a>新建GitHub_Issue.swig</h5><p>在/themes/next/layout/_partials文件下新建GitHub_Issue.swig,并加入下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.commentIssueId %&#125;</span><br><span class="line">    &#123;% include &apos;../_partials/github_comments.swig&apos; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="3"><li><h5 id="修改-themes-next-layout-post-swig"><a href="#修改-themes-next-layout-post-swig" class="headerlink" title="修改/themes/next/layout/post.swig"></a>修改/themes/next/layout/post.swig</h5><p>在<span id="inline-green">block content</span>最后 <span id="inline-green">endblock</span> 之前引入GitHub_Issue.swig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">...</span><br><span class="line">    &#123;% include &apos;_partials/GitHub_Issue.swig&apos; %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="4"><li><h5 id="修改-themes-next-source-css-custom-custom-styl"><a href="#修改-themes-next-source-css-custom-custom-styl" class="headerlink" title="修改/themes/next/source/css/_custom/custom.styl"></a>修改/themes/next/source/css/_custom/custom.styl</h5>添加代码如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#comments&#123;</span><br><span class="line">    margin-top:20px;</span><br><span class="line">    padding: 40px;</span><br><span class="line">    background: white;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="5"><li><h5 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h5><img src="/img/Comments.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;添加评论功能-完结&quot;&gt;&lt;a href=&quot;#添加评论功能-完结&quot; class=&quot;headerlink&quot; title=&quot;添加评论功能   [完结]&quot;&gt;&lt;/a&gt;添加评论功能 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;可以手动添加issue，这样非常简单，但是如果文章越来越多，手动添加肯定不现实。因此可以写脚本来实现自动创建issue。由于本人并不想把别人的脚本直接搬过来，所以自动创建issue暂时被搁置…&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo" scheme="https://hotkang.cn/tags/Hexo/"/>
    
      <category term="博客" scheme="https://hotkang.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub Issue" scheme="https://hotkang.cn/tags/GitHub-Issue/"/>
    
      <category term="Next" scheme="https://hotkang.cn/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Github添加SSH密钥</title>
    <link href="https://hotkang.cn/2018/Github%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/"/>
    <id>https://hotkang.cn/2018/Github添加SSH密钥/</id>
    <published>2018-07-18T13:33:55.000Z</published>
    <updated>2018-08-03T10:00:23.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="添加SSH密钥-完结"><a href="#添加SSH密钥-完结" class="headerlink" title="添加SSH密钥 [完结]"></a>添加SSH密钥 <span style="font-size:.5em">[完结]</span></h2><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">GitHub Help</a></li><li><a href="http://www.cnblogs.com/ayseeing/p/3572582.html" target="_blank" rel="noopener">参考连接</a></li></ul><p>参考链接有整体的流程总结。跟着步骤来没有问题。但我会觉得GitHub Help比较官方？权威？</p></blockquote><hr><h2 id="一、查看现有的SSH密钥"><a href="#一、查看现有的SSH密钥" class="headerlink" title="一、查看现有的SSH密钥"></a>一、查看现有的SSH密钥</h2><pre><code>$ ls -al ~/.ssh</code></pre><p><br></p><h2 id="二、生成新SSH密钥"><a href="#二、生成新SSH密钥" class="headerlink" title="二、生成新SSH密钥"></a>二、生成新SSH密钥</h2><ol><li><h5 id="根据实际情况填写GitHub电子邮件地址"><a href="#根据实际情况填写GitHub电子邮件地址" class="headerlink" title="根据实际情况填写GitHub电子邮件地址"></a>根据实际情况填写GitHub电子邮件地址</h5><pre><code>$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; </code></pre></li><li><h5 id="文件生成位置"><a href="#文件生成位置" class="headerlink" title="文件生成位置"></a>文件生成位置</h5><pre><code>Enter file in which to save the key (/Users/hotkang/.ssh/id_rsa): [Press enter]  /*按回车默认文件位置*/</code></pre></li><li><h5 id="设置push密码"><a href="#设置push密码" class="headerlink" title="设置push密码"></a>设置push密码</h5><pre><code>Enter passphrase (empty for no passphrase):Enter same passphrase again: /*设置push文件时的密码,回车默认没有密码*/</code></pre></li></ol><p><br></p><h2 id="三、添加密钥到GitHub"><a href="#三、添加密钥到GitHub" class="headerlink" title="三、添加密钥到GitHub"></a>三、添加密钥到GitHub</h2><ol><li><h5 id="打开-ssh-id-rsa-pub-文件-将内容复制到剪贴板"><a href="#打开-ssh-id-rsa-pub-文件-将内容复制到剪贴板" class="headerlink" title="打开 /.ssh/id_rsa.pub 文件,将内容复制到剪贴板"></a>打开 /.ssh/id_rsa.pub 文件,将内容复制到剪贴板</h5></li><li><h5 id="单击右上角头像"><a href="#单击右上角头像" class="headerlink" title="单击右上角头像"></a>单击右上角头像</h5></li><li><h5 id="单击-Settings"><a href="#单击-Settings" class="headerlink" title="单击 Settings "></a>单击 <span id="inline-green">Settings</span></h5></li><li><h5 id="单击-SSH-and-GPG-keys"><a href="#单击-SSH-and-GPG-keys" class="headerlink" title="单击 SSH and GPG keys  "></a>单击 <span id="inline-green">SSH and GPG keys</span></h5></li><li><h5 id="单击-New-SSH-Key"><a href="#单击-New-SSH-Key" class="headerlink" title="单击 New SSH Key"></a>单击 <span id="inline-green">New SSH Key</span></h5></li><li><h5 id="填写Title并将-ssh-id-rsa-pub文件内容粘贴到Key"><a href="#填写Title并将-ssh-id-rsa-pub文件内容粘贴到Key" class="headerlink" title="填写Title并将/.ssh/id_rsa.pub文件内容粘贴到Key"></a>填写<span id="inline-green">Title</span>并将/.ssh/id_rsa.pub文件内容粘贴到<span id="inline-green">Key</span></h5></li><li><h5 id="单击Add-SSH-Key完成"><a href="#单击Add-SSH-Key完成" class="headerlink" title="单击Add SSH Key完成"></a>单击<span id="inline-green">Add SSH Key</span>完成</h5></li><li><h5 id="如果出现提示-请确认你的GitHub密码"><a href="#如果出现提示-请确认你的GitHub密码" class="headerlink" title="如果出现提示,请确认你的GitHub密码"></a>如果出现提示,请确认你的GitHub密码</h5></li></ol><p><br></p><h2 id="四、测试SSH连接"><a href="#四、测试SSH连接" class="headerlink" title="四、测试SSH连接"></a>四、测试SSH连接</h2><pre><code>$ ssh -T git@github.com</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;添加SSH密钥-完结&quot;&gt;&lt;a href=&quot;#添加SSH密钥-完结&quot; class=&quot;headerlink&quot; title=&quot;添加SSH密钥 [完结]&quot;&gt;&lt;/a&gt;添加SSH密钥 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://hotkang.cn/categories/GitHub/"/>
    
    
      <category term="SSH" scheme="https://hotkang.cn/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>我是置顶博文</title>
    <link href="https://hotkang.cn/2018/%E6%88%91%E6%98%AF%E7%BD%AE%E9%A1%B6%E5%8D%9A%E6%96%87/"/>
    <id>https://hotkang.cn/2018/我是置顶博文/</id>
    <published>2018-07-18T13:30:35.000Z</published>
    <updated>2018-12-06T05:05:08.319Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h2 id="❤️About-Blog"><a href="#❤️About-Blog" class="headerlink" title="❤️About Blog"></a>❤️About Blog</h2><p><br></p><p><strong>作为学习过程的记录总结。</strong></p><p><strong>最近动态↓↓↓↓↓↓</strong><br><strong>有好一段时间没有更新博客了，一直在笔试笔试面试面试，发现了自己很多不足，不断在反省自己。</strong><br><strong>继续加油吧！</strong></p><p><br></p></blockquote><p><br></p><hr><h2 id="❤️About-Link"><a href="#❤️About-Link" class="headerlink" title="❤️About Link"></a>❤️About Link</h2><p><strong>本站的参考链接都是自己过滤后的,可能来自各大官网文档、Others’s Blog、简书、掘金、社区或者外网。如果涉及到外网链接打不开也没有关系,可以参考我的文章。</strong></p><p><br></p><hr><h2 id="❤️About-Post"><a href="#❤️About-Post" class="headerlink" title="❤️About Post"></a>❤️About Post</h2><p><strong>本站文章主要由【 <del>优质</del> 参考文章】和【个人记录总结】构成; 网上资源玲琅满目,如果每个人都一篇篇筛选,浪费时间走弯路; 记录自己 <del>踩坑</del> 完成过程并在参考文章的基础上进行个人总结。</strong></p><p><br></p><hr><h2 id="❤️About-Comments"><a href="#❤️About-Comments" class="headerlink" title="❤️About Comments"></a>❤️About Comments</h2><p><strong>本站唯一的评论搭建在GitHub Issue上,点击<span id="inline-purple">Comment</span>跳转到博客文章对应的 Github issue 处,在 issue 下进行评论,文章展示时会实时获取数据。还在等什么❓❓【<a href="https://hotkang.cn/2018/%E6%88%91%E6%98%AF%E7%BD%AE%E9%A1%B6%E5%8D%9A%E6%96%87/#comments">测试</a>】一下❓❓</strong></p><p><br></p><hr><h2 id="❤️About-Count"><a href="#❤️About-Count" class="headerlink" title="❤️About Count"></a>❤️About Count</h2><p><strong>本站文章阅读统计用的是「 LeanCloud 」，站点人次统计、站点访问量统计用的「 不蒜子 」。</strong></p><p><strong>由于「 不蒜子 」的文章阅读量只在文章详情界面展示，但是我想在主页也展示文章阅读量，有点强迫症… 「 LeanCloud 」解决了这个问题。</strong></p><p>详看【<a href="https://hotkang.cn/2018/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E4%BA%8C/">用hexo搭建github博客二</a>】了解更多</p><p><br></p><h3 id="博客全部文章预览-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-About-Me-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-留言版"><a href="#博客全部文章预览-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-About-Me-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-留言版" class="headerlink" title="博客全部文章预览&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;About Me&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;留言版"></a><a href="https://hotkang.cn/archives/"><span id="inline-blue">博客全部文章预览</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://hotkang.cn/about/"><span id="inline-green">About Me</span></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://hotkang.cn/2018/%E6%88%91%E6%98%AF%E7%BD%AE%E9%A1%B6%E5%8D%9A%E6%96%87/#comments"><span id="inline-purple">留言版</span></a></h3><p><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h2 id=&quot;❤️About-Blog&quot;&gt;&lt;a href=&quot;#❤️About-Blog&quot; class=&quot;headerlink&quot; title=&quot;❤️About Blog&quot;&gt;&lt;/a&gt;❤️About Blog
      
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>在GitHub Pages上部署自己的简历</title>
    <link href="https://hotkang.cn/2018/%E5%9C%A8GitHub-Pages%E4%B8%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    <id>https://hotkang.cn/2018/在GitHub-Pages上部署自己的简历/</id>
    <published>2018-06-28T09:11:27.000Z</published>
    <updated>2018-10-25T05:41:01.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitHub-Pages-完结"><a href="#GitHub-Pages-完结" class="headerlink" title="GitHub Pages [完结]"></a>GitHub Pages <span style="font-size:.5em">[完结]</span></h2><blockquote><p>包含个人隐私信息(电话、照片)的简历不建议贴在网上哦~</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a></li></ul><p>看了很多教程,发现官网是说的最简洁明了又清楚的,最终解决了我的问题。建议打开<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>,两边参考着看更简单易懂。</p></blockquote><hr><h2 id="一、什么是GitHub-Pages"><a href="#一、什么是GitHub-Pages" class="headerlink" title="一、什么是GitHub Pages"></a>一、什么是GitHub Pages</h2><ol><li><p>GitHub Pages是一个静态站点托管服务,旨在直接从GitHub存储库托管我们的个人,组织或项目页面。不支持服务器端代码，例如PHP，Ruby或Python。</p></li><li><p>我们可以使用Jekyll Theme Chooser在线创建和发布GitHub Pages网站。我们也可以在本地工作，使用【GitHub Desktop】或【命令行】。</p></li></ol><blockquote><p>注意:</p><ol><li><p><strong><a href="https://desktop.github.com/" target="_blank" rel="noopener">GitHub Desktop</a></strong>:一个上传项目到github的软件。不想用命令行的不二选择。</p></li><li><p><strong><a href="https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/" target="_blank" rel="noopener">命令行</a></strong>:指使用git命令上传项目</p></li></ol><p>PS:不会命令行没关系，谁敢说自己连一个软件都不会用呀？</p></blockquote><p><br></p><h2 id="二、GitHub-Pages-提供什么"><a href="#二、GitHub-Pages-提供什么" class="headerlink" title="二、GitHub Pages 提供什么"></a>二、GitHub Pages 提供什么</h2><p>在官网上有这样一句话:</p><pre><code>You get one site per GitHub account and organization,and unlimited project sites. </code></pre><p>意思是:</p><pre><code>GitHub Pages为每个GitHub帐户/组织提供一个【站点】,以及无限制的【项目站点】。</code></pre><blockquote><p>注意:</p><ol><li><p>我们只能有一个【<code>User or organization site</code>】;但是我们可以有很多【<code>Project site</code>】。</p></li><li><p>部署简历用【<code>User or organization site</code>】简直是大材小用,用【<code>Project site</code>】就可以了。</p></li><li><p>【<code>User or organization site</code>】可以拿来部署个人博客,点击<a href="https://hotyan.github.io/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/" target="_blank" rel="noopener">用hexo搭建github博客</a>了解如何搭建个人博客。</p></li></ol></blockquote><p><br></p><h2 id="三、准备工作"><a href="#三、准备工作" class="headerlink" title="三、准备工作"></a>三、准备工作</h2><ol><li><h5 id="默认已有GitHub账号-并已创建好存储库或会创建存储库。"><a href="#默认已有GitHub账号-并已创建好存储库或会创建存储库。" class="headerlink" title="默认已有GitHub账号,并已创建好存储库或会创建存储库。"></a>默认已有GitHub账号,并已创建好存储库或会创建存储库。</h5><ul><li><p>没有<code>GitHub</code>账号？？<a href="https://github.com/" target="_blank" rel="noopener">点击注册</a></p></li><li><p>没有存储库？？<a href="https://help.github.com/articles/creating-a-new-repository/" target="_blank" rel="noopener">了解如何创建</a></p></li></ul></li><li><h5 id="默认已有html简历-命名为-index-html"><a href="#默认已有html简历-命名为-index-html" class="headerlink" title="默认已有html简历,命名为 index.html"></a>默认已有html简历,命名为 index.html</h5><ul><li>没有简历？？<a href="http://cv.qiaobutang.com/" target="_blank" rel="noopener">制作并下载</a></li></ul></li></ol><p><br></p><h2 id="四、简历部署"><a href="#四、简历部署" class="headerlink" title="四、简历部署"></a>四、简历部署</h2><ol><li><h5 id="创建新存储库"><a href="#创建新存储库" class="headerlink" title="创建新存储库"></a>创建新存储库</h5><ul><li><p>点击右上角 <strong>+</strong> 选择 <strong><code>New repository</code></strong></p></li><li><p>填写 <strong><code>Repository name</code></strong> 并勾选 <strong><code>Initialize this repository with a README</code></strong></p></li><li>点击 <strong><code>Create repository</code></strong> 完成创建</li></ul></li><li><h5 id="上传简历"><a href="#上传简历" class="headerlink" title="上传简历"></a>上传简历</h5><ul><li><p>在新建的存储库点击 <strong><code>Upload files</code></strong></p></li><li><p>点击 <strong><code>choose your files</code></strong> 上传你的 <strong><code>index.html</code></strong> 文件</p></li><li>点击 <strong><code>Commit changes</code></strong> 完成上传</li></ul></li><li><h5 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h5><ul><li><p>点击 <strong><code>Settings</code></strong> 下滑到 <strong><code>GitHub Pages</code></strong> 部分</p></li><li><p>修改 <strong><code>Source</code></strong> 为 <strong><code>master branch</code></strong> 并点击 <strong><code>Save</code></strong></p></li><li>再次下滑到 <strong><code>GitHub Pages</code></strong> 部分就会看到一个链接</li></ul></li><li><h5 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h5><ul><li><p>如果不成功,再次修改 <strong><code>Source</code></strong> 为 <strong><code>master branch</code></strong> 并点击 <strong><code>Save</code></strong></p></li><li><p>点击链接就可以看到部署的简历</p></li><li><p>将简历链接写在你的<code>README.md</code>或者任何地方</p></li></ul></li></ol><p><br></p><h2 id="五、创建【User-or-organization-site】"><a href="#五、创建【User-or-organization-site】" class="headerlink" title="五、创建【User or organization site】"></a>五、创建【User or organization site】</h2><p>跟创建一般存储库流程一样,只是因为我们每个用户只有一个【<code>User or organization site</code>】,所以存储库的名称比较唯一,必须是<strong><code>username.github.io</code></strong> 格式,其中<code>username</code>是我们在<code>GitHub</code>上的用户名或组织名称</p><p>如果不正确则不起作用，因此请确保正确无误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GitHub-Pages-完结&quot;&gt;&lt;a href=&quot;#GitHub-Pages-完结&quot; class=&quot;headerlink&quot; title=&quot;GitHub Pages [完结]&quot;&gt;&lt;/a&gt;GitHub Pages &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;包含个人隐私信息(电话、照片)的简历不建议贴在网上哦~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://hotkang.cn/categories/GitHub/"/>
    
    
      <category term="GitHub Pages" scheme="https://hotkang.cn/tags/GitHub-Pages/"/>
    
      <category term="简历" scheme="https://hotkang.cn/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>CSS_属性继承</title>
    <link href="https://hotkang.cn/2018/CSS-%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF/"/>
    <id>https://hotkang.cn/2018/CSS-属性继承/</id>
    <published>2018-06-21T10:29:02.000Z</published>
    <updated>2018-08-18T17:34:10.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-属性继承-待完善"><a href="#CSS-属性继承-待完善" class="headerlink" title="CSS_属性继承 [待完善]"></a>CSS_属性继承 <span style="font-size:.5em">[待完善]</span></h2><blockquote><p>哪些属性可继承？？呃。。。往下看。</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://www.cnblogs.com/thislbq/p/5882105.html" target="_blank" rel="noopener">参考链接</a></li><li><a href="http://www.runoob.com/cssref/css-reference.html" target="_blank" rel="noopener">CSS 参考手册</a></li><li><a href="https://www.w3schools.com/cssref/css3_pr_align-content.asp" target="_blank" rel="noopener">CSS Properties</a></li></ul></blockquote><hr><h2 id="一、无继承性的属性"><a href="#一、无继承性的属性" class="headerlink" title="一、无继承性的属性"></a>一、<strong>无继承性</strong>的属性</h2><h3 id="1-display"><a href="#1-display" class="headerlink" title="1. display"></a>1. display</h3><p>定义元素生成的框的类型,下面是常用的属性值:</p><table><thead><tr><th style="text-align:center">display值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">inherit</td><td style="text-align:left">继承父元素 display 属性的值</td></tr><tr><td style="text-align:center"><strong>none</strong></td><td style="text-align:left">不会被显示</td></tr><tr><td style="text-align:center"><strong>block</strong></td><td style="text-align:left">块级元素，前后会带有换行符</td></tr><tr><td style="text-align:center"><strong>inline</strong></td><td style="text-align:left">默认。内联元素，前后没有换行符</td></tr><tr><td style="text-align:center"><strong>inline-block</strong></td><td style="text-align:left">行内块元素</td></tr></tbody></table><h3 id="2-文本属性-部分属性无继承性"><a href="#2-文本属性-部分属性无继承性" class="headerlink" title="2. 文本属性[部分属性无继承性]"></a>2. 文本属性[部分属性无继承性]</h3><table><thead><tr><th style="text-align:center">文本属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">vertical-align</td><td style="text-align:left">垂直文本对齐</td></tr><tr><td style="text-align:center">text-decoration</td><td style="text-align:left">规定添加到文本的装饰</td></tr><tr><td style="text-align:center">text-shadow</td><td style="text-align:left">文本阴影效果</td></tr><tr><td style="text-align:center">white-space</td><td style="text-align:left">空白符的处理</td></tr><tr><td style="text-align:center">unicode-bidi</td><td style="text-align:left">设置文本的方向</td></tr></tbody></table><p></p><h3 id="3-盒子模型"><a href="#3-盒子模型" class="headerlink" title="3.盒子模型"></a>3.盒子模型</h3><table><thead><tr><th style="text-align:center">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">width/height</td><td style="text-align:left">宽/高</td></tr><tr><td style="text-align:center">margin: top right bottom left</td><td style="text-align:left">[上右下左]外边距</td></tr><tr><td style="text-align:center">padding: top right bottom left</td><td style="text-align:left">[上右下左]内边距</td></tr><tr><td style="text-align:center">border: top right bottom left</td><td style="text-align:left">[上右下左]边框</td></tr><tr><td style="text-align:center">border-[top/right/bottom/left]-style</td><td style="text-align:left">边框[上右下左]样式</td></tr><tr><td style="text-align:center">border-[top/right/bottom/left]-width</td><td style="text-align:left">边框[上右下左]宽度</td></tr><tr><td style="text-align:center">border-[top/right/bottom/left]-color</td><td style="text-align:left">边框[上右下左]颜色</td></tr></tbody></table><h3 id="4-背景属性-均无继承性"><a href="#4-背景属性-均无继承性" class="headerlink" title="4.背景属性[均无继承性]"></a>4.背景属性[均无继承性]</h3><table><thead><tr><th style="text-align:center">背景属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">background</td><td style="text-align:left">[颜色/图片/位置/大小/重复/原点/素材/附件]</td></tr><tr><td style="text-align:center">background-color</td><td style="text-align:left">颜色</td></tr><tr><td style="text-align:center">background-image</td><td style="text-align:left">图片</td></tr><tr><td style="text-align:center">background-position</td><td style="text-align:left">位置</td></tr><tr><td style="text-align:center">background-size</td><td style="text-align:left">大小</td></tr><tr><td style="text-align:center">background-repeat</td><td style="text-align:left">重复</td></tr><tr><td style="text-align:center">background-origin</td><td style="text-align:left">指定原点位置</td></tr><tr><td style="text-align:center">background-clip</td><td style="text-align:left">背景(颜色或图像)应在元素内延伸的距离</td></tr><tr><td style="text-align:center">background-attachment</td><td style="text-align:left">背景图像是否与页面的其余部分一起滚动,或者是否已修复。</td></tr></tbody></table><h3 id="5-定位属性"><a href="#5-定位属性" class="headerlink" title="5.定位属性"></a>5.定位属性</h3><table><thead><tr><th style="text-align:center">定位属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:left">指定元素应该如何浮动</td></tr><tr><td style="text-align:center">clear</td><td style="text-align:left">指定元素浮动元素的哪些边不允许浮动</td></tr><tr><td style="text-align:center">position</td><td style="text-align:left">指定用于元素的定位方法的类型(static/relative/absolute/fixed/sticky)</td></tr><tr><td style="text-align:center">top/bottom</td><td style="text-align:left">影响定位元素的垂直位置</td></tr><tr><td style="text-align:center">left/right</td><td style="text-align:left">影响定位元素的水平位置</td></tr><tr><td style="text-align:center">min-[width/height]</td><td style="text-align:left">定义了元素的最小宽度/高度</td></tr><tr><td style="text-align:center">max-[width/height]</td><td style="text-align:left">定义了元素的最大宽度/高度</td></tr><tr><td style="text-align:center">overflow</td><td style="text-align:left">溢出</td></tr><tr><td style="text-align:center">clip</td><td style="text-align:left">指定一个矩形来剪切绝对定位的元素</td></tr><tr><td style="text-align:center">z-index</td><td style="text-align:left">指定元素的堆栈顺序</td></tr></tbody></table><h3 id="6-生成内容属性"><a href="#6-生成内容属性" class="headerlink" title="6.生成内容属性"></a>6.生成内容属性</h3><table><thead><tr><th style="text-align:center">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">content</td><td style="text-align:left">::before和::after伪元素一起使用,以插入生成的内容</td></tr><tr><td style="text-align:center">counter-reset</td><td style="text-align:left">创建或重置一个或多个CSS计数器</td></tr><tr><td style="text-align:center">counter-increment</td><td style="text-align:left">增加或减少一个或多个CSS计数器的值</td></tr></tbody></table><h3 id="7-轮廓属性"><a href="#7-轮廓属性" class="headerlink" title="7.轮廓属性"></a>7.轮廓属性</h3><table><thead><tr><th style="text-align:center">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">outline</td><td style="text-align:left">轮廓[宽度/*样式/颜色]</td></tr><tr><td style="text-align:center">outline-style</td><td style="text-align:left">样式</td></tr><tr><td style="text-align:center">outline-width</td><td style="text-align:left">宽度</td></tr><tr><td style="text-align:center">outline-color</td><td style="text-align:left">颜色</td></tr></tbody></table><h3 id="8-打印属性"><a href="#8-打印属性" class="headerlink" title="8.打印属性"></a>8.打印属性</h3><table><thead><tr><th style="text-align:center">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">size</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">page-break-before</td><td style="text-align:left">元素之前添加分页符</td></tr><tr><td style="text-align:center">page-break-after</td><td style="text-align:left">元素后添加分页符</td></tr><tr><td style="text-align:center">page-break-inside</td><td style="text-align:left">指定元素内避免分页符</td></tr></tbody></table><h3 id="9-声音样式属性"><a href="#9-声音样式属性" class="headerlink" title="9.声音样式属性"></a>9.声音样式属性</h3><table><thead><tr><th style="text-align:center">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">pause-before</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">pause-after</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">pause</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">cue-before</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">cue-after</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">cue</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">play-during</td><td style="text-align:left"></td></tr></tbody></table><h2 id="二、有继承性的属性"><a href="#二、有继承性的属性" class="headerlink" title="二、有继承性的属性"></a>二、<strong>有继承性</strong>的属性</h2><h3 id="1-字体系列属性-均继承"><a href="#1-字体系列属性-均继承" class="headerlink" title="1.字体系列属性[均继承]"></a>1.字体系列属性[均继承]</h3><table><thead><tr><th style="text-align:center">字体属性</th><th style="text-align:left"> 描述</th></tr></thead><tbody><tr><td style="text-align:center">font</td><td style="text-align:left">[*size/* family/weight/style]</td></tr><tr><td style="text-align:center">font-style</td><td style="text-align:left">样式</td></tr><tr><td style="text-align:center">font-variant</td><td style="text-align:left">变形</td></tr><tr><td style="text-align:center">font-weight</td><td style="text-align:left">粗细</td></tr><tr><td style="text-align:center">font-size/line-height</td><td style="text-align:left">尺寸</td></tr><tr><td style="text-align:center">font-family</td><td style="text-align:left">字体系列</td></tr><tr><td style="text-align:center">font-stretch</td><td style="text-align:left">对字体进行伸缩变形</td></tr><tr><td style="text-align:center">font-size-adjust</td><td style="text-align:left">更好地控制字体大小。</td></tr></tbody></table><h3 id="2-文本属性-部分继承"><a href="#2-文本属性-部分继承" class="headerlink" title="2. 文本属性[部分继承]"></a>2. 文本属性[部分继承]</h3><table><thead><tr><th style="text-align:center">文本属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">text-indent</td><td style="text-align:left">文本缩进</td></tr><tr><td style="text-align:center">text-align</td><td style="text-align:left">文本水平对齐</td></tr><tr><td style="text-align:center">line-height</td><td style="text-align:left">行高</td></tr><tr><td style="text-align:center">word-spacing</td><td style="text-align:left">增加或减少<strong>单词间</strong>的空白（即字间隔）</td></tr><tr><td style="text-align:center">letter-spacing</td><td style="text-align:left">增加或减少<strong>字符间</strong>的空白（字符间距）</td></tr><tr><td style="text-align:center">text-transform</td><td style="text-align:left">控制文本大小写</td></tr><tr><td style="text-align:center">direction</td><td style="text-align:left">规定文本的书写方向</td></tr><tr><td style="text-align:center">color</td><td style="text-align:left">文本颜色</td></tr></tbody></table><h3 id="3-visibility"><a href="#3-visibility" class="headerlink" title="3.visibility"></a>3.visibility</h3><h3 id="4-表格布局属性"><a href="#4-表格布局属性" class="headerlink" title="4.表格布局属性"></a>4.表格布局属性</h3><table><thead><tr><th style="text-align:center">表格布局属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">aption-side</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">border-collapse</td><td style="text-align:left">表格边框是应折叠为单个边框还是按标准HTML分隔</td></tr><tr><td style="text-align:center">border-spacing</td><td style="text-align:left">相邻单元格边界之间的距离</td></tr><tr><td style="text-align:center">empty-cells</td><td style="text-align:left">是否在表格中的空单元格上显示边框</td></tr><tr><td style="text-align:center">table-layout</td><td style="text-align:left">布置表格单元格，行和列的算法</td></tr></tbody></table><h3 id="5-列表布局属性-均继承"><a href="#5-列表布局属性-均继承" class="headerlink" title="5.列表布局属性[均继承]"></a>5.列表布局属性[均继承]</h3><table><thead><tr><th style="text-align:center">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">list-style</td><td style="text-align:left">[type/image/position]</td></tr><tr><td style="text-align:center">list-style-type</td><td style="text-align:left">类型</td></tr><tr><td style="text-align:center">list-style-image</td><td style="text-align:left">图像</td></tr><tr><td style="text-align:center">list-style-position</td><td style="text-align:left">位置[inside/outside/initial/inherit];</td></tr></tbody></table><h3 id="6-引用属性-quotes"><a href="#6-引用属性-quotes" class="headerlink" title="6.引用属性:quotes"></a>6.引用属性:quotes</h3><p>引用的引号类型:none|string|initial|inherit;</p><h3 id="7-鼠标光标-cursor"><a href="#7-鼠标光标-cursor" class="headerlink" title="7.鼠标光标:cursor"></a>7.鼠标光标:cursor</h3><h3 id="8-打印属性-1"><a href="#8-打印属性-1" class="headerlink" title="8.打印属性"></a>8.打印属性</h3><table><thead><tr><th style="text-align:center">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">page</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">windows</td><td style="text-align:left">发生分页时必须在页面<strong>顶部</strong>保留的最少行数</td></tr><tr><td style="text-align:center">orphans</td><td style="text-align:left">生分页时必须在页面<strong>底部</strong>保留的最少行数</td></tr></tbody></table><h3 id="9-声音样式属性-1"><a href="#9-声音样式属性-1" class="headerlink" title="9.声音样式属性"></a>9.声音样式属性</h3><table><thead><tr><th style="text-align:center">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">speak</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">speak-punctuation</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">speak-numeral</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">speak-header</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">speech-rate</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">volume</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">voice-family</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">pitch</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">pitch-range</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">stress</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">richness</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">azimuth</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">elevation</td><td style="text-align:left"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS-属性继承-待完善&quot;&gt;&lt;a href=&quot;#CSS-属性继承-待完善&quot; class=&quot;headerlink&quot; title=&quot;CSS_属性继承 [待完善]&quot;&gt;&lt;/a&gt;CSS_属性继承 &lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;哪些属性可继承？？呃。。。往下看。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="CSS" scheme="https://hotkang.cn/tags/CSS/"/>
    
      <category term="属性继承" scheme="https://hotkang.cn/tags/%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统四</title>
    <link href="https://hotkang.cn/2018/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9B%9B/"/>
    <id>https://hotkang.cn/2018/图书管理系统四/</id>
    <published>2018-06-19T15:49:33.000Z</published>
    <updated>2018-10-25T05:40:08.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现具体功能-完结"><a href="#实现具体功能-完结" class="headerlink" title="实现具体功能 [完结]"></a>实现具体功能 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>所有的功能实现都在写在这里了。</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://www.alloyteam.com/2015/03/sexpressmysql/" target="_blank" rel="noopener">参考教程1</a></li><li><a href="https://www.xiabingbao.com/node/2017/02/20/node-express-forum.html" target="_blank" rel="noopener">参考教程2</a>(划重点!)</li></ul><p>虽然前期看了教程1之后，功能没有实现，但是给教程2奠定一定的知识储备,建议都看看。</p></blockquote><hr><h2 id="了解整体架构"><a href="#了解整体架构" class="headerlink" title="了解整体架构"></a>了解整体架构</h2><p>仔细看看<a href="http://blog.fens.me/nodejs-express4/" target="_blank" rel="noopener">Node.js开发框架Express4.x</a> 下的以下部分</p><pre><code>2. 目录结构3. package.json项目配置4. app.js核心文件5.Bootstrap界面框架(选看,里面涉及到的重复代码前面讲过)6. 路由功能</code></pre><p><br></p><h2 id="完成注册-登录"><a href="#完成注册-登录" class="headerlink" title="完成注册/登录"></a>完成注册/登录</h2><p>看了很多网上的教程吧,只有<a href="https://www.xiabingbao.com/node/2017/02/20/node-express-forum.html" target="_blank" rel="noopener">参考教程2</a>让我成功了,作者写的也非常用心超级仔细！！！！我只跟着敲了用户注册登录,后面基本很顺畅~</p><p><br></p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>看了所有推荐的链接,基本上就没有什么问题啦。靠谱的教程让我们少走弯路,少踏坑。</p><p><br><br><br></p><h2 id="项目具体细节记录"><a href="#项目具体细节记录" class="headerlink" title="项目具体细节记录"></a>项目具体细节记录</h2><hr><h2 id="一、保持用户登录状态-app-js"><a href="#一、保持用户登录状态-app-js" class="headerlink" title="一、保持用户登录状态(app.js)"></a>一、保持用户登录状态(app.js)</h2><ol><li><h5 id="加载依赖库"><a href="#加载依赖库" class="headerlink" title="加载依赖库"></a>加载依赖库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cookieParser = require(&apos;cookie-parser&apos;);  </span><br><span class="line">var session = require(&apos;express-session&apos;);</span><br></pre></td></tr></table></figure></li><li><h5 id="定义cookie解析器"><a href="#定义cookie解析器" class="headerlink" title="定义cookie解析器"></a>定义cookie解析器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(cookieParser());</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    secret: &apos;hotyan&apos;,  // 用来对session id相关的cookie进行签名</span><br><span class="line">    saveUninitialized: true,  // 是否自动保存未初始化的会话，建议false</span><br><span class="line">    resave: false,  // 是否每次都重新保存会话，建议false</span><br><span class="line">    cookie: &#123;maxAge:  60*60 * 1000 &#125; // 有效期，单位是毫秒</span><br><span class="line">    &#125;))</span><br></pre></td></tr></table></figure></li><li><h5 id="在app-js文件下添加自定义中间件-实现保持用户登录状态"><a href="#在app-js文件下添加自定义中间件-实现保持用户登录状态" class="headerlink" title="在app.js文件下添加自定义中间件,实现保持用户登录状态"></a>在app.js文件下添加自定义中间件,实现保持用户登录状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.use(function(req, res, next)&#123;</span><br><span class="line">    // 如果session中存在，则说明已经登录</span><br><span class="line">    if( req.session.hotyan )&#123;</span><br><span class="line">        res.locals.hotyan = &#123;</span><br><span class="line">            UserId : req.session.hotyan.UserId,</span><br><span class="line">            UserName : req.session.hotyan.UserName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.locals.hotyan = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    next();//此处必须有</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="二、数据库连接"><a href="#二、数据库连接" class="headerlink" title="二、数据库连接"></a>二、数据库连接</h2><ul><li><h5 id="在-models-下新建-db-js"><a href="#在-models-下新建-db-js" class="headerlink" title="在 models 下新建 db.js"></a>在 models 下新建 <code>db.js</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var mysql = require(&apos;mysql&apos;);</span><br><span class="line">var pool = mysql.createPool(&#123;</span><br><span class="line">    host: &apos;localhost&apos;,</span><br><span class="line">    user: &apos;root&apos;,</span><br><span class="line">    password: &apos;XXXXXX&apos;,</span><br><span class="line">    database: &apos;XXXXXX&apos;</span><br><span class="line">&#125;);</span><br><span class="line">module.exports = pool;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="三、Mysql语句"><a href="#三、Mysql语句" class="headerlink" title="三、Mysql语句"></a>三、Mysql语句</h2><ul><li><h5 id="以对图书管理员进行增删改查为例"><a href="#以对图书管理员进行增删改查为例" class="headerlink" title="以对图书管理员进行增删改查为例"></a>以对图书管理员进行增删改查为例</h5><p>方法总结于教程2,新建(SQL/adminSql.js)文件,将需要的Mysql语句全部独立出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//对bookadmin进行增删改查</span><br><span class="line">var admin = &#123;</span><br><span class="line">    /**添加图书管理员 */</span><br><span class="line">    insert :&apos;INSERT INTO `bookadmin` SET `BAId`=?, `BAName`=? ,`BAPassword`=?,`BAPhone`=?,`BAEmail`=?&apos;,</span><br><span class="line">    </span><br><span class="line">    /**修改图书管理员信息 */</span><br><span class="line">    update : &apos;UPDATE `bookadmin` SET `BAName`=? ,`BAPhone`=?,`BAEmail`=? WHERE `BAId`=?&apos;,</span><br><span class="line">    </span><br><span class="line">    /**删除图书管理员 */</span><br><span class="line">    delete: &apos;DELETE FROM `bookadmin` WHERE `BAId`=?&apos;,</span><br><span class="line">    </span><br><span class="line">    /**精确查看图书管理员信息 */</span><br><span class="line">    queryById : &apos;SELECT * FROM `bookadmin` WHERE `BAId`=?&apos;,</span><br><span class="line">    </span><br><span class="line">    /**查看全部图书管理员信息 */</span><br><span class="line">    queryAll : &apos;SELECT * FROM `bookadmin` &apos;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = admin;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h2><p>实现功能的函数放置在<code>models/users.js</code></p><ol><li><h5 id="加载依赖文件"><a href="#加载依赖文件" class="headerlink" title="加载依赖文件"></a>加载依赖文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var pool = require(&apos;./db&apos;), // 连接数据库</span><br><span class="line">    admin = require(&apos;../SQL/adminSql&apos;),//图书管理员的Mysql语句</span><br><span class="line">    crypto = require(&apos;crypto&apos;); // 对密码进行加密</span><br></pre></td></tr></table></figure></li><li><h5 id="以添加图书管理员为例学习如何使用封装的函数"><a href="#以添加图书管理员为例学习如何使用封装的函数" class="headerlink" title="以添加图书管理员为例学习如何使用封装的函数"></a>以添加图书管理员为例学习如何使用封装的函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">adminadd: function (BAId, BAName, BAPassword, BAPhone, BAEmail, cb) &#123;</span><br><span class="line">    pool.getConnection(function (err, connection) &#123;</span><br><span class="line">        if (err) throw err;</span><br><span class="line"></span><br><span class="line">            connection.query(admin.insert, [BAId, BAName, BAPassword, BAPhone, BAEmail], function (err, result) &#123;</span><br><span class="line">                if (err) throw err;</span><br><span class="line">                    cb(result);</span><br><span class="line">                    connection.release();</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此处应了解一下query()方法,参数可2可3,query(mysql语句,内容数组,回调函数）;我把Mysql语句独立了出去,看了教程2就知道。</p></li></ol><p><br></p><h2 id="五、表单提交POST请求"><a href="#五、表单提交POST请求" class="headerlink" title="五、表单提交POST请求"></a>五、表单提交POST请求</h2><ul><li><h5 id="以添加图书管理员为例"><a href="#以添加图书管理员为例" class="headerlink" title="以添加图书管理员为例:"></a>以添加图书管理员为例:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/badAddAdmin&quot; method=&quot;POST&quot; class=&quot;ad_data&quot;&gt;//注意1</span><br><span class="line">    &lt;div class=&quot;data&quot;&gt;</span><br><span class="line">        &lt;label&gt;管理号&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;输入图书管理员编号&quot; name=&quot;BAId&quot; /&gt;//注意2</span><br><span class="line">    &lt;/div&gt;   </span><br><span class="line">    ...     </span><br><span class="line">    &lt;div class=&quot;data&quot;&gt;</span><br><span class="line">        &lt;label&gt;邮箱&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;输入图书管理员邮箱&quot; name=&quot;BAEmail&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;input class=&quot;add_btn&quot; type=&quot;submit&quot; value=&quot;确认添加&quot; /&gt;//注意3    </span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>注意三个地方:</p><ol><li><code>action=&quot;/badAddAdmin&quot; method=&quot;POST&quot;</code></li><li><code>name=&quot;BAId&quot;</code></li><li><code>type=&quot;submit&quot;</code></li></ol></li></ul><p><br></p><h2 id="六、添加POST代码"><a href="#六、添加POST代码" class="headerlink" title="六、添加POST代码"></a>六、添加POST代码</h2><ul><li><h5 id="以添加图书管理员界面为例-routes-index-js"><a href="#以添加图书管理员界面为例-routes-index-js" class="headerlink" title="以添加图书管理员界面为例(routes/index.js):"></a>以添加图书管理员界面为例(<code>routes/index.js</code>):</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.post(&apos;/badAddAdmin&apos;, function (req, res, next) &#123;</span><br><span class="line">/*获取表单传来的数据*/</span><br><span class="line">    var BAId = req.body.BAId || &apos;&apos;,</span><br><span class="line">        BAName = req.body.BAName || &apos;&apos;,</span><br><span class="line">        BAPassword = req.body.BAPassword || &apos;&apos;,</span><br><span class="line">        BAPhone = req.body.BAPhone || &apos;&apos;,</span><br><span class="line">        BAEmail = req.body.BAEmail || &apos;&apos;;</span><br><span class="line">    /*调用密码加密函数*/</span><br><span class="line">    var password_hash = user_m.hash(BAPassword);</span><br><span class="line">    /*调用添加图书管理员函数*/</span><br><span class="line">    user_m.adminadd(BAId, BAName, password_hash, BAPhone, BAEmail, function (result) &#123;</span><br><span class="line">        console.log(&quot;添加成功&quot;);</span><br><span class="line">        res.redirect(&apos;/badAddAdmin&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="七、EJS循环渲染"><a href="#七、EJS循环渲染" class="headerlink" title="七、EJS循环渲染"></a>七、EJS循环渲染</h2><ol><li><h5 id="在-routes-index-js-中加入"><a href="#在-routes-index-js-中加入" class="headerlink" title="在(routes/index.js)中加入:"></a>在(<code>routes/index.js</code>)中加入:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.post(&apos;/badCheckAdmin&apos;, function (req, res, next) &#123;</span><br><span class="line">    console.log(req.body);</span><br><span class="line">    var BAId = req.body.BAId;</span><br><span class="line">    user_m.adminId(BAId, function (result) &#123;</span><br><span class="line">        console.log(&quot;精确查看成功&quot;);</span><br><span class="line">        res.render(&apos;badCheckAdmin&apos;, &#123;</span><br><span class="line">            title: &apos;查看图书管理员信息&apos;,</span><br><span class="line">            datas: result     //返回json数据,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>返回json数据,需要依赖模块body-parser,此处应了解一下res.render()</p></li><li><h5 id="在-views-badCheckAdmin-ejs-中渲染代码"><a href="#在-views-badCheckAdmin-ejs-中渲染代码" class="headerlink" title="在(views/badCheckAdmin.ejs)中渲染代码:"></a>在(views/badCheckAdmin.ejs)中渲染代码:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line">    &lt;% for(var i=0;i&lt; datas.length;i++)&#123; %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td &gt;&lt;%= datas[i].BAId %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= datas[i].BAName %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= datas[i].BAPhone %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%= datas[i].BAEmail %&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;% &#125;%&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="八、日期格式YYYY-MM-DD"><a href="#八、日期格式YYYY-MM-DD" class="headerlink" title="八、日期格式YYYY-MM-DD"></a>八、日期格式YYYY-MM-DD</h2><ul><li><h5 id="在-routes-index-js-文件中"><a href="#在-routes-index-js-文件中" class="headerlink" title="在(routes/index.js)文件中:"></a>在(routes/index.js)文件中:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*加载依赖模块*/</span><br><span class="line">var time = require(&apos;silly-datetime&apos;)</span><br><span class="line"></span><br><span class="line">/*在需要的地方使用,以注册时间为例*/</span><br><span class="line">RegTime = time.format(new Date(), &apos;YYYY-MM-DD&apos;);</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="九、图书应该归还日期-30天后"><a href="#九、图书应该归还日期-30天后" class="headerlink" title="九、图书应该归还日期(30天后)"></a>九、图书应该归还日期(30天后)</h2><ol><li><h5 id="在-models-users-js-中添加date方法"><a href="#在-models-users-js-中添加date方法" class="headerlink" title="在(models/users.js)中添加date方法:"></a>在(models/users.js)中添加date方法:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">date: function (AddDay) &#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    /*****获取AddDay天后的日期 ********/</span><br><span class="line">    date.setDate(date.getDate() + AddDay);</span><br><span class="line"></span><br><span class="line">    var Y = date.getFullYear(),</span><br><span class="line"></span><br><span class="line">    /***** 获取当前月份的日期，不足10补0 *****/</span><br><span class="line">        M = (date.getMonth() + 1) &lt; 10 ? &quot;0&quot; + (date.getMonth() + 1) : (date.getMonth() + 1),</span><br><span class="line"></span><br><span class="line">        /****获取当前几号，不足10补0  ****/</span><br><span class="line">        D = date.getDate() &lt; 10 ? &quot;0&quot; + date.getDate() : date.getDate();</span><br><span class="line"></span><br><span class="line">    return Y + &quot;-&quot; + M + &quot;-&quot; + D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="在-routes-index-js-借书界面调用date方法"><a href="#在-routes-index-js-借书界面调用date方法" class="headerlink" title="在(routes/index.js)借书界面调用date方法:"></a>在(routes/index.js)借书界面调用date方法:</h5><pre><code>var ShouldTime = user_m.date(30);</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现具体功能-完结&quot;&gt;&lt;a href=&quot;#实现具体功能-完结&quot; class=&quot;headerlink&quot; title=&quot;实现具体功能 [完结]&quot;&gt;&lt;/a&gt;实现具体功能 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;所有的功能实现都在写在这里了。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql命令小结</title>
    <link href="https://hotkang.cn/2018/Mysql%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>https://hotkang.cn/2018/Mysql命令小结/</id>
    <published>2018-06-19T14:04:20.000Z</published>
    <updated>2018-07-26T18:16:42.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql语句-持续完善"><a href="#Mysql语句-持续完善" class="headerlink" title="Mysql语句 [持续完善]"></a>Mysql语句 <span style="font-size:.5em">[持续完善]</span></h2><blockquote><p>常用命令小结</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://juejin.im/post/5ae55861f265da0ba062ec71" target="_blank" rel="noopener">参考链接</a></li></ul></blockquote><hr><h2 id="一、DATABASE"><a href="#一、DATABASE" class="headerlink" title="一、DATABASE"></a>一、DATABASE</h2><p>新建数据库：</p><pre><code>CREATE DATABASE database_name;</code></pre><p>删除数据库：</p><pre><code>DROP DATABASE database_name;</code></pre><p>查看所有可用的数据库：</p><pre><code>SHOW DATABASES;  </code></pre><p>选择数据库：</p><pre><code>USE database_name;</code></pre><p>显示数据库服务器的状态信息：</p><pre><code>SHOW STATUS;  </code></pre><p>获取当前所选的数据库中所有可用的表：</p><pre><code>SHOW TABLES; </code></pre><p>获取表中所有列的信息：</p><pre><code>SHOW COLUMNS FROM table_name; </code></pre><p><br></p><h2 id="二、TABLE"><a href="#二、TABLE" class="headerlink" title="二、TABLE"></a>二、TABLE</h2><p>新建表:</p><pre><code>CREATE TABLE table_name;</code></pre><p>删除表,使用DROP TABLE子句:</p><pre><code>DROP TABLE table_name。</code></pre><p>清空表中记录:</p><pre><code>delete from table_name;</code></pre><p>显示表中的记录:</p><pre><code>select * from table_name;</code></pre><p><br></p><h2 id="三、导入导出"><a href="#三、导入导出" class="headerlink" title="三、导入导出"></a>三、导入导出</h2><p>导入.sql</p><pre><code>source .sql文件路径</code></pre><p>备份数据,导出.sql文件</p><pre><code>cd 存放目录mysqldump -u root_name -p database_name&gt;file_name.sql例如:mysqldump -u root -p hotyan&gt;db.sql</code></pre><p>退出MYSQL命令:</p><pre><code>exit(回车)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mysql语句-持续完善&quot;&gt;&lt;a href=&quot;#Mysql语句-持续完善&quot; class=&quot;headerlink&quot; title=&quot;Mysql语句 [持续完善]&quot;&gt;&lt;/a&gt;Mysql语句 &lt;span style=&quot;font-size:.5em&quot;&gt;[持续完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;常用命令小结&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/Mysql/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统三</title>
    <link href="https://hotkang.cn/2018/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%89/"/>
    <id>https://hotkang.cn/2018/图书管理系统三/</id>
    <published>2018-06-11T15:24:23.000Z</published>
    <updated>2018-10-25T05:40:03.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Use-Homebre-Install-Mysql-完结"><a href="#Use-Homebre-Install-Mysql-完结" class="headerlink" title="Use Homebre Install Mysql [完结]"></a>Use Homebre Install Mysql <span style="font-size:.5em">[完结]</span></h2><blockquote><p>安装Mysql,你可能会进入Mysql官网,下载安装适合你自己电脑的版本,我用的Mac,所以我继续看了一下在【macOS上安装MySQL】,然后就跟着操作,结果不成功,解决不了？？？卸载试试？？？重新安装,依旧失败~</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/installing.html" target="_blank" rel="noopener">Mysql官网</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/osx-installation.html" target="_blank" rel="noopener">在macOS上安装MySQL</a></li><li><a href="https://brew.sh/" target="_blank" rel="noopener">homebrew官网</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html" target="_blank" rel="noopener">本文参考链接</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/MySql/index.html" target="_blank" rel="noopener">YouTube视频教程</a>(划重点,是这个视频让我成功的！！！)</li></ul></blockquote><hr><h2 id="一、安装homebrew"><a href="#一、安装homebrew" class="headerlink" title="一、安装homebrew"></a>一、安装homebrew</h2><p>请参考<a href="https://hotyan.github.io/2018/use%20homebrew%20install%20mongodb" target="_blank" rel="noopener">Mac Use Homebrew Install Mongodb</a>,那里有详细记录,这边不再赘述</p><p><br></p><h2 id="二、安装Mysql"><a href="#二、安装Mysql" class="headerlink" title="二、安装Mysql"></a>二、安装Mysql</h2><ol><li><h5 id="终端下运行以下命令"><a href="#终端下运行以下命令" class="headerlink" title="终端下运行以下命令"></a>终端下运行以下命令</h5><pre><code>$ brew install mysql</code></pre><p>【暂时忽略你看到的一些提示！！！】</p></li><li><h5 id="启动Mysql服务器"><a href="#启动Mysql服务器" class="headerlink" title="启动Mysql服务器"></a>启动Mysql服务器</h5><p>先把服务器start再说</p><pre><code>$ brew services start mysql</code></pre><p>【现在可以跟着你看到的提示一步一步来！！！】</p></li><li><h5 id="先安全登录Mysql"><a href="#先安全登录Mysql" class="headerlink" title="先安全登录Mysql"></a>先安全登录Mysql</h5><p>运行提示一:</p><pre><code>$ mysql_secure_installation  </code></pre><ul><li><p>根据提示设置user root密码</p><pre><code>Enter password for user root：（此处输入你的密码）</code></pre></li><li><p>根据提示进行设置</p><pre><code>可一路yes</code></pre></li><li><p>设置完后，你会看到提示</p><pre><code>All done！</code></pre></li></ul></li><li><h5 id="连接Mysql"><a href="#连接Mysql" class="headerlink" title="连接Mysql"></a>连接Mysql</h5><p>运行提示二:</p><pre><code>$ mysql -uroot</code></pre><p>或者</p><pre><code>$ mysql -u root -p    </code></pre><p>回车后,输入刚刚设置的密码：</p><pre><code>Enter password：</code></pre></li><li><h5 id="success！"><a href="#success！" class="headerlink" title="success！"></a>success！</h5><p>成功之后,就可以对Mysql进行操作啦</p></li><li><h5 id="退出mysql"><a href="#退出mysql" class="headerlink" title="退出mysql"></a>退出mysql</h5><pre><code>mysql&gt; exitBye</code></pre></li><li><h5 id="关闭mysql服务器"><a href="#关闭mysql服务器" class="headerlink" title="关闭mysql服务器"></a>关闭mysql服务器</h5><pre><code>$ brew services start mysql</code></pre></li><li><h5 id="配置-bash-profile"><a href="#配置-bash-profile" class="headerlink" title="配置.bash_profile"></a>配置.bash_profile</h5><p>先查看你的mysql安装在哪:</p><pre><code>$ which mysql</code></pre><p>比如我返回的是:</p><pre><code>/usr/local/Cellar/mysql/5.7.22/bin/mysql</code></pre><p>打开.bash_profile文件:</p><pre><code>$ open ~/.bash_profile</code></pre><p>将下面这行代码加入.bash_profile文件:</p><pre><code>export PATH=&quot;/usr/local/Cellar/mysql/5.7.22/bin:$PATH&quot;</code></pre><p>保存,退出后,保存新配置:</p><pre><code>$ source ~/.bash_profile</code></pre></li><li><h5 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h5><p>开启服务器:</p><pre><code>$ brew services start mysql</code></pre><p>登录Mysql:</p><pre><code>$ mysql -u root -p</code></pre><p>操作Mysql:</p><p>【<a href="https://hotyan.github.io/2018/Mysql%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">Mysql指令小结</a> 】</p><p>退出Mysql:</p><pre><code>mysql&gt;exitBye</code></pre><p>关闭服务器:</p><pre><code>$ brew services stop mysql</code></pre></li><li><h5 id="基本完成"><a href="#基本完成" class="headerlink" title="基本完成"></a>基本完成</h5><p>其实我遇到过很多问题，也尝试解决，Google了很多，并没有很成功的解决问题，课设期间时间也比较有限，所以在尝试解决不成功后，出现问题我选择卸载，重新安装~</p><p>根据上面打开流程，基本不会再出差啦</p></li></ol><p><br></p><h2 id="三、卸载Mysql"><a href="#三、卸载Mysql" class="headerlink" title="三、卸载Mysql"></a>三、卸载Mysql</h2><ol><li><h5 id="打开终端-依次输入"><a href="#打开终端-依次输入" class="headerlink" title="打开终端,依次输入"></a>打开终端,依次输入</h5><pre><code>$ brew remove mysql$ brew cleanup$ sudo rm /usr/local/mysql$ sudo rm -rf /usr/local/var/mysql$ sudo rm -rf /usr/local/mysql*$ sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ sudo rm -rf /Library/StartupItems/MySQLCOM$ sudo rm -rf /Library/PreferencePanes/My*</code></pre></li><li><h5 id="查看是否成功"><a href="#查看是否成功" class="headerlink" title="查看是否成功"></a>查看是否成功</h5><pre><code>$ mysql</code></pre><p>提示mysql 没有发现，多半就可以了。（其实我也不确定哈，只是我这样就可以~）</p></li><li><h5 id="最后重启电脑重新安装即可"><a href="#最后重启电脑重新安装即可" class="headerlink" title="最后重启电脑重新安装即可"></a>最后重启电脑重新安装即可</h5></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Use-Homebre-Install-Mysql-完结&quot;&gt;&lt;a href=&quot;#Use-Homebre-Install-Mysql-完结&quot; class=&quot;headerlink&quot; title=&quot;Use Homebre Install Mysql [完结]&quot;&gt;&lt;/a&gt;Use Homebre Install Mysql &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;安装Mysql,你可能会进入Mysql官网,下载安装适合你自己电脑的版本,我用的Mac,所以我继续看了一下在【macOS上安装MySQL】,然后就跟着操作,结果不成功,解决不了？？？卸载试试？？？重新安装,依旧失败~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Install" scheme="https://hotkang.cn/categories/Install/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/categories/Install/Mysql/"/>
    
    
      <category term="Homebrew" scheme="https://hotkang.cn/tags/Homebrew/"/>
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
      <category term="Node.js" scheme="https://hotkang.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统二</title>
    <link href="https://hotkang.cn/2018/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BA%8C/"/>
    <id>https://hotkang.cn/2018/图书管理系统二/</id>
    <published>2018-06-11T15:24:16.000Z</published>
    <updated>2018-10-25T05:39:57.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EJS模板引擎-完结"><a href="#EJS模板引擎-完结" class="headerlink" title="EJS模板引擎 [完结]"></a>EJS模板引擎 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>初步渲染页面~</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">EJS官网</a></li></ul></blockquote><hr><h2 id="一、首先来了解一下项目结构"><a href="#一、首先来了解一下项目结构" class="headerlink" title="一、首先来了解一下项目结构"></a>一、首先来了解一下项目结构</h2><pre><code>.├── app.js  //程序启动文件├── bin│   └── www├── package.json  //项目依赖配置及开发者信息├── public        //静态文件(存css,js,img)│   ├── images│   ├── javascripts│   └── stylesheets│       └── style.css├── routes          //路由文件│   ├── index.js│   └── users.js└── views           //页面文件(ejs模板)    ├── error.ejs    ├── index.ejs    └── layout.ejs</code></pre><p><br></p><h2 id="二、渲染界面"><a href="#二、渲染界面" class="headerlink" title="二、渲染界面"></a>二、渲染界面</h2><ol><li><h5 id="对views文件夹进行操作"><a href="#对views文件夹进行操作" class="headerlink" title="对views文件夹进行操作:"></a>对views文件夹进行操作:</h5><pre><code>在现有的首页index.ejs里面加入你的首页界面代码新建注册界面reg.ejs,并加入该界面代码新建登录界面login.ejs,并加入该界面代码...</code></pre></li></ol><p><br></p><ol start="2"><li><h5 id="对routes文件夹进行操作"><a href="#对routes文件夹进行操作" class="headerlink" title="对routes文件夹进行操作"></a>对routes文件夹进行操作</h5><p>在<code>index.js</code>文件里面分别渲染<code>index.ejs</code>、<code>reg.ejs</code> 、<code>login.ejs</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.render(&apos;index&apos;, &#123;</span><br><span class="line">        title: &apos;index&apos;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/reg&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.render(&apos;reg&apos;, &#123;</span><br><span class="line">        title: &apos;reg&apos;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/login&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.render(&apos;login&apos;, &#123;</span><br><span class="line">        title: &apos;login&apos;</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="3"><li><h5 id="将相同代码独立出来"><a href="#将相同代码独立出来" class="headerlink" title="将相同代码独立出来"></a>将相同代码独立出来</h5><p>比如我的(基本资料/修改资料/借书/还书/借阅记录)这5个界面,上半部分是重复代码。</p><p>新建<code>TopBar.ejs</code>,放置重复代码,在其他五个界面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- include TopBar %&gt;</span><br></pre></td></tr></table></figure><p>所有重复代码以此类推</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;EJS模板引擎-完结&quot;&gt;&lt;a href=&quot;#EJS模板引擎-完结&quot; class=&quot;headerlink&quot; title=&quot;EJS模板引擎 [完结]&quot;&gt;&lt;/a&gt;EJS模板引擎 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;初步渲染页面~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
      <category term="Express" scheme="https://hotkang.cn/tags/Express/"/>
    
      <category term="EJS" scheme="https://hotkang.cn/tags/EJS/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统一</title>
    <link href="https://hotkang.cn/2018/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%80/"/>
    <id>https://hotkang.cn/2018/图书管理系统一/</id>
    <published>2018-06-11T15:24:02.000Z</published>
    <updated>2018-10-25T05:39:48.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-完结"><a href="#Express-完结" class="headerlink" title="Express [完结]"></a>Express <span style="font-size:.5em">[完结]</span></h2><blockquote><p>图书管理系统大家应该都不陌生~<br>老师对大一的说：写一个图书管理系统吧？！！！<br>老师对大二的说：写一个图书管理系统！！！！<br>老师对大三的说：写一个图书管理系统！<br>大一的图书管理系统VS大三的图书管理系统？？</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><h3 id="个人比较喜欢先甩参考链接-可以选择直接去看参考链接。"><a href="#个人比较喜欢先甩参考链接-可以选择直接去看参考链接。" class="headerlink" title="个人比较喜欢先甩参考链接,可以选择直接去看参考链接。"></a>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</h3><ul><li><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">Express官网</a></li></ul></blockquote><hr><p>首先默认你已经安装了 Node.js,没有装的可以参考<a href="https://hotkang.cn/2018/%E7%94%A8nvm%E8%A3%85node-js">用nvm装node.js</a></p><h2 id="一、为你的应用创建一个目录（-hotyan）"><a href="#一、为你的应用创建一个目录（-hotyan）" class="headerlink" title="一、为你的应用创建一个目录（/hotyan）"></a>一、为你的应用创建一个目录（/hotyan）</h2><pre><code>$ mkdir hotyan</code></pre><p><br></p><h2 id="二、进入此目录并将其作为当前工作目录"><a href="#二、进入此目录并将其作为当前工作目录" class="headerlink" title="二、进入此目录并将其作为当前工作目录"></a>二、进入此目录并将其作为当前工作目录</h2><pre><code>$ cd hotyan</code></pre><p><br></p><h2 id="三、install-Express应用生成器"><a href="#三、install-Express应用生成器" class="headerlink" title="三、install Express应用生成器"></a>三、install Express应用生成器</h2><p>通过应用生成器工具 express 可以快速创建一个应用的骨架。</p><p>通过如下命令安装：</p><pre><code>$ npm install express-generator -g</code></pre><p><br></p><h2 id="四、创建工作项目"><a href="#四、创建工作项目" class="headerlink" title="四、创建工作项目"></a>四、创建工作项目</h2><p>当前工作目录下（/hotyan）创建一个命名为 Librarys 的工作项目。</p><pre><code>$ express --view=ejs  Libraryscreate : Librarys/create : Librarys/public/create : Librarys/public/javascripts/create : Librarys/public/images/create : Librarys/public/stylesheets/create : Librarys/public/stylesheets/style.csscreate : Librarys/routes/create : Librarys/routes/index.jscreate : Librarys/routes/users.jscreate : Librarys/views/create : Librarys/views/error.ejscreate : Librarys/views/index.ejscreate : Librarys/app.jscreate : Librarys/package.jsoncreate : Librarys/bin/create : Librarys/bin/wwwchange directory:    $ cd Librarysinstall dependencies:    $ npm installrun the app:    $ DEBUG=librarys:* npm start</code></pre><p><br></p><h2 id="五、进入Library并安装依赖包"><a href="#五、进入Library并安装依赖包" class="headerlink" title="五、进入Library并安装依赖包"></a>五、进入Library并安装依赖包</h2><pre><code>$ cd Librarys$ npm install</code></pre><p><br></p><h2 id="六、启动这个项目（MacOS-或-Linux-平台）"><a href="#六、启动这个项目（MacOS-或-Linux-平台）" class="headerlink" title="六、启动这个项目（MacOS 或 Linux 平台）"></a>六、启动这个项目（MacOS 或 Linux 平台）</h2><pre><code>$ DEBUG=librarys:* npm start</code></pre><p><br></p><h2 id="七、在浏览器打开-http-localhost-3000"><a href="#七、在浏览器打开-http-localhost-3000" class="headerlink" title="七、在浏览器打开 http://localhost:3000/"></a>七、在浏览器打开 <code>http://localhost:3000/</code></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Express-完结&quot;&gt;&lt;a href=&quot;#Express-完结&quot; class=&quot;headerlink&quot; title=&quot;Express [完结]&quot;&gt;&lt;/a&gt;Express &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;图书管理系统大家应该都不陌生~&lt;br&gt;老师对大一的说：写一个图书管理系统吧？！！！&lt;br&gt;老师对大二的说：写一个图书管理系统！！！！&lt;br&gt;老师对大三的说：写一个图书管理系统！&lt;br&gt;大一的图书管理系统VS大三的图书管理系统？？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Express" scheme="https://hotkang.cn/tags/Express/"/>
    
      <category term="EJS" scheme="https://hotkang.cn/tags/EJS/"/>
    
      <category term="Node.js" scheme="https://hotkang.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>用nvm装node.js</title>
    <link href="https://hotkang.cn/2018/%E7%94%A8nvm%E8%A3%85node-js/"/>
    <id>https://hotkang.cn/2018/用nvm装node-js/</id>
    <published>2018-05-30T14:23:44.000Z</published>
    <updated>2018-08-03T16:42:39.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于node安装-完结"><a href="#关于node安装-完结" class="headerlink" title="关于node安装  [完结]"></a>关于node安装 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>本地安装？全局安装？nvm安装？傻傻分不清楚？<br>使用 nvm 管理不同版本的 node 与 npm</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li>了解<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">NVM</a></li><li>了解<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></li><li>了解<a href="https://nodejs.org/en/download/package-manager/" target="_blank" rel="noopener">通过包管理器安装Node.js</a>NVM部分</li><li>了解<a href="https://www.npmjs.com/get-npm" target="_blank" rel="noopener">NPM</a></li><li><a href="https://www.runoob.com/w3cnote/nvm-manager-node-versions.html" target="_blank" rel="noopener">本文参考链接</a></li></ul></blockquote><hr><h2 id="一、卸载全局安装的-node"><a href="#一、卸载全局安装的-node" class="headerlink" title="一、卸载全局安装的 node"></a>一、卸载全局安装的 node</h2><p>在官网下载的 node 安装包,运行后会自动安装在全局目录,使用过程中经常会遇到一些权限问题,用以下方法卸载全局安装的 node。(不需要卸载则跳过此步骤)</p><ol><li><h5 id="删除-node-和-node-modules-相关的文件和文件夹"><a href="#删除-node-和-node-modules-相关的文件和文件夹" class="headerlink" title="删除 node 和 node_modules 相关的文件和文件夹"></a>删除 node 和 node_modules 相关的文件和文件夹</h5><p>打开Finder,按 shift+command+G 来打开前往文件夹的窗口,分别进入下列目录,删除 node 和 node_modules 相关的文件和文件夹</p><pre><code>/usr/local/lib/usr/local/include</code></pre></li><li><h5 id="如果你是使用的-brew-install-node-安装的-还需要在终端中执行以下命令来卸载"><a href="#如果你是使用的-brew-install-node-安装的-还需要在终端中执行以下命令来卸载" class="headerlink" title="如果你是使用的 brew install node 安装的,还需要在终端中执行以下命令来卸载"></a>如果你是使用的 brew install node 安装的,还需要在终端中执行以下命令来卸载</h5><pre><code>$ brew uninstall node </code></pre></li><li><h5 id="检查-node-和-node-modules-相关文件-文件夹是否删除成功"><a href="#检查-node-和-node-modules-相关文件-文件夹是否删除成功" class="headerlink" title="检查 node 和 node_modules 相关文件/文件夹是否删除成功"></a>检查 node 和 node_modules 相关文件/文件夹是否删除成功</h5><p>检查个人主文件夹下面的所有的 local、lib 以及 include 文件夹，并且删除所有与 node 和 node_modules 相关的文件以及文件夹</p></li><li><h5 id="进入-usr-local-bin-并删除-node-可执行文件"><a href="#进入-usr-local-bin-并删除-node-可执行文件" class="headerlink" title="进入 /usr/local/bin 并删除 node 可执行文件"></a>进入 /usr/local/bin 并删除 node 可执行文件</h5></li></ol><ol start="5"><li><h5 id="你可能还需要在终端中输入一些额外的指令"><a href="#你可能还需要在终端中输入一些额外的指令" class="headerlink" title="你可能还需要在终端中输入一些额外的指令"></a>你可能还需要在终端中输入一些额外的指令</h5><pre><code>$ sudo rm /usr/local/bin/npm$ sudo rm /usr/local/share/man/man1/node.1$ sudo rm /usr/local/lib/dtrace/node.d$ sudo rm -rf ~/.npm$ sudo rm -rf ~/.node-gyp$ sudo rm /opt/local/bin/node$ sudo rm /opt/local/include/node$ sudo rm -rf /opt/local/lib/node_modules</code></pre></li></ol><p><br></p><h2 id="二、OSX-安装-NVM"><a href="#二、OSX-安装-NVM" class="headerlink" title="二、OSX 安装 NVM"></a>二、OSX 安装 NVM</h2><ul><li><h5 id="用-X-Code-的命令行工具"><a href="#用-X-Code-的命令行工具" class="headerlink" title="用 X-Code 的命令行工具"></a>用 X-Code 的命令行工具</h5><p>运行以下命令</p><pre><code>$ xcode-select --install$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</code></pre></li></ul><p><br></p><h2 id="三、安装多版本-node"><a href="#三、安装多版本-node" class="headerlink" title="三、安装多版本 node"></a>三、安装多版本 node</h2><ul><li><h5 id="查看远程服务器上所有的可用版本"><a href="#查看远程服务器上所有的可用版本" class="headerlink" title="查看远程服务器上所有的可用版本"></a>查看远程服务器上所有的可用版本</h5><pre><code>$ nvm ls-remote</code></pre></li><li><h5 id="安装最新版-Node"><a href="#安装最新版-Node" class="headerlink" title="安装最新版 Node"></a>安装最新版 Node</h5><pre><code>$ nvm install node </code></pre></li><li><h5 id="安装某一版本-4-2-2"><a href="#安装某一版本-4-2-2" class="headerlink" title="安装某一版本(4.2.2)"></a>安装某一版本(4.2.2)</h5><pre><code>$ nvm install 4.2.2</code></pre></li><li><h5 id="安装4-2-系列的最新的一个版本"><a href="#安装4-2-系列的最新的一个版本" class="headerlink" title="安装4.2 系列的最新的一个版本"></a>安装4.2 系列的最新的一个版本</h5><pre><code>$ nvm install 4.2</code></pre></li></ul><p>nvm 遵守语义化版本命名规则,nvm 会寻找 4.2.x 中最高的版本来安装。</p><p><br></p><h2 id="四、在不同版本间切换"><a href="#四、在不同版本间切换" class="headerlink" title="四、在不同版本间切换"></a>四、在不同版本间切换</h2><p>每当安装了一个新版本 Node 后,全局环境会自动把这个新版本设置为默认。</p><ul><li><h5 id="nvm-提供-nvm-use-命令用于版本切换"><a href="#nvm-提供-nvm-use-命令用于版本切换" class="headerlink" title="nvm 提供 nvm use 命令用于版本切换"></a>nvm 提供 nvm use 命令用于版本切换</h5><ul><li><h5 id="切换到最新版："><a href="#切换到最新版：" class="headerlink" title="切换到最新版："></a>切换到最新版：</h5><pre><code>$ nvm use node</code></pre></li><li><h5 id="切换到-4-2-2："><a href="#切换到-4-2-2：" class="headerlink" title="切换到 4.2.2："></a>切换到 4.2.2：</h5><pre><code>$ nvm use 4.2.2</code></pre></li><li><h5 id="切换到最新的-4-2-x："><a href="#切换到最新的-4-2-x：" class="headerlink" title="切换到最新的 4.2.x："></a>切换到最新的 4.2.x：</h5><pre><code>$ nvm use 4.2</code></pre><p>每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。</p></li></ul></li></ul><p><br></p><h2 id="五、用-nvm-给不同的版本号设置别名"><a href="#五、用-nvm-给不同的版本号设置别名" class="headerlink" title="五、用 nvm 给不同的版本号设置别名"></a>五、用 nvm 给不同的版本号设置别名</h2><ul><li><h5 id="给4-2-2-版本号起个别名hotyan-version"><a href="#给4-2-2-版本号起个别名hotyan-version" class="headerlink" title="给4.2.2 版本号起个别名hotyan-version"></a>给4.2.2 版本号起个别名hotyan-version</h5><pre><code>$ nvm alias hotyan-version 4.2.2</code></pre></li><li><h5 id="运行"><a href="#运行" class="headerlink" title="运行:"></a>运行:</h5><pre><code>$ nvm use hotyan-version</code></pre></li><li><h5 id="取消别名："><a href="#取消别名：" class="headerlink" title="取消别名："></a>取消别名：</h5><pre><code>$ nvm unalias hotyan-version  </code></pre></li></ul><p><br></p><h2 id="六、列出已安装实例"><a href="#六、列出已安装实例" class="headerlink" title="六、列出已安装实例"></a>六、列出已安装实例</h2><pre><code>$ nvm ls</code></pre><p><br></p><h2 id="七、确认某个版本Node的路径"><a href="#七、确认某个版本Node的路径" class="headerlink" title="七、确认某个版本Node的路径"></a>七、确认某个版本Node的路径</h2><pre><code>$ nvm which 4.2.2</code></pre><p><br></p><h2 id="八、检查是否成功安装node和npm"><a href="#八、检查是否成功安装node和npm" class="headerlink" title="八、检查是否成功安装node和npm"></a>八、检查是否成功安装node和npm</h2><p>当成功下载Node.js时,会自动安装npm。</p><ul><li><h5 id="检查Node"><a href="#检查Node" class="headerlink" title="检查Node:"></a>检查Node:</h5><pre><code>$ node -v</code></pre></li><li><h5 id="确认npm"><a href="#确认npm" class="headerlink" title="确认npm:"></a>确认npm:</h5><pre><code>$ npm -v</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于node安装-完结&quot;&gt;&lt;a href=&quot;#关于node安装-完结&quot; class=&quot;headerlink&quot; title=&quot;关于node安装  [完结]&quot;&gt;&lt;/a&gt;关于node安装 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;本地安装？全局安装？nvm安装？傻傻分不清楚？&lt;br&gt;使用 nvm 管理不同版本的 node 与 npm&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Install" scheme="https://hotkang.cn/categories/Install/"/>
    
      <category term="Node.js" scheme="https://hotkang.cn/categories/Install/Node-js/"/>
    
    
      <category term="Node.js" scheme="https://hotkang.cn/tags/Node-js/"/>
    
      <category term="NVM" scheme="https://hotkang.cn/tags/NVM/"/>
    
      <category term="NPM" scheme="https://hotkang.cn/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>用hexo搭建github博客二</title>
    <link href="https://hotkang.cn/2018/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E4%BA%8C/"/>
    <id>https://hotkang.cn/2018/用hexo搭建github博客二/</id>
    <published>2018-05-29T07:39:01.000Z</published>
    <updated>2018-10-25T05:39:34.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优化博客-持续完善"><a href="#优化博客-持续完善" class="headerlink" title="优化博客 [持续完善]"></a>优化博客 <span style="font-size:.5em">[持续完善]</span></h2><blockquote><p>搜索了很多Next主题的效果，总结了自己比较喜欢或者已运用到Blog的效果~</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next使用文档</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">参考链接1</a></li><li><a href="https://www.jianshu.com/p/efbeddc5eb19" target="_blank" rel="noopener">参考链接2</a></li><li><a href="https://www.vincentqin.tech/posts/build-a-website-using-hexo/" target="_blank" rel="noopener">参考链接3</a></li><li><a href="http://devinol.com/Hexo/Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E4%B8%89/" target="_blank" rel="noopener">参考链接4</a></li><li><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题</a></li></ul></blockquote><hr><h2 id="一、修改Next主题模式"><a href="#一、修改Next主题模式" class="headerlink" title="一、修改Next主题模式"></a>一、修改Next主题模式</h2><ol><li><h5 id="修改themes-next-config-yml文件Schemes属性"><a href="#修改themes-next-config-yml文件Schemes属性" class="headerlink" title="修改themes/next/_config.yml文件Schemes属性"></a>修改themes/next/_config.yml文件Schemes属性</h5><p>注意不要跟根目录下的_config.yml混淆</p><pre><code># Schemes# scheme: Muse   # scheme: Mist  scheme: Pisces# scheme: Gemini</code></pre><p>NexT主题默认使用Muse模式,根据自己的喜好选择。</p><p><del>我比较喜欢Pisces ,对源码做了些样式修改。</del></p><p>后来我喜欢上了<code>Gemini</code>。<code>Gemini</code>跟<code>Pisce</code>相似,而且<code>Gemini</code>的源码样式是在<code>Pisce</code>的基础上重写的。</p></li></ol><p><br></p><ol start="2"><li><h5 id="更新Hexo部署"><a href="#更新Hexo部署" class="headerlink" title="更新Hexo部署"></a>更新Hexo部署</h5><p>每次修改后都可以更新部署,也可最后再一次性部署。后面不再赘述。</p><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo clean    // 清理缓存$ hexo generate // 生成文件$ hexo deploy   // 线上部署/*简写如下*/$ hexo clean$ hexo g$ hexo d</code></pre></li></ol><p><br></p><h2 id="二、设置首页预览摘要"><a href="#二、设置首页预览摘要" class="headerlink" title="二、设置首页预览摘要"></a>二、设置首页预览摘要</h2><p>了解一下官网【Next使用文档】【<a href="https://theme-next.iissnan.com/faqs.html#read-more" target="_blank" rel="noopener">如何设置阅读全文</a>】介绍的三种方法</p><p>我使用的是用<code>&lt;!-- more --&gt;</code>进行手动截断</p><p><br></p><h2 id="三、侧边栏显示效果"><a href="#三、侧边栏显示效果" class="headerlink" title="三、侧边栏显示效果"></a>三、侧边栏显示效果</h2><ul><li><h5 id="修改themes-next-config-yml文件sidebar属性"><a href="#修改themes-next-config-yml文件sidebar属性" class="headerlink" title="修改themes/next/_config.yml文件sidebar属性"></a>修改themes/next/_config.yml文件sidebar属性</h5><pre><code>sidebar:    # Sidebar Position, available value: left | right (only for Pisces | Gemini).      position: left    # position: right //修改侧边栏位置    # Sidebar Display, available value (only for Muse | Mist):    #  - post    expand on posts automatically. Default.    #  - always  expand for all pages automatically    #  - hide    expand only when click on the sidebar toggle icon.    #  - remove  Totally remove sidebar including sidebar toggle.    # display: post      //默认      display: always     //一直显示    # display: hide      //初始隐藏    # display: remove    //移除侧边栏</code></pre><p>根据提示,设置自己喜欢的样式,我是Pisces主题,设置侧边栏在左边,且一直显示。</p></li></ul><p><br></p><h2 id="四、侧边栏社交链接"><a href="#四、侧边栏社交链接" class="headerlink" title="四、侧边栏社交链接"></a>四、侧边栏社交链接</h2><ul><li><h5 id="修改themes-next-config-yml文件social属性"><a href="#修改themes-next-config-yml文件social属性" class="headerlink" title="修改themes/next/_config.yml文件social属性"></a>修改themes/next/_config.yml文件social属性</h5><pre><code>/*文字链接*/social:    GitHub: https://github.com/hotYan || github    E-Mail: mailto:hotyann@163.com || envelope/*链接前图标*/social_icons:    enable: true    GitHub: github </code></pre><p>我只添加了GitHub、E-Mail。</p></li></ul><p><br></p><h2 id="五、设置RSS"><a href="#五、设置RSS" class="headerlink" title="五、设置RSS"></a>五、设置RSS</h2><ol><li><h5 id="安装-hexo-generator-feed-插件"><a href="#安装-hexo-generator-feed-插件" class="headerlink" title="安装 hexo-generator-feed 插件"></a>安装 hexo-generator-feed 插件</h5><p>RSS需要有一个Feed链接，而这个链接需要靠hexo-generator-feed插件来生成</p><pre><code>$ cd HotYan_Blog$ npm install hexo-generator-feed --save</code></pre></li></ol><p><br></p><ol start="2"><li><h5 id="修改-config-yml文件"><a href="#修改-config-yml文件" class="headerlink" title="修改/_config.yml文件"></a>修改/_config.yml文件</h5><pre><code>#type: RSS的类型(atom/rss2)#path: 文件路径,默认是atom.xml/rss2.xml#limit:展示文章的数量,使用0或则false代表展示全部#RSS订阅插件feed:     type: atom    path: atom.xml    limit: 0#RSS订阅支持plugins: hexo-generate-feed</code></pre></li></ol><p><br></p><ol start="3"><li><h5 id="修改themes-next-config-yml文件rss属性"><a href="#修改themes-next-config-yml文件rss属性" class="headerlink" title="修改themes/next/_config.yml文件rss属性"></a>修改themes/next/_config.yml文件rss属性</h5><pre><code>rss: /atom.xml </code></pre></li></ol><p><br></p><h2 id="六、添加菜单选项"><a href="#六、添加菜单选项" class="headerlink" title="六、添加菜单选项"></a>六、添加菜单选项</h2><p>默认情况下，菜单导航栏有首页、归档、关于三个选项，我们可以自行添加</p><ol><li><h5 id="修改themes-next-config-yml文件menu属性"><a href="#修改themes-next-config-yml文件menu属性" class="headerlink" title="修改themes/next/_config.yml文件menu属性"></a>修改themes/next/_config.yml文件menu属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">    home: / || home                //默认有</span><br><span class="line">    about: /about/ || user         // 默认有</span><br><span class="line">    tags: /tags/ || tags            //自行添加</span><br><span class="line">    categories: /categories/ || th  //自行添加</span><br><span class="line">    archives: /archives/ || archive   //默认有</span><br></pre></td></tr></table></figure><p>比如我添加了tags、categories</p></li></ol><p><br></p><ol start="2"><li><h5 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h5><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo new page &quot;tags&quot;$ hexo new page &quot;categories&quot;</code></pre></li></ol><p><br></p><ol start="3"><li><h5 id="修改index-md"><a href="#修改index-md" class="headerlink" title="修改index.md"></a>修改<code>index.md</code></h5><p>在/source/目录下创建了categories、tags文件夹,在这些文件夹中分别会创建一个index.md文件,对内容type进行修改，使之分别为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-05-29 00:02:39</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-05-29 00:02:54</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="七、修改文章底部标签样式"><a href="#七、修改文章底部标签样式" class="headerlink" title="七、修改文章底部标签样式"></a>七、修改文章底部标签样式</h2><ul><li><h5 id="修改-themes-next-layout-macro-post-swig文件"><a href="#修改-themes-next-layout-macro-post-swig文件" class="headerlink" title="修改/themes/next/layout/_macro/post.swig文件"></a>修改/themes/next/layout/_macro/post.swig文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;post-tags&quot;&gt;  </span><br><span class="line">        &#123;% for tag in post.tags %&#125;</span><br><span class="line">                &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p></li></ul><p><br></p><h2 id="八、文章末尾添加结束标记"><a href="#八、文章末尾添加结束标记" class="headerlink" title="八、文章末尾添加结束标记"></a>八、文章末尾添加结束标记</h2><ol><li><h5 id="在-themes-next-layout-macro新建passage-end-tag-swig"><a href="#在-themes-next-layout-macro新建passage-end-tag-swig" class="headerlink" title="在/themes/next/layout/_macro新建passage-end-tag.swig"></a>在/themes/next/layout/_macro新建passage-end-tag.swig</h5><p>添加以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt; - END - &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="2"><li><h5 id="修改-themes-next-layout-macro-post-swig文件-1"><a href="#修改-themes-next-layout-macro-post-swig文件-1" class="headerlink" title="修改/themes/next/layout/_macro/post.swig文件"></a>修改/themes/next/layout/_macro/post.swig文件</h5><p>在下面相应的位置添加添加相应的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/*插入代码如下*/</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &#123;% if not is_index %&#125;</span><br><span class="line">                &#123;% include&apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*插入到此处结束*/</span><br><span class="line"></span><br><span class="line">&lt;footer class=&quot;post-footer&quot;&gt;</span><br><span class="line">        &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><del>看参考文档的时候觉得代码插入的地方描述的不是很清楚!!在这个地方自己尽量描述的不能再清楚了</del></p></li></ol><p><br></p><ol start="3"><li><h5 id="修改themes-next-config-yml文件"><a href="#修改themes-next-config-yml文件" class="headerlink" title="修改themes/next/_config.yml文件"></a>修改themes/next/_config.yml文件</h5><p>在任意地方添加下面代码:</p><pre><code># 文章末尾添加结束标记passage_end_tag:        enabled: true</code></pre></li></ol><p><br></p><h2 id="九、访问量统计"><a href="#九、访问量统计" class="headerlink" title="九、访问量统计"></a>九、访问量统计</h2><ol><li><h5 id="busuanzi统计"><a href="#busuanzi统计" class="headerlink" title="busuanzi统计"></a>busuanzi统计</h5><blockquote><p>修改themes/next/_config.yml文件busuanzi_count属性</p></blockquote><pre><code>busuanzi_count:        # count values only if the other configs are false        enable: true         # 站点UV配置 总访问人次(一个人访问多篇文章记录一次)        site_uv: false        site_uv_header: 总访问量        site_uv_footer:        # 站点PV配置 总访问量(一个人访问多篇文章记录多次)        site_pv: false        site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;        site_pv_footer: 次        # 文章PV配置 访问量        page_pv: true        page_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;        page_pv_footer: </code></pre><p><del>我只设置了文章访问量</del></p><p><a href="https://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">更多&gt;&gt;</a></p></li></ol><p><br></p><ol start="2"><li><h5 id="LeanCloud统计文章阅读量"><a href="#LeanCloud统计文章阅读量" class="headerlink" title="LeanCloud统计文章阅读量"></a>LeanCloud统计文章阅读量</h5>【<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a>】</li></ol><p><br></p><h2 id="十、修改头像"><a href="#十、修改头像" class="headerlink" title="十、修改头像"></a>十、修改头像</h2><ol><li><h5 id="在themes-next-source-images下放置头像"><a href="#在themes-next-source-images下放置头像" class="headerlink" title="在themes/next/source/images下放置头像"></a>在themes/next/source/images下放置头像</h5></li><li><h5 id="修改themes-next-config-yml文件avatar属性"><a href="#修改themes-next-config-yml文件avatar属性" class="headerlink" title="修改themes/next/_config.yml文件avatar属性"></a>修改themes/next/_config.yml文件avatar属性</h5><pre><code>#avatar: 路径为头像目录avatar: ../images/avata.gif     </code></pre></li></ol><p><br></p><h2 id="十一、添加背景图"><a href="#十一、添加背景图" class="headerlink" title="十一、添加背景图"></a>十一、添加背景图</h2><ul><li><h5 id="修改themes-next-source-css-custom-custom-styl"><a href="#修改themes-next-source-css-custom-custom-styl" class="headerlink" title="修改themes/next/source/css _custom/custom.styl"></a>修改themes/next/source/css _custom/custom.styl</h5>添加如下代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">        background:url(../images/xx.jpg);</span><br><span class="line">        background-size:cover;</span><br><span class="line">        background-repeat:no-repeat;</span><br><span class="line">        background-attachment:fixed;</span><br><span class="line">        background-position:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="十二、修改各版块透明度"><a href="#十二、修改各版块透明度" class="headerlink" title="十二、修改各版块透明度"></a>十二、修改各版块透明度</h2><ol><li><h5 id="内容板块"><a href="#内容板块" class="headerlink" title="内容板块"></a>内容板块</h5><ul><li><p>修改在对应主题的对应.yml文件中,ID为【.content-wrap】标签下的background属性</p><pre><code>background: rgba(255,255,255,0.7); </code></pre></li><li><p>以主题Pisces为例,对应内容板块文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre></li></ul></li></ol><p><br></p><ol start="2"><li><h5 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h5><ul><li><p>修改在对应主题的对应.yml文件中,ID为【.header-inner】标签下的background属性。</p></li><li><p>以主题Pisces为例,对应菜单栏文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre></li></ul></li></ol><p><br></p><ol start="3"><li><h5 id="站点概况"><a href="#站点概况" class="headerlink" title="站点概况"></a>站点概况</h5><ul><li><p>修改在对应主题的对应.yml文件中,ID为【.sidebar-inner】标签下的background属性</p></li><li><p>以主题Pisces为例,对应站点概况文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_sidebar.styl</code></pre></li><li><p>修改在对应主题的对应.yml文件中,ID为【.sidebar】标签下的background属性</p></li><li><p>以主题Pisces为例,对应站点概况文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre></li></ul></li></ol><p><br></p><ol start="4"><li><h5 id="按钮背景"><a href="#按钮背景" class="headerlink" title="按钮背景"></a>按钮背景</h5><p>主题共享的文件,文件位置:</p><pre><code>themes/next/source/css _custom/components/post/post-button.styl</code></pre></li></ol><p><br></p><h2 id="十三、点击出现桃心"><a href="#十三、点击出现桃心" class="headerlink" title="十三、点击出现桃心"></a>十三、点击出现桃心</h2><ol><li><p>copy<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="noopener">网页</a>代码</p></li><li><p>在<code>/themes/next/source/js/src</code>目录下新建love.js文件,把copy的代码粘贴到此文件。</p></li><li><p>在/themes/next/layout/_layout.swig 文件引入love.js</p><pre><code>...&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;   //在&lt;/body&gt;标签前引入love.js</code></pre><p><del>我发现在文章详情界面,没有效果,理论上应该是有效果的吧？？可能源码被我改砸了？</del></p><p><del>检查发现因为我love.js位置放错了！！</del>一定要放在紧挨<code>&lt;/body&gt;</code>标签前！！</p></li></ol><p><br><br></p><h2 id="十四、文章目录"><a href="#十四、文章目录" class="headerlink" title="十四、文章目录"></a>十四、文章目录</h2><p>目录不能跨级,否则会导致编号会错误。<a href="https://github.com/iissnan/hexo-theme-next/issues/1259" target="_blank" rel="noopener">More&gt;&gt;</a></p><ol><li><h5 id="取消文章目录自动编号"><a href="#取消文章目录自动编号" class="headerlink" title="取消文章目录自动编号"></a>取消文章目录自动编号</h5><blockquote><p>修改themes/next/_config.yml文件toc属性</p></blockquote><pre><code># Table Of Contents in the Sidebar  toc:  enable: true# Automatically add list number to toc.  number: false      /*修改这里*/# If true, all words will placed on next lines if header width longer then sidebar width.  wrap: false</code></pre></li></ol><p><br></p><ol start="2"><li><h5 id="自定义文章目录全显示"><a href="#自定义文章目录全显示" class="headerlink" title="自定义文章目录全显示"></a>自定义文章目录全显示</h5><blockquote><p>修改/themes/next/source/css/_custom/custom.styl,添加以下代码</p></blockquote><pre><code>.post-toc .nav .nav-child {        display: block;} </code></pre><p>并不确定是否成功<a href="https://github.com/iissnan/hexo-theme-next/issues/531" target="_blank" rel="noopener">More &gt;&gt;</a></p></li></ol><p><br></p><ol start="3"><li><h5 id="自定义文章目录级数"><a href="#自定义文章目录级数" class="headerlink" title="自定义文章目录级数"></a>自定义文章目录级数</h5><pre><code>h1      # h2      ## h3      ### h4      #### </code></pre><p>我的标题从h2开始。</p><pre><code>## 十四、文章目录### 1.取消文章目录自动编号#### 修改themes/next/_config.yml文件toc属性  </code></pre><p>不喜欢阅读的时候左边目录一直动,也不喜欢目录全部显示。想要只显示大标题的效果</p><pre><code>一、修改Next主题模式二、设置首页预览摘要三、侧边栏显示效果...</code></pre><p>没有Google到解决方法,以下方法是自己乱改的！！！</p><p><br></p><blockquote><p>修改根目录下/node_modules/hexo/lib/plugins/helper/toc.js</p></blockquote><pre><code>/*修改前*/const headingsMaxDepth = options.hasOwnProperty(&apos;max_depth&apos;) ? options.max_depth : 6;/*修改后*/const headingsMaxDepth = options.hasOwnProperty(&apos;max_depth&apos;) ? options.max_depth : 2;</code></pre></li></ol><p><br></p><h2 id="十五、博文置顶"><a href="#十五、博文置顶" class="headerlink" title="十五、博文置顶"></a>十五、博文置顶</h2><ol><li><h5 id="修改-node-modules-hexo-generator-index-lib-generator-js-文件"><a href="#修改-node-modules-hexo-generator-index-lib-generator-js-文件" class="headerlink" title="修改 node_modules/hexo-generator-index/lib/generator.js 文件"></a>修改 node_modules/hexo-generator-index/lib/generator.js 文件</h5><p>代码全部替换为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">    var config = this.config;</span><br><span class="line">    var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">    if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">        if(a.top == b.top) </span><br><span class="line">            return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">        else </span><br><span class="line">            return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">        &#125;);</span><br><span class="line">        var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class="line">        return pagination(&apos;&apos;, posts, &#123;</span><br><span class="line">            perPage: config.index_generator.per_page,</span><br><span class="line">            layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class="line">            format: paginationDir + &apos;/%d/&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                __index: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="2"><li><h5 id="在文章添加top字段"><a href="#在文章添加top字段" class="headerlink" title="在文章添加top字段"></a>在文章添加top字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我是置顶博文</span><br><span class="line">date: 2018-07-18 21:30:35</span><br><span class="line">tags: 留言板</span><br><span class="line">categories: hotYan_博客之路</span><br><span class="line">top: 100                   //值越大,越靠前</span><br><span class="line">commentIssueId: 1</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h2 id="十六、博客压缩"><a href="#十六、博客压缩" class="headerlink" title="十六、博客压缩"></a>十六、博客压缩</h2><blockquote><p>【<a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">hexo-all-minifier</a>】</p></blockquote><p><br></p><h2 id="十七、精简部署命令"><a href="#十七、精简部署命令" class="headerlink" title="十七、精简部署命令"></a>十七、精简部署命令</h2><ol><li><h5 id="修改根目录下-package-json文件"><a href="#修改根目录下-package-json文件" class="headerlink" title="修改根目录下/package.json文件"></a>修改根目录下/package.json文件</h5><p>添加下面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;update&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><br></p><ol start="2"><li><h5 id="更新Hexo部署-1"><a href="#更新Hexo部署-1" class="headerlink" title="更新Hexo部署"></a>更新Hexo部署</h5><pre><code>$ npm run update</code></pre></li></ol><p><br></p><h2 id="十八、文章categories字段多级"><a href="#十八、文章categories字段多级" class="headerlink" title="十八、文章categories字段多级"></a>十八、文章categories字段多级</h2><ol><li><h5 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h5><pre><code>categories: [博客,Hexo]</code></pre></li></ol><p><br></p><ol start="2"><li><h5 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h5><pre><code>categories:         - 博客        - Hexo</code></pre></li></ol><p><br></p><ol start="3"><li><h5 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h5><ul><li>博客<ul><li>Next</li></ul></li></ul></li></ol><p><br></p><h2 id="十九、文章多个Tags字段值"><a href="#十九、文章多个Tags字段值" class="headerlink" title="十九、文章多个Tags字段值"></a>十九、文章多个Tags字段值</h2><p>写法同十八,表达意思不一样,tags表示多个标签,categories表示多级分类</p><p><br></p><h2 id="二十、SEO优化"><a href="#二十、SEO优化" class="headerlink" title="二十、SEO优化"></a>二十、SEO优化</h2><p>我只进行了GoogleSEO优化,好的参考链接有很多,便不重复总结一遍。这个<a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">参考链接</a>总结的非常全面仔细,连我踩得坑都一模一样(HTML上传一直验证失败,最后选择的HTML标记验证)。其中【网站结构自身优化】部分,很全面。👍👍</p><h4 id="BUT"><a href="#BUT" class="headerlink" title="BUT"></a>BUT</h4><p>建议把</p><pre><code>permalink: :title.html</code></pre><p>修改为</p><pre><code>permalink: :title/</code></pre><p>避免出现想跳转到页面某个特定位置时找不到(即出现404界面)</p><p>修改后:</p><ol><li><p>文章将全部移到public根目录下,后面文章越来越多…github【code】部分列表将越来越长！逼死强迫症患者！</p></li><li><p>文章的阅读量将从0重新统计！！！💔</p></li><li><p>现链接格式必须改为<code>yoursite.com/title/</code>,之前贴的链接将失效。</p></li></ol><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优化博客-持续完善&quot;&gt;&lt;a href=&quot;#优化博客-持续完善&quot; class=&quot;headerlink&quot; title=&quot;优化博客 [持续完善]&quot;&gt;&lt;/a&gt;优化博客 &lt;span style=&quot;font-size:.5em&quot;&gt;[持续完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;搜索了很多Next主题的效果，总结了自己比较喜欢或者已运用到Blog的效果~&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo" scheme="https://hotkang.cn/tags/Hexo/"/>
    
      <category term="博客" scheme="https://hotkang.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Next" scheme="https://hotkang.cn/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Mac Use Homebrew Install Mongodb</title>
    <link href="https://hotkang.cn/2018/use%20homebrew%20install%20mongodb/"/>
    <id>https://hotkang.cn/2018/use homebrew install mongodb/</id>
    <published>2018-05-29T07:38:51.000Z</published>
    <updated>2018-08-03T08:38:33.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac-Use-Homebrew-Install-Mongodb-完结"><a href="#Mac-Use-Homebrew-Install-Mongodb-完结" class="headerlink" title="Mac Use Homebrew Install Mongodb [完结]"></a>Mac Use Homebrew Install Mongodb <span style="font-size:.5em">[完结]</span></h2><blockquote><p>图书管理系统,一开始是打算用Express+ejs+Mongodb,但是后期,使用mongoose出现了问题,尝试解决,没有成功后,就放弃了,转而使用Mysql。将安装过程记录一下。</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接,以下内容作为我的个人记录,以我的角度去记录,总结。</p><ul><li><a href="https://brew.sh/" target="_blank" rel="noopener">homebrew官网</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html" target="_blank" rel="noopener">参考链接</a></li></ul></blockquote><hr><h2 id="一、安装Homebrew"><a href="#一、安装Homebrew" class="headerlink" title="一、安装Homebrew"></a>一、安装Homebrew</h2><p>打开Terminal并运行以下命令</p><pre><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>【注意】 Homebrew将作为安装过程的一部分下载并安装Xcode 8.0的命令行工具。</p><p><br></p><h2 id="二、安装MongoDB"><a href="#二、安装MongoDB" class="headerlink" title="二、安装MongoDB"></a>二、安装MongoDB</h2><ol><li><p>运行以下命令进行安装mongodb</p><pre><code>$ brew install mongodb</code></pre></li><li><p>将mongodb升级，确保版本最新</p><pre><code>$ brew upgrade mongodb</code></pre></li><li><p>创建一个目录，用来保存mongo默认的数据</p><pre><code>$ mkdir -p /data/db</code></pre></li><li><p>给目录以可读可写的权限</p><pre><code>$ chown `id -u` /data/db</code></pre></li><li><p>启动</p><pre><code>$ brew services start mongodb</code></pre></li></ol><p><br></p><h2 id="三、未正常关闭导致数据库突然启动不了"><a href="#三、未正常关闭导致数据库突然启动不了" class="headerlink" title="三、未正常关闭导致数据库突然启动不了"></a>三、未正常关闭导致数据库突然启动不了</h2><ol><li>删除掉mongod.lock文件，然后重新启动</li></ol><ol start="2"><li><p>如果还是不可以，先查看一下进程</p><pre><code>$ ps -aef | grep mongo</code></pre></li><li><p>然后根据进程ID杀掉进程</p><pre><code>$ sudo kill 6955</code></pre></li><li><p>重新启动mongodb服务</p><pre><code>$ brew services start mongodb</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mac-Use-Homebrew-Install-Mongodb-完结&quot;&gt;&lt;a href=&quot;#Mac-Use-Homebrew-Install-Mongodb-完结&quot; class=&quot;headerlink&quot; title=&quot;Mac Use Homebrew Install Mongodb [完结]&quot;&gt;&lt;/a&gt;Mac Use Homebrew Install Mongodb &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;图书管理系统,一开始是打算用Express+ejs+Mongodb,但是后期,使用mongoose出现了问题,尝试解决,没有成功后,就放弃了,转而使用Mysql。将安装过程记录一下。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Install" scheme="https://hotkang.cn/categories/Install/"/>
    
      <category term="Mongodb" scheme="https://hotkang.cn/categories/Install/Mongodb/"/>
    
    
      <category term="Homebrew" scheme="https://hotkang.cn/tags/Homebrew/"/>
    
      <category term="Mongodb" scheme="https://hotkang.cn/tags/Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>用hexo搭建github博客一</title>
    <link href="https://hotkang.cn/2018/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E4%B8%80/"/>
    <id>https://hotkang.cn/2018/用hexo搭建github博客一/</id>
    <published>2018-05-29T07:38:51.000Z</published>
    <updated>2018-10-25T05:39:24.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建博客-完结"><a href="#搭建博客-完结" class="headerlink" title="搭建博客 [完结]"></a>搭建博客 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>一直想搭个人博客,却无从下手？？</p></blockquote><a id="more"></a><p><br></p><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://dmkf.xyz/2017/03/12/6272440/" target="_blank" rel="noopener">参考教程1</a></li><li><a href="https://sunny73.github.io/2018/02/10/Build-my-first-blog/" target="_blank" rel="noopener">参考教程2</a></li><li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官网文档</a></li></ul><p>第二个链接也是参考第一个写的,第一个链接加载超级慢,可以选择看第二个。</p></blockquote><hr><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><ol><li><h5 id="默认已有GitHub账号"><a href="#默认已有GitHub账号" class="headerlink" title="默认已有GitHub账号"></a>默认已有GitHub账号</h5><ul><li>没有GitHub账号？？<a href="https://github.com/" target="_blank" rel="noopener">点击注册</a></li></ul></li></ol><p><br></p><ol start="2"><li><h5 id="默认已安装Git"><a href="#默认已安装Git" class="headerlink" title="默认已安装Git"></a>默认已安装Git</h5><ul><li>没有安装Git？？<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="noopener">了解如何安装</a></li></ul></li></ol><p><br></p><ol start="3"><li><h5 id="默认已安装-Node-js"><a href="#默认已安装-Node-js" class="headerlink" title="默认已安装 Node.js"></a>默认已安装 Node.js</h5><ul><li>没有安装Node.js??<a href="https://hotyan.github.io/2018/%E7%94%A8nvm%E8%A3%85node-js/" target="_blank" rel="noopener">了解如何安装</a></li></ul></li></ol><p><br></p><ol start="4"><li><h5 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h5><ul><li><p>全局下载hexo</p><pre><code>$ npm install -g hexo-cli</code></pre></li><li><p>查看是否成功</p><pre><code>$ hexo</code></pre><p>进入<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官网文档</a>了解更多</p></li></ul></li></ol><p><br></p><h2 id="二、初始化博客"><a href="#二、初始化博客" class="headerlink" title="二、初始化博客"></a>二、初始化博客</h2><pre><code>$ hexo init HotYan_Bolg //创建一个放在博客项目的文件$ cd HotYan_Bolg       //进入该文件$ npm install       //安装依赖包</code></pre><p><br>进入HotYan_Bolg,已自动生成以下文件</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p><br></p><h2 id="三、本地搭建"><a href="#三、本地搭建" class="headerlink" title="三、本地搭建"></a>三、本地搭建</h2><ol><li><h5 id="修改-config-yml文件"><a href="#修改-config-yml文件" class="headerlink" title="修改_config.yml文件"></a>修改_config.yml文件</h5><p>根据个人情况修改以下部分:</p><pre><code>/*修改前*/# Site  title: # The title of your website  subtitle: # The subtitle of your website  description: # The description of your website  author: # Your name  language: # The language of your website  timezone:/*修改后*/# Site  title: hotYan&apos;s Blog   subtitle: 爱美的程序媛  description: 毒鸡汤Yan  keywords:  author: hotYan  language: zh-CN  timezone: Asia/Shanghai</code></pre><p>注意:每一项的填写,其 <strong>:</strong> 后面都要保留一个空格,下同。</p></li></ol><p><br></p><ol start="2"><li><h5 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h5><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo generate // 生成文件$ hexo server   //本地部署/*简写如下*/$ hexo g$ hexo s</code></pre><p>可在浏览器输入地址 <code>http://host:4000</code>进行查看</p></li></ol><p><br></p><h2 id="四、配置远程环境-线上运行"><a href="#四、配置远程环境-线上运行" class="headerlink" title="四、配置远程环境,线上运行"></a>四、配置远程环境,线上运行</h2><ol><li><h5 id="github新建一个库"><a href="#github新建一个库" class="headerlink" title="github新建一个库"></a>github新建一个库</h5><pre><code>库名格式为: username.github.io //非常重要！！！</code></pre><p>你可能想了解一下<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a></p></li></ol><p><br></p><ol start="2"><li><h5 id="GitHub添加SSH密钥"><a href="#GitHub添加SSH密钥" class="headerlink" title="GitHub添加SSH密钥"></a><a href="https://hotkang.cn/2018/Github%E6%B7%BB%E5%8A%A0SSH%E5%AF%86%E9%92%A5/">GitHub添加SSH密钥</a></h5></li></ol><p><br></p><ol start="3"><li><h5 id="配置-config-yml文件"><a href="#配置-config-yml文件" class="headerlink" title="配置_config.yml文件"></a>配置_config.yml文件</h5><ul><li><p>配置统一资源定位符（个人域名）</p><pre><code>/*配置前*/# URL# If your site is put in a subdirectory, .....url: http://yoursite.com/child/*配置后*/  # URL# If your site is put in a subdirectory,......url: http://github.com</code></pre></li><li><p>配置部署</p><pre><code># Deployment# Docs: https://hexo.io/docs/deployment.html  deploy:      type: git       repo: https://github.com/hotYan/hotYan.github.io.git  //repo项是之前Github上创建好的仓库地址      branch: master</code></pre></li></ul></li></ol><p><br></p><ol start="4"><li><h5 id="线上运行"><a href="#线上运行" class="headerlink" title="线上运行"></a>线上运行</h5><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo generate // 生成文件$ hexo deploy   // 线上部署/*简写如下*/$ hexo g$ hexo d</code></pre><p>可在浏览器输入博客地址 <code>https://hotyan.github.io/</code> 进行查看</p></li></ol><p><br></p><h2 id="五、修改主题"><a href="#五、修改主题" class="headerlink" title="五、修改主题"></a>五、修改主题</h2><ol><li><h5 id="下载Next主题"><a href="#下载Next主题" class="headerlink" title="下载Next主题"></a><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">下载Next主题</a></h5></li><li><h5 id="下载后-将压缩包解压缩-复制其中名称为next的文件夹到你博客文件的themes下"><a href="#下载后-将压缩包解压缩-复制其中名称为next的文件夹到你博客文件的themes下" class="headerlink" title="下载后,将压缩包解压缩,复制其中名称为next的文件夹到你博客文件的themes下"></a>下载后,将压缩包解压缩,复制其中名称为next的文件夹到你博客文件的themes下</h5></li><li><h5 id="修改博客文件根目录下的-config-yml-将主题改为next"><a href="#修改博客文件根目录下的-config-yml-将主题改为next" class="headerlink" title="修改博客文件根目录下的_config.yml,将主题改为next"></a>修改博客文件根目录下的_config.yml,将主题改为next</h5><pre><code># Extensions# Plugins: https://hexo.io/plugins/# Themes: https://hexo.io/themes/# theme: landscape  theme: next   </code></pre></li></ol><p><br></p><h2 id="六、创建新文章"><a href="#六、创建新文章" class="headerlink" title="六、创建新文章"></a>六、创建新文章</h2><ol><li><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><pre><code>$ cd  HotYan_Blog   //进入博客文件夹目录$ hexo new &quot;用hexo搭建github博客一&quot;  // 新建一篇文章</code></pre><p>可在博客文件夹下的source/_post查看你新建的markdown文件</p></li></ol><p><br></p><ol start="2"><li><h5 id="编写内容"><a href="#编写内容" class="headerlink" title="编写内容"></a>编写内容</h5><p>如果不清楚如何编写markdown文件,你可能需要先了解一下。</p><ul><li><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">参考链接1</a></li><li><a href="http://xianbai.me/learn-md/article/syntax/blockquotes.html" target="_blank" rel="noopener">参考链接2</a></li></ul></li></ol><p><br></p><h2 id="七、更新Hexo部署"><a href="#七、更新Hexo部署" class="headerlink" title="七、更新Hexo部署"></a>七、更新Hexo部署</h2><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo clean    // 清理缓存$ hexo generate // 生成文件$ hexo deploy   // 线上部署/*简写如下*/$ hexo clean$ hexo g$ hexo d</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;搭建博客-完结&quot;&gt;&lt;a href=&quot;#搭建博客-完结&quot; class=&quot;headerlink&quot; title=&quot;搭建博客 [完结]&quot;&gt;&lt;/a&gt;搭建博客 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;一直想搭个人博客,却无从下手？？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Hexo" scheme="https://hotkang.cn/tags/Hexo/"/>
    
      <category term="博客" scheme="https://hotkang.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>高性能网站建设指南14条规则</title>
    <link href="https://hotkang.cn/2018/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%9714%E6%9D%A1%E8%A7%84%E5%88%99/"/>
    <id>https://hotkang.cn/2018/高性能网站建设指南14条规则/</id>
    <published>2018-05-29T00:54:54.000Z</published>
    <updated>2018-12-05T09:46:56.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14条常用性能规则-待完善"><a href="#14条常用性能规则-待完善" class="headerlink" title="14条常用性能规则[待完善]"></a>14条常用性能规则<span style="font-size:.5em">[待完善]</span></h2><p><img src="/img/XN.png" alt=""></p><a id="more"></a><h2 id="高性能网站建设指南"><a href="#高性能网站建设指南" class="headerlink" title="高性能网站建设指南"></a>高性能网站建设指南</h2><p>按照优先级顺序依次介绍14个性能规则</p><p><a href="#减少http请求"><code>1. 减少HTTP请求</code></a><br><a href="#使用内容分发网络cdn"><code>2. 使用内容分发网络CDN</code></a><br><a href="#添加Expires头"><code>3. 添加Expires头</code></a><br><a href="#压缩组件"><code>4. 压缩组件</code></a><br><a href="#将样式表放在顶部"><code>5. 将样式表放在顶部</code></a><br><a href="#将脚本放在底部"><code>6. 将脚本放在底部</code></a><br><a href="#避免使用css表达式"><code>7. 避免使用CSS表达式</code></a><br><a href="#使用外部JavaScript和CSS"><code>8. 使用外部JavaScript和CSS</code></a><br><a href="#减少dns查找"><code>9. 减少DNS查找</code></a><br><a href="#精简javascript"><code>10. 精简JavaScript</code></a><br><a href="#避免重定向"><code>11. 避免重定向</code></a><br><a href="#删除重复的脚本"><code>12. 删除重复的脚本</code></a><br><a href="#配置etags"><code>13. 配置ETags</code></a><br><a href="#使ajax可缓存"><code>14. 使Ajax可缓存</code></a></p><hr><p>终端用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像、样式表、脚本、Flash等。</p><h2 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h2><ul><li><p>图片地图</p><ul><li><p>假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。</p><p><img src="/img/JL.png" alt=""></p></li><li>服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应</li><li>客户端图片地图：直接将点击映射到操作</li></ul></li><li><p>CSS Sprites ：将背景图像组合成单个图像</p><ul><li><p>优点 ：</p><pre><code>1.减少HTTP请求，响应时间短  2.图片数量变少，降低下载量</code></pre></li><li><p>方法：</p><pre><code>使用  CSSbackground-image  background-position  属性显示所需的图像片段。      </code></pre></li></ul></li></ul><ul><li><p>内内联图片</p><ul><li><p>使用 data:URL 模式，允许将小块数据内联为“立即数”，数据就在URL自身中。</p><pre><code>格式：data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></pre><ul><li>合并脚本和样式表</li></ul></li><li>通过将所有脚本合并为一个脚本来减少HTTP请求数量的方法，同样也可以将所有CSS合并到一个样式表中，能够缩短响应时间。</li></ul></li></ul><h2 id="使用内容分发网络CDN"><a href="#使用内容分发网络CDN" class="headerlink" title="使用内容分发网络CDN"></a>使用内容分发网络CDN</h2><ul><li>用户与Web服务器的距离对响应时间有影响。在多个地理位置分散的服务器上部署您的内容将使您的网页从用户的角度更快加载。但是你应该从哪里开始？</li></ul><p>作为实现地理上分散的内容的第一步，不要尝试重新设计您的Web应用程序以在分布式架构中工作。根据应用程序的不同，更改体系结构可能包括艰巨的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与内容之间的距离可能会延迟或不能通过此应用程序体系结构步骤。</p><p>请记住，80-90％的最终用户响应时间用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是性能黄金法则。</p><p>不要从重新设计应用程序体系结构的艰巨任务开始，最好先分散您的静态内容。这不仅实现了响应时间的更大缩短，而且由于内容交付网络，这更容易实现。</p><p><code>内容传送网络（CDN）</code>是分布在多个位置的网络服务器的集合，以更高效地向用户传送内容。选择用于将内容递送给特定用户的服务器通常基于网络邻近度的度量。例如，选择网络跳数最少的服务器或响应时间最快的服务器。</p><p>一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如Akamai Technologies，EdgeCast或level3）具有成本效益。对于创业公司和私人网站来说，CDN服务的成本可能会很高，但随着您的目标受众不断扩大并变得更加全球化，CDN是实现快速响应所必需的。</p><h2 id="添加Expires头"><a href="#添加Expires头" class="headerlink" title="添加Expires头"></a>添加Expires头</h2><p>这条规则有两个方面：</p><ul><li>对于静态组件：通过设置远期<code>Expires</code>标题实现“永不过期”策略</li><li>对于动态组件：使用适当的<code>Cache-Control</code>头文件来帮助浏览器提供有条件的请求</li></ul><p>网页设计越来越丰富，这意味着更多的脚本，样式表，图像和Flash在页面中。</p><p>首次访问您的页面可能需要发出多个HTTP请求，但通过使用Expires标头，可以使这些组件可缓存。这避免了后续页面浏览中不必要的HTTP请求。</p><p>过期标头最常用于图像，但它们应该用于所有组件，包括脚本，样式表和Flash组件。</p><p>浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，使网页加载速度更快。<br>Web服务器使用HTTP响应中的Expires标头告诉客户端可以缓存组件的时间。</p><p>请记住，如果您使用远期未来的Expires头文件，则只要组件更改，就必须更改组件的文件名。</p><p>只有在用户已经访问过您的网站后，使用远期未来的Expires标题才会影响页面浏览。</p><p>当用户第一次访问您的网站并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。</p><p>因此，这种性能改进的影响取决于用户多久访问一次带有缓冲区的页面。（一个“准备好的缓存”已经包含了页面中的所有组件。）我们在Yahoo!上测试了这一点。并发现带有引导缓存的页面浏览量为75-85％。通过使用远期未来的Expires标题，您可以增加浏览器缓存的组件数量，并在后续页面浏览中重新使用，而无需在用户的Internet连接上发送单个字节。</p><h2 id="Gzip压缩传输文件"><a href="#Gzip压缩传输文件" class="headerlink" title="Gzip压缩传输文件"></a>Gzip压缩传输文件</h2><p>通过网络传输HTTP请求和响应所需的时间可以通过前端工程师做出的决策大大减少。</p><p>确实，最终用户的带宽速度，互联网服务提供商，邻近对等交换点等是超出了开发团队的控制范围。</p><p>但还有其他一些影响响应时间的因素。</p><p>压缩通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP / 1.1开始，Web客户端通过HTTP请求中的Accept-Encoding标头指示对压缩的支持。</p><pre><code>Accept-Encoding：gzip，deflate</code></pre><p>如果Web服务器在请求中看到该头部，则可能使用客户端列出的方法之一压缩响应。</p><p>Web服务器通过响应中的Content-Encoding标头通知Web客户端。</p><pre><code>内容编码：gzip</code></pre><blockquote><p>Gzip是目前最流行和最有效的压缩方法。它由GNU项目开发并由RFC 1952标准化。您可能会看到的唯一的其他压缩格式是压缩，但效果不太好，不太受欢迎。Gzipping通常将响应大小减少约70％。目前大约90％的互联网流量都通过声称支持gzip的浏览器。</p></blockquote><blockquote><p>浏览器和代理存在已知的问题，这些问题可能会导致浏览器期望的不匹配和接收到的有关压缩内容的不匹配。幸运的是，随着旧版浏览器的使用下降，这些边缘案例正在减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。</p></blockquote><p>服务器根据文件类型选择要压缩的内容，但在决定压缩的内容时通常太有限。</p><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。</p><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p><p>尽可能多地缩放文件类型是减少页面重量和加速用户体验的简单方法。</p><h2 id="将样式表放在顶部"><a href="#将样式表放在顶部" class="headerlink" title="将样式表放在顶部"></a>将样式表放在顶部</h2><p>将样式表移动到文档HEAD中,页面显示加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。这改善了整体用户体验。</p><p>将样式表放在文档底部附近的问题:它禁止在许多浏览器（包括Internet Explorer）中进行渐进式呈现。这些浏览器会阻止渲染，以避免在样式更改时重新绘制页面元素。用户停留在查看空白页面。</p><p>没有任何替代方案，空白屏幕或无风格内容的闪光都值得冒这个风险。最佳解决方案是遵循HTML规范，并将样式表加载到文档HEAD中。</p><h2 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h2><p>脚本导致的问题是它们会阻止并行下载。</p><p>在HTTP / 1.1规范建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以同时发生两个以上的下载。然而，当脚本正在下载时，浏览器将不会启动任何其他下载，即使是在不同的主机名上。</p><p>在某些情况下，将脚本移动到底部并不容易。例如，如果脚本用于document.write插入页面内容的一部分，则不能在页面中移动较小的内容。也可能存在范围问题。在很多情况下，有办法解决这些情况。</p><p>经常出现的另一个建议是使用延迟脚本。<br>该DEFER属性指示该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该DEFER属性。在Internet Explorer中，该脚本可能会延迟，但不如预期的那么多。如果脚本可以被延期，它也可以被移动到页面的底部。这会让你的网页加载速度更快。</p><h2 id="避免使用CSS表达式"><a href="#避免使用CSS表达式" class="headerlink" title="避免使用CSS表达式"></a>避免使用CSS表达式</h2><p>CSS表达式是动态设置CSS属性的强大（也是危险的）方法。<br>从版本5开始，它们在Internet Explorer中受支持，但从IE8开始已弃用。</p><p>表达式的问题在于它们比大多数人期望的更频繁地进行评估。</p><p>减少CSS表达式评估次数的一种方法是使用一次性表达式，第一次评估表达式时，它将style属性设置为一个显式值，该值将替换CSS表达式。</p><p>如果样式属性必须在页面的整个生命周期中动态设置，则使用事件处理程序而不是CSS表达式是一种替代方法。</p><p>如果您必须使用CSS表达式，请记住它们可能会被评估数千次，并且可能会影响页面的性能。</p><h2 id="使用外部JavaScript和CSS"><a href="#使用外部JavaScript和CSS" class="headerlink" title="使用外部JavaScript和CSS"></a>使用外部JavaScript和CSS</h2><p>许多这些性能规则涉及如何管理外部组件。但是，在出现这些问题之前，您应该提出一个更基本的问题：JavaScript和CSS应该包含在外部文件中还是包含在页面本身中？</p><p>在现实世界中<code>使用外部文件通常会产生更快的页面</code>，因为浏览器会缓存JavaScript和CSS文件。</p><ul><li>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</li><li>JavaScript和CSS位于浏览器缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><p>许多网站都处于这些指标的中间。对于这些网站，最好的解决方案通常是将JavaScript和CSS作为外部文件进行部署。首选内联的唯一例外是主页，例如雅虎的首页和My Yahoo! 。每个会话只有很少（可能只有一个）页面视图的主页可能会发现内嵌JavaScript和CSS可以缩短最终用户的响应时间。</p><p>对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少以及通过使用外部文件实现的缓存优点。其中一种方法是在首页内嵌JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已经在浏览器缓存中的外部文件。</p><h2 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><p><code>域名系统（DNS）</code>将主机名映射到IP地址，就像电话本将人名映射到他们的电话号码一样。<br>当您在浏览器中输入<a href="http://www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。" target="_blank" rel="noopener">www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。</a><br>DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。直到DNS查找完成后，浏览器才能从此主机名下载任何内容。</p><p>DNS查找缓存以获得更好的性能。这种高速缓存可以发生在用户的ISP或局域网维护的特殊高速缓存服务器上，但也可以在个人用户的计算机上进行高速缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器在自己的缓存中保存了一条DNS记录，它就不会打扰操作系统请求记录。</p><p>按照DnsCacheTimeout注册表设置的指定，Internet Explorer默认缓存DNS查找30分钟 。Firefox缓存DNS查找1分钟，由network.dnsCacheExpiration配置设置控制。（Fasterfox将此更改为1小时。）</p><p>当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。</p><p>减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间取得了很好的折衷。</p><h2 id="精简JavaScript"><a href="#精简JavaScript" class="headerlink" title="精简JavaScript"></a>精简JavaScript</h2><ul><li>在JavaScript的情况下，由于下载文件的大小减小，这提高了响应时间性能。</li><li>从代码中移除不必要的字符以减少其大小，减少加载时间。</li><li><p>减少JavaScript 文件大小的有几种手段:</p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。</li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。</li></ul></li></ul><h2 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h2><p>重定向是使用301和302状态码完成的。</p><p>浏览器会自动将用户转到该Location字段中指定的URL 。重定向所需的所有信息都在标题中,响应的主体通常是空的。</p><p>尽管名称不同，301和302响应在实践中都不会被缓存，除非额外的标头（例如Expires或Cache-Control）指示它应该是。</p><p>元刷新标记和JavaScript是将用户引导到不同URL的其他方式，但是如果您必须执行重定向，首选方法是使用标准的3xx HTTP状态代码，主要是为了确保后退按钮正常工作。</p><p>要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。</p><p>将旧网站连接到新网站是重定向的另一个常见用途。</p><p>其他包括连接网站的不同部分，并根据特定条件（浏览器类型，用户帐户类型等）指导用户。</p><p>使用重定向来连接两个网站很简单，只需要很少的附加编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。</p><p>这种重定向的替代方案包括使用Alias和mod_rewrite如果两个代码路径托管在同一台服务器上。</p><p>如果域名更改是使用重定向的原因，另一种方法是创建一个CNAME（一个DNS记录，用于创建一个别名从一个域名指向另一个域名）与Alias或mod_rewrite。</p><h2 id="删除重复的脚本"><a href="#删除重复的脚本" class="headerlink" title="删除重复的脚本"></a>删除重复的脚本</h2><p>在一个页面中包含两次相同的JavaScript文件会使性能受损。</p><p>当它发生时，通过创建不必要的HTTP请求和浪费JavaScript执行，重复脚本会损害性能。</p><p>不必要的HTTP请求发生在Internet Explorer中，但不在Firefox中。</p><p>在Internet Explorer中，如果外部脚本包含两次并且不可缓存，则会在加载页面期间生成两个HTTP请求。如果脚本可缓存，当用户重新加载页面时也会发生额外的HTTP请求。</p><p>除了生成浪费的HTTP请求之外，还会浪费多次时间评估脚本。无论脚本是否可缓存，此冗余JavaScript执行都会在Firefox和Internet Explorer中发生。</p><h2 id="配置ETags"><a href="#配置ETags" class="headerlink" title="配置ETags"></a>配置ETags</h2><p>实体标签（ETags）是Web服务器和浏览器用来确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（一个“实体”是另一个词“组件”：图像，脚本，样式表等）</p><p>ETag被添加来提供一种机制来验证比上一次修改日期更灵活的实体。</p><p>ETag是唯一标识组件特定版本的字符串。唯一的格式约束是字符串被引用。原始服务器使用ETag响应头指定组件的ETag 。</p><pre><code>HTTP / 1.1 200 OKLast-Modified：Tue，2006年12月12日03:03:59 GMTETag：“10c24bc-4ab-457e1c1f”内容长度：12195</code></pre><p>之后，如果浏览器必须验证组件，它将使用If-None-Match标头将ETag传递回原始服务器。如果ETags匹配，则返回一个304状态码，在此示例中将响应减少12195字节。</p><pre><code>GET /i/yahoo.gif HTTP / 1.1主持人：us.yimg.comIf-Modified-Since：星期二，2006年12月12日03:03:59 GMTIf-None-Match：“10c24bc-4ab-457e1c1f”HTTP / 1.1 304未修改</code></pre><p>ETags的问题在于，它们通常使用属性来构建，这些属性使它们对托管站点的特定服务器是唯一的。</p><p>当浏览器从一台服务器获取原始组件并稍后尝试在另一台服务器上验证该组件时，ETags将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。</p><p>虽然给定的文件可能位于多个服务器的相同目录中，并且具有相同的文件大小，权限，时间戳等，但其inode不同于一台服务器。</p><p>IIS 5.0和6.0与ETags有类似的问题。IIS上ETags的格式是Filetimestamp:ChangeNumber。A ChangeNumber是用于跟踪IIS配置更改的计数器。ChangeNumber在网站后面的所有IIS服务器上都不可能是相同的。</p><p>最终结果是由Apache和IIS生成的ETags完全相同的组件不会从一台服务器到另一台服务器进行匹配。如果ETags不匹配，用户不会收到ETags设计的小而快的304响应; 相反，他们会得到一个正常的200响应以及组件的所有数据。</p><p>如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多台服务器托管您的网站，并且您使用的是默认的ETag配置的Apache或IIS，那么您的用户的页面速度会变慢，您的服务器的负载会更高，消耗的带宽也会更大，高效地缓存您的内容。即使你的组件有一个遥远的将来Expires头，当用户点击重新加载或刷新时，仍然会发出条件GET请求。</p><p>如果您没有充分利用ETags提供的灵活验证模型，最好完全删除ETag。</p><p>该Last-Modified头验证基于对组件的时间戳。</p><p>删除ETag可以减少响应和后续请求中HTTP头的大小。</p><h2 id="使Ajax可缓存"><a href="#使Ajax可缓存" class="headerlink" title="使Ajax可缓存"></a>使Ajax可缓存</h2><p>Ajax引用的好处之一是，它向用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待这些异步JavaScript和XML响应返回时扭动拇指。</p><p>在许多应用程序中，用户是否在等待取决于如何使用Ajax。例如，在基于Web的电子邮件客户端中，用户将不断等待Ajax请求的结果，以查找与其搜索条件匹配的所有电子邮件。记住“异步”并不意味着“即时”。</p><p>为了提高性能，优化这些Ajax响应非常重要。</p><p>提高Ajax性能的最重要方法是使响应可缓存，如<code>添加过期或缓存控制头</code>中所述。</p><ul><li>其他一些规则也适用于Ajax：<br>Gzip组件<br>减少DNS查找<br>缩小JavaScript<br>避免重定向<br>配置ETags</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;14条常用性能规则-待完善&quot;&gt;&lt;a href=&quot;#14条常用性能规则-待完善&quot; class=&quot;headerlink&quot; title=&quot;14条常用性能规则[待完善]&quot;&gt;&lt;/a&gt;14条常用性能规则&lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/XN.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>7类35条网页性能优化</title>
    <link href="https://hotkang.cn/2018/7%E7%B1%BB35%E6%9D%A1%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://hotkang.cn/2018/7类35条网页性能优化/</id>
    <published>2018-05-29T00:52:55.000Z</published>
    <updated>2018-12-05T13:56:35.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小结于"><a href="#小结于" class="headerlink" title="小结于"></a>小结于</h2><blockquote><p><a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#menu" target="_blank" rel="noopener">参考链接</a></p></blockquote><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><blockquote><h3 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h3></blockquote><p>终端用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像、样式表、脚本、Flash等。<br>减少组件数量又会减少呈现页面所需的HTTP请求数量。这是更快页面的关键。</p><p>减少页面中组件数量的一种方法是简化页面的设计。但是，有没有办法构建更丰富的内容，同时实现快速响应时间？</p><p>以下是一些减少HTTP请求数量的技术，同时还支持丰富的页面设计。</p><ul><li><p><code>组合文件</code>是一种通过将所有脚本合并为一个脚本来减少HTTP请求数量的方法，同样也可以将所有CSS合并到一个样式表中。当脚本和样式表因页面而异时，将文件组合起来更具挑战性，但使发布过程的这一部分能够缩短响应时间。</p></li><li><p><code>CSS Sprites</code>是减少图片请求数量的首选方法。将背景图像组合成单个图像，并使用CSSbackground-image和background-position属性显示所需的图像片段。</p></li><li><p><code>图像映射</code>将多个图像组合成单个图像。整体大小大致相同，但减少HTTP请求的数量会加快页面的速度。仅当图像在页面中连续存在时（例如导航栏），图像映射才起作用。定义图像映射的坐标可能很乏味且容易出错。使用图像地图进行导航也无法访问，因此不推荐。</p></li><li><p><code>内联图像</code>使用data:URL方案将图像数据嵌入到实际页面中。这可以增加HTML文档的大小。将内嵌图像合并到缓存的样式表中是减少HTTP请求并避免增加页面大小的一种方法。所有主流浏览器都不支持内嵌图像。</p></li></ul><p>减少页面中的HTTP请求数量是开始的地方。这是提高初次访问者性能的最重要指导方针。</p><blockquote><h3 id="减少DNS查询次数"><a href="#减少DNS查询次数" class="headerlink" title="减少DNS查询次数"></a>减少DNS查询次数</h3></blockquote><p><code>域名系统（DNS）</code>将主机名映射到IP地址，就像电话本将人名映射到他们的电话号码一样。<br>当您在浏览器中输入<a href="http://www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。" target="_blank" rel="noopener">www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。</a><br>DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。直到DNS查找完成后，浏览器才能从此主机名下载任何内容。</p><p>DNS查找缓存以获得更好的性能。这种高速缓存可以发生在用户的ISP或局域网维护的特殊高速缓存服务器上，但也可以在个人用户的计算机上进行高速缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器在自己的缓存中保存了一条DNS记录，它就不会打扰操作系统请求记录。</p><p>按照DnsCacheTimeout注册表设置的指定，Internet Explorer默认缓存DNS查找30分钟 。Firefox缓存DNS查找1分钟，由network.dnsCacheExpiration配置设置控制。（Fasterfox将此更改为1小时。）</p><p>当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。</p><p>减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间取得了很好的折衷。</p><blockquote><h3 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h3></blockquote><p>重定向是使用301和302状态码完成的。</p><p>浏览器会自动将用户转到该Location字段中指定的URL 。重定向所需的所有信息都在标题中,响应的主体通常是空的。</p><p>尽管名称不同，301和302响应在实践中都不会被缓存，除非额外的标头（例如Expires或Cache-Control）指示它应该是。</p><p>元刷新标记和JavaScript是将用户引导到不同URL的其他方式，但是如果您必须执行重定向，首选方法是使用标准的3xx HTTP状态代码，主要是为了确保后退按钮正常工作。</p><p>要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。</p><p>将旧网站连接到新网站是重定向的另一个常见用途。</p><p>其他包括连接网站的不同部分，并根据特定条件（浏览器类型，用户帐户类型等）指导用户。</p><p>使用重定向来连接两个网站很简单，只需要很少的附加编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。</p><p>这种重定向的替代方案包括使用Alias和mod_rewrite如果两个代码路径托管在同一台服务器上。</p><p>如果域名更改是使用重定向的原因，另一种方法是创建一个CNAME（一个DNS记录，用于创建一个别名从一个域名指向另一个域名）与Alias或mod_rewrite。</p><blockquote><h3 id="使Ajax可缓存"><a href="#使Ajax可缓存" class="headerlink" title="使Ajax可缓存"></a>使Ajax可缓存</h3></blockquote><p>Ajax引用的好处之一是，它向用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待这些异步JavaScript和XML响应返回时扭动拇指。</p><p>在许多应用程序中，用户是否在等待取决于如何使用Ajax。例如，在基于Web的电子邮件客户端中，用户将不断等待Ajax请求的结果，以查找与其搜索条件匹配的所有电子邮件。记住“异步”并不意味着“即时”。</p><p>为了提高性能，优化这些Ajax响应非常重要。</p><p>提高Ajax性能的最重要方法是使响应可缓存，如<code>添加过期或缓存控制头</code>中所述。</p><ul><li>其他一些规则也适用于Ajax：<br>Gzip组件<br>减少DNS查找<br>缩小JavaScript<br>避免重定向<br>配置ETags</li></ul><blockquote><h3 id="延迟加载组件"><a href="#延迟加载组件" class="headerlink" title="延迟加载组件"></a>延迟加载组件</h3></blockquote><p>你可以仔细看看你的页面，并问自己：“为了最初呈现页面，绝对需要什么？”。其余的内容和组件可以等待。</p><p>JavaScript是在onload事件之前和之后进行分割的理想人选。</p><p>例如，如果您有JavaScript代码和用于拖放和动画的库，则可以等待，因为在初始渲染之后拖动页面上的元素。其他要查找候选人进行后加载的地方包括隐藏内容（用户操作后显示的内容）和低于该对象的图像。</p><p>性能目标与其他Web开发最佳实践保持一致是很好的。在这种情况下，逐步增强的想法告诉我们，JavaScript在受支持的情况下可以改善用户体验，但是即使没有JavaScript，您也必须确保页面能够正常工作。</p><p>因此，在确保页面正常工作后，您可以使用一些后期加载的脚本来增强它，从而为您提供更多的细节和哨音，例如拖放和动画。</p><blockquote><h3 id="预加载组件"><a href="#预加载组件" class="headerlink" title="预加载组件"></a>预加载组件</h3></blockquote><p>预加载看起来可能与后加载相反，但它实际上有一个不同的目标。通过预加载组件，您可以利用浏览器闲置的时间以及将来需要的组件（如图像，样式和脚本）。通过这种方式，当用户访问下一页时，您可以将大部分组件都存储在缓存中，并且您的页面将为用户加载得更快。</p><p>实际上有几种类型的预加载：</p><ul><li><p>无条件预加载:只要onload激活，您就可以继续并获取一些额外的组件。</p></li><li><p>有条件预加载:根据用户操作，您可以根据用户的行为猜测下一个用户前进的位置并相应地进行预加载。</p></li><li>预期的预加载:在启动重新设计之前提前预加载。它经常发生在重新设计之后，您会听到：“新网站很酷，但速度比以前慢”。部分问题可能在于用户使用完全缓存访问旧网站，但新网站总是空的缓存体验。您甚至可以在启动重新设计之前通过预加载某些组件来减轻这种副作用。您的旧网站可以使用浏览器闲置的时间，并请求将由新网站使用的图像和脚本</li></ul><blockquote><h3 id="减少DOM元素的数量"><a href="#减少DOM元素的数量" class="headerlink" title="减少DOM元素的数量"></a>减少DOM元素的数量</h3></blockquote><p>复杂的页面意味着需要下载更多的字节，这也意味着JavaScript中的DOM访问速度较慢。例如，当您想要添加事件处理程序时，如果在页面上循环遍历500或5000个DOM元素，则会有所不同。</p><p>大量的DOM元素可能是一种症状，应该通过页面的标记来改善某些内容，而不必删除内容。</p><p>DOM元素的数量很容易测试，只需输入Firebug的控制台：<br>document.getElementsByTagName(‘*’).length</p><blockquote><h3 id="拆分组件跨域"><a href="#拆分组件跨域" class="headerlink" title="拆分组件跨域"></a>拆分组件跨域</h3></blockquote><p>拆分组件可让您最大限度地平行下载。由于DNS查找惩罚，请确保您使用的域不超过2-4个。</p><blockquote><h3 id="尽量减少iframe的数量"><a href="#尽量减少iframe的数量" class="headerlink" title="尽量减少iframe的数量"></a>尽量减少iframe的数量</h3></blockquote><p>Iframe允许将HTML文档插入到父文档中。了解iframe如何工作以便可以有效使用非常重要。</p><ul><li><p><code>&lt;iframe&gt;</code>优点：</p><ul><li>像徽章和广告等缓慢的第三方内容</li><li>安全沙箱</li><li>并行下载脚本</li></ul></li><li><p><code>&lt;iframe&gt;</code>缺点：</p><ul><li>即使空白也很昂贵</li><li>阻止页面载入</li><li>非语义</li></ul></li></ul><blockquote><h3 id="避免404"><a href="#避免404" class="headerlink" title="避免404"></a>避免404</h3></blockquote><p>HTTP请求很昂贵，因此提出HTTP请求并获得无用的响应（即404 Not Found）是完全没有必要的，并且会减慢用户体验而没有任何好处。</p><p>有些网站有帮助的404s“你的意思是X？”，这对用户体验很好，但也浪费了服务器资源（如数据库等）。特别糟糕的是，当到外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应正文，就好像它是JavaScript代码一样，试图找到可用的东西。</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><blockquote><h3 id="将样式表放置在顶部"><a href="#将样式表放置在顶部" class="headerlink" title="将样式表放置在顶部"></a>将样式表放置在顶部</h3></blockquote><p>将样式表移动到文档HEAD中,页面显示加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。这改善了整体用户体验。</p><p>将样式表放在文档底部附近的问题:它禁止在许多浏览器（包括Internet Explorer）中进行渐进式呈现。这些浏览器会阻止渲染，以避免在样式更改时重新绘制页面元素。用户停留在查看空白页面。</p><p>没有任何替代方案，空白屏幕或无风格内容的闪光都值得冒这个风险。最佳解决方案是遵循HTML规范，并将样式表加载到文档HEAD中。</p><blockquote><h3 id="避免使用CSS表达式"><a href="#避免使用CSS表达式" class="headerlink" title="避免使用CSS表达式"></a>避免使用CSS表达式</h3></blockquote><p>CSS表达式是动态设置CSS属性的强大（也是危险的）方法。<br>从版本5开始，它们在Internet Explorer中受支持，但从IE8开始已弃用。</p><p>表达式的问题在于它们比大多数人期望的更频繁地进行评估。</p><p>减少CSS表达式评估次数的一种方法是使用一次性表达式，第一次评估表达式时，它将style属性设置为一个显式值，该值将替换CSS表达式。</p><p>如果样式属性必须在页面的整个生命周期中动态设置，则使用事件处理程序而不是CSS表达式是一种替代方法。</p><p>如果您必须使用CSS表达式，请记住它们可能会被评估数千次，并且可能会影响页面的性能。</p><blockquote><h3 id="用-lt-link-gt-替代-import"><a href="#用-lt-link-gt-替代-import" class="headerlink" title="用&lt;link&gt;替代@import"></a>用<code>&lt;link&gt;</code>替代@import</h3></blockquote><p>以前的最佳实践之一指出，为了允许渐进式渲染，CSS应该处于顶端。</p><p>在IE中的@import行为与<link>在页面底部使用的行为相同，因此最好不要使用它。</p><blockquote><h3 id="避免过滤器Filters"><a href="#避免过滤器Filters" class="headerlink" title="避免过滤器Filters"></a>避免过滤器Filters</h3></blockquote><p>IE专有AlphaImageLoader过滤器旨在解决IE版本&lt;7中的半透明真彩色PNG问题。该过滤器的问题在于，它会在图像下载时阻止渲染并冻结浏览器。它也增加了内存消耗，并且每个元素应用，而不是每个图像，因此问题倍增。</p><p>最好的方法是AlphaImageLoader完全避免使用PNG8而不是降级，这在IE中是很好的。如果您绝对需要AlphaImageLoader，请使用下划线黑客_filter来惩罚您的IE7 +用户。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><blockquote><h3 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h3></blockquote><p>脚本导致的问题是它们会阻止并行下载。</p><p>在HTTP / 1.1规范建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以同时发生两个以上的下载。然而，当脚本正在下载时，浏览器将不会启动任何其他下载，即使是在不同的主机名上。</p><p>在某些情况下，将脚本移动到底部并不容易。例如，如果脚本用于document.write插入页面内容的一部分，则不能在页面中移动较小的内容。也可能存在范围问题。在很多情况下，有办法解决这些情况。</p><p>经常出现的另一个建议是使用延迟脚本。<br>该DEFER属性指示该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该DEFER属性。在Internet Explorer中，该脚本可能会延迟，但不如预期的那么多。如果脚本可以被延期，它也可以被移动到页面的底部。这会让你的网页加载速度更快。</p><blockquote><h3 id="使JavaScript和CSS在外部"><a href="#使JavaScript和CSS在外部" class="headerlink" title="使JavaScript和CSS在外部"></a>使JavaScript和CSS在外部</h3></blockquote><p>许多这些性能规则涉及如何管理外部组件。但是，在出现这些问题之前，您应该提出一个更基本的问题：JavaScript和CSS应该包含在外部文件中还是包含在页面本身中？</p><p>在现实世界中<code>使用外部文件通常会产生更快的页面</code>，因为浏览器会缓存JavaScript和CSS文件。</p><ul><li>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</li><li>JavaScript和CSS位于浏览器缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><p>许多网站都处于这些指标的中间。对于这些网站，最好的解决方案通常是将JavaScript和CSS作为外部文件进行部署。首选内联的唯一例外是主页，例如雅虎的首页和My Yahoo! 。每个会话只有很少（可能只有一个）页面视图的主页可能会发现内嵌JavaScript和CSS可以缩短最终用户的响应时间。</p><p>对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少以及通过使用外部文件实现的缓存优点。其中一种方法是在首页内嵌JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已经在浏览器缓存中的外部文件。</p><blockquote><h3 id="精简JavaScript和CSS"><a href="#精简JavaScript和CSS" class="headerlink" title="精简JavaScript和CSS"></a>精简JavaScript和CSS</h3></blockquote><ul><li>在JavaScript的情况下，由于下载文件的大小减小，这提高了响应时间性能。</li><li>从代码中移除不必要的字符以减少其大小，减少加载时间。</li><li><p>减少JavaScript 文件大小的有几种手段:</p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。</li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。</li></ul></li></ul><blockquote><h3 id="删除重复的脚本"><a href="#删除重复的脚本" class="headerlink" title="删除重复的脚本"></a>删除重复的脚本</h3></blockquote><p>在一个页面中包含两次相同的JavaScript文件会使性能受损。</p><p>当它发生时，通过创建不必要的HTTP请求和浪费JavaScript执行，重复脚本会损害性能。</p><p>不必要的HTTP请求发生在Internet Explorer中，但不在Firefox中。</p><p>在Internet Explorer中，如果外部脚本包含两次并且不可缓存，则会在加载页面期间生成两个HTTP请求。如果脚本可缓存，当用户重新加载页面时也会发生额外的HTTP请求。</p><p>除了生成浪费的HTTP请求之外，还会浪费多次时间评估脚本。无论脚本是否可缓存，此冗余JavaScript执行都会在Firefox和Internet Explorer中发生。</p><blockquote><h3 id="最小化DOM访问"><a href="#最小化DOM访问" class="headerlink" title="最小化DOM访问"></a>最小化DOM访问</h3></blockquote><p>使用JavaScript访问DOM元素很慢，所以为了获得更响应的页面，您应该：</p><ul><li>缓存对访问元素的引用</li><li>更新节点“脱机”，然后将它们添加到树中</li><li>避免使用JavaScript修复布局</li></ul><blockquote><h3 id="开发智能事件处理程序"><a href="#开发智能事件处理程序" class="headerlink" title="开发智能事件处理程序"></a>开发智能事件处理程序</h3></blockquote><p>有时由于过多的事件处理程序附加到DOM树的不同元素上，而这些事件处理程序过于频繁地执行，有时页面的响应速度会降低 这就是为什么使用事件授权是一个好方法。</p><p>如果在a中有10个按钮div，则只将一个事件处理程序附加到div包装器，而不是每个按钮的一个处理程序。事件冒泡，所以你可以捕捉事件并找出它起源于哪个按钮。</p><p>您也不需要等待onload事件才能开始使用DOM树进行操作。通常你需要的是你想访问的元素在树中可用。您不必等待下载所有图像。</p><p>DOMContentLoaded是您可能考虑使用而不是onload的事件.</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><blockquote><h3 id="优化图像"><a href="#优化图像" class="headerlink" title="优化图像"></a>优化图像</h3></blockquote><ul><li><p>减少图像周围的空白。 一些开发人员使用空白的填充这是万万要不得的。裁剪图像，删除图像周围任何空白，并使用CSS来填充。</p></li><li><p>使用正确的文件格式。如果你有图标，或者没有太多颜色的图形，可以保存为GIF这种较少颜色的图形。如果你有更详细的图形，可以使用JPG文件格式，降低质量保存图像。</p></li><li>以适当的尺寸保存图像。如果您正在使用HTML和CSS来调整您的图像，那么不要这样。以期望的大小保存你的图像，从而减少文件大小。</li></ul><blockquote><p>恰当的图片格式：</p><ul><li>PNG格式几乎一直优于GIF格式，尽管某些旧版浏览器只能为PNG格式提供部分支持。</li><li>为较小或简单的图形（例如，小于10x10像素的图形或调色板小于3色的图形）以及包含动画的图片使用GIF格式。</li><li>为所有摄影风格的图片使用JPG格式。</li><li>请勿使用BMP格式或TIFF格式。</li></ul></blockquote><blockquote><h3 id="优化CSS精灵"><a href="#优化CSS精灵" class="headerlink" title="优化CSS精灵"></a>优化CSS精灵</h3></blockquote><p>一种网页图片应用处理方式。允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，再利用CSS的以下属性精确的定位出背景图片的位置。</p><blockquote><p>background-image<br>background- repeat<br>background-position</p></blockquote><blockquote><h3 id="不要在HTML中缩放图像"><a href="#不要在HTML中缩放图像" class="headerlink" title="不要在HTML中缩放图像"></a>不要在HTML中缩放图像</h3></blockquote><p>指定所有图片的宽度和高度可以加速渲染，因为省去了不必要的回流和重绘。</p><blockquote><h3 id="制作favicon-icoSmall和Cacheable"><a href="#制作favicon-icoSmall和Cacheable" class="headerlink" title="制作favicon.icoSmall和Cacheable"></a>制作<code>favicon.icoSmall</code>和Cacheable</h3></blockquote><p>favicon.ico是保留在服务器根目录中的映像。这是一个必要的罪恶，因为即使你不关心它，浏览器仍然会请求它，所以最好不要回应404 Not Found。</p><p>另外，由于它位于同一台服务器上，每次请求时都会发送Cookie。此图片还会干扰下载顺序，例如在IE中，当您在onload中请求额外的组件时，favicon会在这些额外的组件之前下载。</p><p>因此，要减轻拥有favicon.ico的缺点，请确保：</p><ul><li>它很小，最好在1K以下。</li><li>设置过期标题与你感觉舒适（因为你不能重命名，如果你决定改变它）。您几乎可以在将来几个月安全地设置Expires标题。您可以查看您当前的favicon.ico的最后修改日期，以做出明智的决定。</li><li>Imagemagick可以帮助您创建小型图标</li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><blockquote><h3 id="减小Cookie大小"><a href="#减小Cookie大小" class="headerlink" title="减小Cookie大小"></a>减小Cookie大小</h3></blockquote><p>HTTP cookie由于各种原因（如身份验证和个性化）而被使用。有关cookie的信息在Web服务器和浏览器之间的HTTP标头中交换。尽可能降低cookies的大小以尽量减少对用户响应时间的影响，这一点很重要。</p><ul><li>消除不必要的cookie</li><li>尽可能降低Cookie大小，以尽量减少对用户响应时间的影响</li><li>请注意在适当的域级别设置cookie，以便其他子域不受影响</li><li>适当设置过期日期。更早的过期日期或不更早删除cookie，提高用户响应时间</li></ul><blockquote><h3 id="页面内容使用无Cookie域"><a href="#页面内容使用无Cookie域" class="headerlink" title="页面内容使用无Cookie域"></a>页面内容使用无Cookie域</h3></blockquote><p>当浏览器发出静态图像请求并将cookie与请求一起发送时，服务器对这些cookie没有任何用处。所以他们只是没有理由地创建网络流量。您应该确保使用无cookie请求来请求静态组件。创建一个子域，并在其中托管所有静态组件。</p><p>在无Cookie域上托管静态组件的另一个好处是，某些代理可能会拒绝缓存使用cookie请求的组件。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><blockquote><h3 id="使用内容分发网络CDN"><a href="#使用内容分发网络CDN" class="headerlink" title="使用内容分发网络CDN"></a>使用内容分发网络CDN</h3></blockquote><ul><li>用户与Web服务器的距离对响应时间有影响。在多个地理位置分散的服务器上部署您的内容将使您的网页从用户的角度更快加载。但是你应该从哪里开始？</li></ul><p>作为实现地理上分散的内容的第一步，不要尝试重新设计您的Web应用程序以在分布式架构中工作。根据应用程序的不同，更改体系结构可能包括艰巨的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与内容之间的距离可能会延迟或不能通过此应用程序体系结构步骤。</p><p>请记住，80-90％的最终用户响应时间用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是性能黄金法则。</p><p>不要从重新设计应用程序体系结构的艰巨任务开始，最好先分散您的静态内容。这不仅实现了响应时间的更大缩短，而且由于内容交付网络，这更容易实现。</p><p><code>内容传送网络（CDN）</code>是分布在多个位置的网络服务器的集合，以更高效地向用户传送内容。选择用于将内容递送给特定用户的服务器通常基于网络邻近度的度量。例如，选择网络跳数最少的服务器或响应时间最快的服务器。</p><p>一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如Akamai Technologies，EdgeCast或level3）具有成本效益。对于创业公司和私人网站来说，CDN服务的成本可能会很高，但随着您的目标受众不断扩大并变得更加全球化，CDN是实现快速响应所必需的。</p><blockquote><h3 id="添加Expires或Cache-Control标题"><a href="#添加Expires或Cache-Control标题" class="headerlink" title="添加Expires或Cache-Control标题"></a>添加Expires或<code>Cache-Control</code>标题</h3></blockquote><p>这条规则有两个方面：</p><ul><li>对于静态组件：通过设置远期<code>Expires</code>标题实现“永不过期”策略</li><li>对于动态组件：使用适当的<code>Cache-Control</code>头文件来帮助浏览器提供有条件的请求</li></ul><p>网页设计越来越丰富，这意味着更多的脚本，样式表，图像和Flash在页面中。</p><p>首次访问您的页面可能需要发出多个HTTP请求，但通过使用Expires标头，可以使这些组件可缓存。这避免了后续页面浏览中不必要的HTTP请求。</p><p>过期标头最常用于图像，但它们应该用于所有组件，包括脚本，样式表和Flash组件。</p><p>浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，使网页加载速度更快。<br>Web服务器使用HTTP响应中的Expires标头告诉客户端可以缓存组件的时间。</p><p>请记住，如果您使用远期未来的Expires头文件，则只要组件更改，就必须更改组件的文件名。</p><p>只有在用户已经访问过您的网站后，使用远期未来的Expires标题才会影响页面浏览。</p><p>当用户第一次访问您的网站并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。</p><p>因此，这种性能改进的影响取决于用户多久访问一次带有缓冲区的页面。（一个“准备好的缓存”已经包含了页面中的所有组件。）我们在Yahoo!上测试了这一点。并发现带有引导缓存的页面浏览量为75-85％。通过使用远期未来的Expires标题，您可以增加浏览器缓存的组件数量，并在后续页面浏览中重新使用，而无需在用户的Internet连接上发送单个字节。</p><blockquote><h3 id="Gzip压缩传输文件"><a href="#Gzip压缩传输文件" class="headerlink" title="Gzip压缩传输文件"></a>Gzip压缩传输文件</h3></blockquote><p>通过网络传输HTTP请求和响应所需的时间可以通过前端工程师做出的决策大大减少。</p><p>确实，最终用户的带宽速度，互联网服务提供商，邻近对等交换点等是超出了开发团队的控制范围。</p><p>但还有其他一些影响响应时间的因素。</p><p>压缩通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP / 1.1开始，Web客户端通过HTTP请求中的Accept-Encoding标头指示对压缩的支持。</p><pre><code>Accept-Encoding：gzip，deflate</code></pre><p>如果Web服务器在请求中看到该头部，则可能使用客户端列出的方法之一压缩响应。</p><p>Web服务器通过响应中的Content-Encoding标头通知Web客户端。</p><pre><code>内容编码：gzip</code></pre><blockquote><p>Gzip是目前最流行和最有效的压缩方法。它由GNU项目开发并由RFC 1952标准化。您可能会看到的唯一的其他压缩格式是压缩，但效果不太好，不太受欢迎。Gzipping通常将响应大小减少约70％。目前大约90％的互联网流量都通过声称支持gzip的浏览器。</p></blockquote><blockquote><p>浏览器和代理存在已知的问题，这些问题可能会导致浏览器期望的不匹配和接收到的有关压缩内容的不匹配。幸运的是，随着旧版浏览器的使用下降，这些边缘案例正在减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。</p></blockquote><p>服务器根据文件类型选择要压缩的内容，但在决定压缩的内容时通常太有限。</p><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。</p><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p><p>尽可能多地缩放文件类型是减少页面重量和加速用户体验的简单方法。</p><blockquote><h3 id="配置ETags"><a href="#配置ETags" class="headerlink" title="配置ETags"></a>配置ETags</h3></blockquote><p>实体标签（ETags）是Web服务器和浏览器用来确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（一个“实体”是另一个词“组件”：图像，脚本，样式表等）</p><p>ETag被添加来提供一种机制来验证比上一次修改日期更灵活的实体。</p><p>ETag是唯一标识组件特定版本的字符串。唯一的格式约束是字符串被引用。原始服务器使用ETag响应头指定组件的ETag 。</p><pre><code>HTTP / 1.1 200 OKLast-Modified：Tue，2006年12月12日03:03:59 GMTETag：“10c24bc-4ab-457e1c1f”内容长度：12195</code></pre><p>之后，如果浏览器必须验证组件，它将使用If-None-Match标头将ETag传递回原始服务器。如果ETags匹配，则返回一个304状态码，在此示例中将响应减少12195字节。</p><pre><code>GET /i/yahoo.gif HTTP / 1.1主持人：us.yimg.comIf-Modified-Since：星期二，2006年12月12日03:03:59 GMTIf-None-Match：“10c24bc-4ab-457e1c1f”HTTP / 1.1 304未修改</code></pre><p>ETags的问题在于，它们通常使用属性来构建，这些属性使它们对托管站点的特定服务器是唯一的。</p><p>当浏览器从一台服务器获取原始组件并稍后尝试在另一台服务器上验证该组件时，ETags将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。</p><p>虽然给定的文件可能位于多个服务器的相同目录中，并且具有相同的文件大小，权限，时间戳等，但其inode不同于一台服务器。</p><p>IIS 5.0和6.0与ETags有类似的问题。IIS上ETags的格式是Filetimestamp:ChangeNumber。A ChangeNumber是用于跟踪IIS配置更改的计数器。ChangeNumber在网站后面的所有IIS服务器上都不可能是相同的。</p><p>最终结果是由Apache和IIS生成的ETags完全相同的组件不会从一台服务器到另一台服务器进行匹配。如果ETags不匹配，用户不会收到ETags设计的小而快的304响应; 相反，他们会得到一个正常的200响应以及组件的所有数据。</p><p>如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多台服务器托管您的网站，并且您使用的是默认的ETag配置的Apache或IIS，那么您的用户的页面速度会变慢，您的服务器的负载会更高，消耗的带宽也会更大，高效地缓存您的内容。即使你的组件有一个遥远的将来Expires头，当用户点击重新加载或刷新时，仍然会发出条件GET请求。</p><p>如果您没有充分利用ETags提供的灵活验证模型，最好完全删除ETag。</p><p>该Last-Modified头验证基于对组件的时间戳。</p><p>删除ETag可以减少响应和后续请求中HTTP头的大小。</p><blockquote><h3 id="尽早flush输出"><a href="#尽早flush输出" class="headerlink" title="尽早flush输出"></a>尽早flush输出</h3></blockquote><p>当用户请求页面时，后端服务器可能需要200到500毫秒才能将HTML页面拼接在一起。在此期间，浏览器在等待数据到达时处于空闲状态。</p><p>在PHP中，你有函数flush（）。</p><p>它允许您将部分就绪的HTML响应发送到浏览器，以便浏览器可以在您的后端忙于HTML页面的其余部分时开始获取组件。好处主要出现在繁忙的后端或前端。<br>考虑刷新的好地方就在HEAD之后，因为头部的HTML通常更容易生成，并且允许您在浏览器中包含任何CSS和JavaScript文件，以便在后端仍在处理的同时开始并行读取。</p><blockquote><h3 id="使用GET获取AJAX请求"><a href="#使用GET获取AJAX请求" class="headerlink" title="使用GET获取AJAX请求"></a>使用GET获取AJAX请求</h3></blockquote><p>在使用时XMLHttpRequest，POST在浏览器中实现为两步：首先发送标题，然后发送数据。所以最好使用GET，它只需要一个TCP数据包发送（除非你有很多的cookie）。</p><p>IE中最大的URL长度是2K，所以如果你发送的数据超过2K，你可能无法使用GET。</p><p>一个有趣的副作用是POST没有实际发布任何数据就像GET一样。</p><p>基于HTTP规范，GET旨在用于检索信息，所以在您仅请求数据时使用GET（在语义上）是合理的，而不是将数据发送到服务器端存储。</p><blockquote><h3 id="避免空图像src"><a href="#避免空图像src" class="headerlink" title="避免空图像src"></a>避免空图像src</h3></blockquote><p>具有空字符串src属性的图像会发生超过一个人的预期。它以两种形式出现：</p><ul><li><code>&lt;img src =“”&gt;</code></li><li><code>var img = new Image（）;</code><br><code>img.src =“”;</code></li></ul><p>两种形式都会产生相同的效果：浏览器向您的服务器发出另一个请求</p><blockquote><p>Internet Explorer向该页面所在的目录发出请求。<br>Safari和Chrome向实际页面本身发出请求。<br>Firefox 3和更早版本的行为与Safari和Chrome相同，但版本3.5解决了此问题[错误444931]，不再发送请求。<br>当遇到空图像src时，Opera不会执行任何操作。</p></blockquote><p>为什么这种行为不好？</p><ul><li>通过发送大量意外流量来瘫痪您的服务器，特别是对于每天获得数百万页面浏览量的页面。</li><li>浪费服务器计算周期生成一个永远不会被查看的页面。</li><li>可能损坏的用户数据。如果您通过Cookie或以其他方式跟踪请求中的状态，则可能会销毁数据。即使图像请求没有返回图像，浏览器也会读取并接受所有标题，包括所有的Cookie。虽然其余的反应被抛弃，但损害可能已经完成。</li></ul><h2 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h2><blockquote><h3 id="保持组件低于25K"><a href="#保持组件低于25K" class="headerlink" title="保持组件低于25K"></a>保持组件低于25K</h3></blockquote><p>此限制与iPhone不会缓存大于25K的组件有关。请注意，这是未压缩的大小。这是缩小比例很重要的地方，因为gzip本身可能不够。</p><blockquote><h3 id="将组件打包成多部分文档"><a href="#将组件打包成多部分文档" class="headerlink" title="将组件打包成多部分文档"></a>将组件打包成多部分文档</h3></blockquote><p>将组件打包成多部分文档就像带有附件的电子邮件一样，它可以帮助您用一个HTTP请求获取多个组件（记住：HTTP请求很贵）。当你使用这种技术时，首先检查用户代理是否支持它（iPhone不支持）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小结于&quot;&gt;&lt;a href=&quot;#小结于&quot; class=&quot;headerlink&quot; title=&quot;小结于&quot;&gt;&lt;/a&gt;小结于&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1#menu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器请求和响应过程来谈性能优化</title>
    <link href="https://hotkang.cn/2018/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B%E6%9D%A5%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://hotkang.cn/2018/从浏览器请求和响应过程来谈性能优化/</id>
    <published>2018-05-29T00:52:08.000Z</published>
    <updated>2018-07-19T15:35:12.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小结于"><a href="#小结于" class="headerlink" title="小结于"></a>小结于</h2><p><img src="/img/XNGC.png" alt=""></p><a id="more"></a><ul><li><p>为什么前端性能如此重要？数据显示：</p><ul><li>只有10%~20%的最终用户响应时间用来下载HTML文档，其余80%~90%时间用在下载页面中的所有组件</li><li>优化后台成本大，优化前端只需要适当遵循一些法则就会有较大的提升，低成本高收益</li></ul></li></ul><h2 id="一、浏览器预处理"><a href="#一、浏览器预处理" class="headerlink" title="一、浏览器预处理"></a>一、浏览器预处理</h2><ul><li>查询Cache：读取Cache或者发送304 请求</li></ul><h2 id="二、查询DNS"><a href="#二、查询DNS" class="headerlink" title="二、查询DNS"></a>二、查询DNS</h2><blockquote><p>DNS查找就是输入域名对服务器IP地址的查找过程。<br>DNS缓存: 浏览器DNS缓存、操作系统DNS缓存。<br>当你输入<a href="http://www.google.com的时候，浏览器会先去自身的" target="_blank" rel="noopener">www.google.com的时候，浏览器会先去自身的</a> <code>DNS缓存</code> 里面查找有没有google服务器的IP地址;如果找不到则继续到 <code>操作系统的DNS缓存</code> 查找;如果浏览器在这两个容器都没有找到google的IP地址记录，则会向广域域名体系查找。</p></blockquote><h3 id="1-优化规则-减少DNS查找"><a href="#1-优化规则-减少DNS查找" class="headerlink" title="1. 优化规则 - 减少DNS查找"></a><code>1. 优化规则 - 减少DNS查找</code></h3><ul><li>方法1：使用DNS缓存<br>浏览器DNS缓存 | 计算机DNS缓存 | 服务器DNS缓存（TTL）</li></ul><ul><li><p>方法2：使用Keep-Alive特性<br>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。</p></li><li><p>方法3：较少的域名来减少DNS查找（2-4个主机）</p></li><li><p>方法4：使用第三方DNS域名解析加速服务<br>国内的一款免费DNS加速服务DNSPOD；</p></li></ul><h2 id="三、建立连接"><a href="#三、建立连接" class="headerlink" title="三、建立连接"></a>三、建立连接</h2><blockquote><p>CDN是一组分布在多个不同地理位置的Web服务器，由于距离用户 物理距离比较短，所以能够更加有利于用户获取到静态资源；这种服务通常需要购买，也有一些免费、通用的CDN可使用，国内的可以使用BootCDN。</p></blockquote><h3 id="2-优化规则-–-使用内容分发网络（CDN）"><a href="#2-优化规则-–-使用内容分发网络（CDN）" class="headerlink" title="2. 优化规则 – 使用内容分发网络（CDN）"></a><code>2. 优化规则 – 使用内容分发网络（CDN）</code></h3><ul><li><p>方法1：美国十大Internet网站和CDN服务提供商</p></li><li><p>方法2：页面静态化,取决于发布系统</p></li><li><p>方法3：Ctrip使用的China-Cache和网宿</p></li></ul><h3 id="3-优化规则-–-用域名划分页面内容"><a href="#3-优化规则-–-用域名划分页面内容" class="headerlink" title="3. 优化规则 – 用域名划分页面内容"></a><code>3. 优化规则 – 用域名划分页面内容</code></h3><p>按页面内容划分域名，在合适的资源服务器上存放文件</p><h2 id="四、发送请求"><a href="#四、发送请求" class="headerlink" title="四、发送请求"></a>四、发送请求</h2><blockquote><p>一般来说，使用外链的脚本和样式表更加有利。分别把外链脚本和样式表进行合并会减少HTTP请求，以节省客户端和服务器之间的通讯次数来加快页面打开速度。但是出于开发的便利，开发的时候一般会采取模块化的方式；这时候可以在部署前采用一些前端构建工具 <code>gulp</code> 、<code>grunt</code> 把这些模块文件合并起来再发布。</p></blockquote><h3 id="4-优化规则-–-减少HTTP请求"><a href="#4-优化规则-–-减少HTTP请求" class="headerlink" title="4. 优化规则 – 减少HTTP请求"></a><code>4. 优化规则 – 减少HTTP请求</code></h3><ul><li><p>图片地图</p><ul><li>假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。</li></ul><p><img src="/img/JL.png" alt=""></p><ul><li>服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应</li><li>客户端图片地图：直接将点击映射到操作</li></ul></li><li><p>内联图像</p></li><li><p>合并文件: js文件不超过7个,css文件不超过4个,各频道首页和全站首页不超过3个;</p></li><li>目前无法解决的是allyes广告的请求数。</li><li>大量的广告和产品图片可能会造成，图片请求数很大，可能造成总请求数指标吃紧，这个只能从设计上搞定，需要权衡</li><li><p>目前老页面可能css和js文件请求数可能会超标</p></li><li><p>合并样式和脚本</p></li></ul><h3 id="5-优化规则-–-优化CSS-Spirite-图片精灵"><a href="#5-优化规则-–-优化CSS-Spirite-图片精灵" class="headerlink" title="5. 优化规则 – 优化CSS Spirite(图片精灵)"></a><code>5. 优化规则 – 优化CSS Spirite(图片精灵)</code></h3><p>一种网页图片应用处理方式。允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，再利用CSS的以下属性精确的定位出背景图片的位置。</p><blockquote><p>background-image<br>background- repeat<br>background-position</p></blockquote><h3 id="6-优化规则-–-避免404错误"><a href="#6-优化规则-–-避免404错误" class="headerlink" title="6. 优化规则 – 避免404错误"></a><code>6. 优化规则 – 避免404错误</code></h3><p>HTTP请求很昂贵，因此提出HTTP请求并获得无用的响应（即404 Not Found）是完全没有必要的，会减慢用户体验没有任何好处。</p><p>有些网站有帮助的404“你的意思是X？”，这对用户体验很好，但也浪费了服务器资源（如数据库等）。</p><p>特别糟糕的是，当到外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应正文，就好像它是JavaScript代码一样，试图找到可用的东西。</p><h3 id="7-优化规则-–-不要使用frameset-少使用iframe"><a href="#7-优化规则-–-不要使用frameset-少使用iframe" class="headerlink" title="7. 优化规则 – 不要使用frameset,少使用iframe"></a><code>7. 优化规则 – 不要使用frameset,少使用iframe</code></h3><p>搜索引擎不友好，即使内容为空，加载也需要时间、会阻止页面加载</p><p>Iframe允许将HTML文档插入到父文档中。了解iframe如何工作以便可以有效使用非常重要。</p><ul><li><p><code>&lt;iframe&gt;</code>优点：</p><ul><li>像徽章和广告等缓慢的第三方内容</li><li>安全沙箱</li><li>并行下载脚本</li></ul></li><li><p><code>&lt;iframe&gt;</code>缺点：</p><ul><li>即使空白也很昂贵</li><li>阻止页面载入</li><li>非语义</li></ul></li></ul><p>禁止使用iframe引入外部资源，不包括allyes广告，不包括about:blank的空页面。</p><h2 id="五、等待响应"><a href="#五、等待响应" class="headerlink" title="五、等待响应"></a>五、等待响应</h2><h3 id="8-优化规则-–-避免重定向"><a href="#8-优化规则-–-避免重定向" class="headerlink" title="8. 优化规则 – 避免重定向"></a><code>8. 优化规则 – 避免重定向</code></h3><p>以下是一个重定向的过程：</p><p>浏览器发送请求——&gt;服务器返回302——&gt;浏览器发送第二次请求—–&gt;服务器返回200—&gt;浏览器开始呈现</p><p>就是说，在重定向完毕并且HTML下载完毕之前，是没有任何东西显示给用户</p><p>要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。</p><p>涉及服务器负载、数据查询、服务器端缓存等</p><h2 id="六、接收数据"><a href="#六、接收数据" class="headerlink" title="六、接收数据"></a>六、接收数据</h2><h3 id="9-优化规则-–-压缩组件Gzip"><a href="#9-优化规则-–-压缩组件Gzip" class="headerlink" title="9. 优化规则 – 压缩组件Gzip"></a><code>9. 优化规则 – 压缩组件Gzip</code></h3><ul><li><p>HTML文档、脚本和样式表、XML和JSON的文本响应,压缩通常能将响应的数据量减少将近70%</p></li><li><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。</p></li><li><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p></li></ul><h3 id="10-优化规则-–-精简Javascript和CSS文件大小"><a href="#10-优化规则-–-精简Javascript和CSS文件大小" class="headerlink" title="10. 优化规则 – 精简Javascript和CSS文件大小"></a><code>10. 优化规则 – 精简Javascript和CSS文件大小</code></h3><ul><li><p>从代码中移除不必要的字符以减少其大小，减少加载时间。</p></li><li><p>减少JavaScript 文件大小的有几种手段:</p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。</li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。</li></ul></li></ul><h3 id="11-优化规则-–-尽量缩减页面大小"><a href="#11-优化规则-–-尽量缩减页面大小" class="headerlink" title="11. 优化规则 – 尽量缩减页面大小"></a><code>11. 优化规则 – 尽量缩减页面大小</code></h3><ul><li><p>页面必须小于150K(不含图片）</p></li><li><p>静态文件是否gzip</p></li><li>图片是否压缩优化过</li></ul><h2 id="七、读取Cache"><a href="#七、读取Cache" class="headerlink" title="七、读取Cache"></a>七、读取Cache</h2><h3 id="12-优化规则-–-添加-Expires-头或-Cache-Control"><a href="#12-优化规则-–-添加-Expires-头或-Cache-Control" class="headerlink" title="12. 优化规则 – 添加 Expires 头或 Cache-Control"></a><code>12. 优化规则 – 添加 Expires 头或 Cache-Control</code></h3><ul><li><p>Expires头是用来告诉浏览器该响应的有效期，可以理解为该资源的“保质期”，在期限内可以使用该资源的缓存不需要重新请求。</p></li><li><p>由于浏览器与服务器存在时钟同步问题，HTTP1.2.1还添加了Cache-Control和max-age来弥补Expires头的不足。</p></li><li>通常用于脚本、样式表、图片等静态资源。</li></ul><p>使用这种策略可能会遇到一个问题是，开发者可能想要在资源过期前这段时间更新它们。</p><p>这时候，由于浏览器的缓存还没失效，这就需要通过更改文件名来令静态资源 强制失效。有很多种方式给静态资源打上版本号，可以一本正经地打上数字版本号，根据内容生成哈希码也行，甚至有人用π来给自己的资源打版本号.</p><p>应用于不经常变化的组件，包括脚本、样式表、Flash组件、图片</p><h3 id="13-优化规则-–-使用外链JavaScript和CSS"><a href="#13-优化规则-–-使用外链JavaScript和CSS" class="headerlink" title="13. 优化规则 – 使用外链JavaScript和CSS"></a><code>13. 优化规则 – 使用外链JavaScript和CSS</code></h3><ul><li>尽可能 使用外链JavaScript和CSS，因为我们目前大部分avaScript和CSS都做了Gzip和缓存技术，可以充分利用。</li></ul><ul><li><p>使用外链样式和脚本优点有：</p><ul><li>可以被浏览器缓存起来；</li><li>组件可重用</li><li>可模块化；</li><li>能够被构建（合并压缩打版本）</li></ul></li><li><p>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</p></li><li>JavaScript和CSS位于浏览器：缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><h2 id="八、处理元素"><a href="#八、处理元素" class="headerlink" title="八、处理元素"></a>八、处理元素</h2><p>不要对image和pdf等二进制文件进行gzip压缩</p><h2 id="九、渲染元素"><a href="#九、渲染元素" class="headerlink" title="九、渲染元素"></a>九、渲染元素</h2><h3 id="14-优化规则-–-将样式表放在顶部"><a href="#14-优化规则-–-将样式表放在顶部" class="headerlink" title="14. 优化规则 – 将样式表放在顶部"></a><code>14. 优化规则 – 将样式表放在顶部</code></h3><ul><li><p>样式表放在底部时，浏览器会延迟显示任何可视化组件(使用 CSS 的@import 等同于把想要加载的样式放在底部，所以不建议使用。)</p></li><li><p>对于浏览器的渲染机制，本书并没有过多提及，只是对现象做出了描述以及提供了解决办法.</p></li><li><p>如果样式表仍然在加载，构建呈现树就是一种浪费，因为在所有样式表 加载并解析完毕 之前无需绘制任何东西。因为在样式表准备好之前显示内容会遇到 FOUC（无样式内容的闪烁，Flash of Unstyled Content）问题。</p></li><li>样式表不在顶部中，当遇到样式时，浏览器就会阻止页面呈现，等待样式表下载完毕。如果把样式表放在底部，在 IE 中还会产生白屏现象。</li><li>总之，把样式表放进就能避免这些问题。</li></ul><h3 id="15-优化规则-–-建议将脚本放在底部"><a href="#15-优化规则-–-建议将脚本放在底部" class="headerlink" title="15. 优化规则 – 建议将脚本放在底部"></a><code>15. 优化规则 – 建议将脚本放在底部</code></h3><p>一般浏览器可以允许并行下载，取决于主机个数、带宽等（默认情况下，IE是2个而FF是8个）下载脚本时并行下载实际上是被禁用的。</p><ul><li>脚本对页面的影响是：<ul><li>阻塞对其后面内容的呈现</li><li>阻塞后面组件的下载</li><li>浏览器会在下载脚本的时候阻塞并行下载，因为需要确保脚本能够顺序执行。<blockquote><p>但是，实际开发中有时候很难完全遵守这条准则，那只能把能够放在最后的都放在最后。</p></blockquote></li></ul></li></ul><h3 id="16-优化规则-–-移除重复脚本"><a href="#16-优化规则-–-移除重复脚本" class="headerlink" title="16. 优化规则 – 移除重复脚本"></a><code>16. 优化规则 – 移除重复脚本</code></h3><p>必须为0，重复的脚本对增加HTTP 请求次数和脚本执行的时间。</p><h3 id="17-优化规则-–-避免CSS表达式"><a href="#17-优化规则-–-避免CSS表达式" class="headerlink" title="17. 优化规则 – 避免CSS表达式"></a><code>17. 优化规则 – 避免CSS表达式</code></h3><p>使用CSS 的expression()通常会造成多次运算。影响浏览器渲染时间。实际上，需要用到CSS表达式的地方，通常能够找到其他替代方案，所以避免使用CSS表达式。</p><h3 id="18-优化规则-–-优化图像"><a href="#18-优化规则-–-优化图像" class="headerlink" title="18. 优化规则 – 优化图像"></a><code>18. 优化规则 – 优化图像</code></h3><ul><li><p>尽量使用GIF和PNG</p></li><li><p>尽量使用png/gif格式的图片，png的图片优先，但是必须注意如要兼容IE6，则png使用一定要注意透明问题。</p></li><li><p>图片在使用前一定要先用工具压缩优化（png、jpg）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小结于&quot;&gt;&lt;a href=&quot;#小结于&quot; class=&quot;headerlink&quot; title=&quot;小结于&quot;&gt;&lt;/a&gt;小结于&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/XNGC.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
