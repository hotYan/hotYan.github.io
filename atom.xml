<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hotYan&#39;s Blog</title>
  
  <subtitle>程序媛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hotkang.cn/"/>
  <updated>2018-07-11T16:38:23.628Z</updated>
  <id>https://hotkang.cn/</id>
  
  <author>
    <name>hotYan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在GitHub Pages上部署自己的简历</title>
    <link href="https://hotkang.cn/2018/06/28/%E5%9C%A8GitHub-Pages%E4%B8%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    <id>https://hotkang.cn/2018/06/28/在GitHub-Pages上部署自己的简历/</id>
    <published>2018-06-28T09:11:27.000Z</published>
    <updated>2018-07-11T16:38:23.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitHub-Pages-完结"><a href="#GitHub-Pages-完结" class="headerlink" title="GitHub Pages [完结]"></a>GitHub Pages <span style="font-size:.5em">[完结]</span></h2><p><img src="/img/GHP.png" alt=""></p><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>  </li></ul></blockquote><p>看了很多教程,发现官网是说的最简洁明了又清楚的,最终解决了我的问题。建议打开<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>,两边参考着看更简单易懂。</p><hr><h2 id="一、什么是GitHub-Pages"><a href="#一、什么是GitHub-Pages" class="headerlink" title="一、什么是GitHub Pages"></a>一、什么是GitHub Pages</h2><ol><li><p>GitHub Pages是一个静态站点托管服务,旨在直接从GitHub存储库托管我们的个人,组织或项目页面。不支持服务器端代码，例如PHP，Ruby或Python。   </p></li><li><p>我们可以使用Jekyll Theme Chooser在线创建和发布GitHub Pages网站。我们也可以在本地工作，使用【GitHub Desktop】或【命令行】。  </p></li></ol><p>注意:  </p><ul><li><strong><a href="https://desktop.github.com/" target="_blank" rel="noopener">GitHub Desktop</a></strong>:一个上传项目到github的软件。不想用命令行的不二选择。  </li><li><strong><a href="https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/" target="_blank" rel="noopener">命令行</a></strong>:指使用git命令上传项目  </li></ul><p>【PS:不会命令行没关系，谁敢说自己连一个软件都不会用呀？】  </p><h2 id="二、GitHub-Pages-提供什么"><a href="#二、GitHub-Pages-提供什么" class="headerlink" title="二、GitHub Pages 提供什么"></a>二、GitHub Pages 提供什么</h2><p>在官网上有这样一句话:  </p><pre><code>You get one site per GitHub account and organization,and unlimited project sites. </code></pre><p>意思是:</p><pre><code>GitHub Pages为每个GitHub帐户/组织提供一个【站点】,以及无限制的【项目站点】。</code></pre><blockquote><p>注意:<br>1.我们只能有一个【User or organization site】;但是我们可以有很多【Project site】。 </p><p>2.部署简历用【User or organization site】简直是大材小用,用【Project site】就可以了。  </p><p>3.【User or organization site】可以拿来部署个人博客,点击<a href="https://hotyan.github.io/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/" target="_blank" rel="noopener">用hexo搭建github博客</a>了解如何搭建个人博客。</p></blockquote><h2 id="三、准备工作"><a href="#三、准备工作" class="headerlink" title="三、准备工作"></a>三、准备工作</h2><p>1、默认已有GitHub账号,并已创建好存储库或会创建存储库。</p><ul><li>没有GitHub账号？？<a href="https://github.com/" target="_blank" rel="noopener">点击注册</a>   </li><li>没有存储库？？<a href="https://help.github.com/articles/creating-a-new-repository/" target="_blank" rel="noopener">了解如何创建</a>     </li></ul><p>2、默认已有html简历,命名为 index.html   </p><ul><li>没有简历？？<a href="http://cv.qiaobutang.com/" target="_blank" rel="noopener">制作并下载</a></li></ul><h2 id="四、简历部署"><a href="#四、简历部署" class="headerlink" title="四、简历部署"></a>四、简历部署</h2><blockquote><p>创建新存储库 </p></blockquote><ol><li><p>点击右上角 <strong>+</strong> 选择 <strong>New repository</strong></p></li><li><p>填写 <strong>Repository name</strong> 并勾选 <strong>Initialize this repository with a README</strong></p></li><li>点击 <strong>Create repository</strong> 完成创建</li></ol><blockquote><p>上传简历  </p></blockquote><ol><li><p>在新建的存储库点击 <strong>Upload files</strong></p></li><li><p>点击 <strong>choose your files</strong> 上传你的 <strong>index.html</strong> 文件</p></li><li>点击 <strong>Commit changes</strong> 完成上传  </li></ol><blockquote><p>部署</p></blockquote><ol><li><p>点击 <strong>Settings</strong> 下滑到 <strong>GitHub Pages</strong> 部分</p></li><li><p>修改 <strong>Source</strong> 为 <strong>master branch</strong> 并点击 <strong>Save</strong></p></li><li>再次下滑到 <strong>GitHub Pages</strong> 部分就会看到一个链接</li></ol><blockquote><p>成功  </p></blockquote><ol><li><p>如果不成功,再次修改 <strong>Source</strong> 为 <strong>master branch</strong> 并点击 <strong>Save</strong></p></li><li><p>点击链接就可以看到部署的简历</p></li><li>将简历链接写在你的README.md或者任何地方</li></ol><h2 id="五、创建【User-or-organization-site】"><a href="#五、创建【User-or-organization-site】" class="headerlink" title="五、创建【User or organization site】"></a>五、创建【User or organization site】</h2><blockquote><p>跟创建一般存储库流程一样,只是因为我们每个用户只有一个【User or organization site】,所以存储库的名称比较唯一,必须是<strong>username.github.io</strong> 格式,其中username是我们在GitHub上的用户名（或组织名称  </p></blockquote><p>如果不正确则不起作用，因此请确保正确无误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GitHub-Pages-完结&quot;&gt;&lt;a href=&quot;#GitHub-Pages-完结&quot; class=&quot;headerlink&quot; title=&quot;GitHub Pages [完结]&quot;&gt;&lt;/a&gt;GitHub Pages &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/GHP.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="GitHub" scheme="https://hotkang.cn/categories/GitHub/"/>
    
    
      <category term="GitHub Pages" scheme="https://hotkang.cn/tags/GitHub-Pages/"/>
    
      <category term="简历" scheme="https://hotkang.cn/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>CSS_属性继承</title>
    <link href="https://hotkang.cn/2018/06/21/CSS-%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF/"/>
    <id>https://hotkang.cn/2018/06/21/CSS-属性继承/</id>
    <published>2018-06-21T10:29:02.000Z</published>
    <updated>2018-07-08T08:38:42.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-属性继承-待完善"><a href="#CSS-属性继承-待完善" class="headerlink" title="CSS_属性继承 [待完善]"></a>CSS_属性继承 <span style="font-size:.5em">[待完善]</span></h2><blockquote><p>哪些属性可继承？？呃。。。往下看。</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://www.cnblogs.com/thislbq/p/5882105.html" target="_blank" rel="noopener">参考链接</a></li><li><a href="http://www.runoob.com/cssref/css-reference.html" target="_blank" rel="noopener">CSS 参考手册</a></li><li><a href="https://www.w3schools.com/cssref/css3_pr_align-content.asp" target="_blank" rel="noopener">CSS Properties</a></li></ul></blockquote><hr><h2 id="一、无继承性的属性"><a href="#一、无继承性的属性" class="headerlink" title="一、无继承性的属性"></a>一、<strong>无继承性</strong>的属性</h2><h3 id="1-display"><a href="#1-display" class="headerlink" title="1. display"></a>1. display</h3><p>定义元素生成的框的类型,下面是常用的属性值: </p><table><thead><tr><th style="text-align:center">display值</th><th style="text-align:left">描述 </th></tr></thead><tbody><tr><td style="text-align:center">inherit</td><td style="text-align:left">继承父元素 display 属性的值 </td></tr><tr><td style="text-align:center"><strong>none</strong></td><td style="text-align:left">不会被显示</td></tr><tr><td style="text-align:center"><strong>block</strong></td><td style="text-align:left">块级元素，前后会带有换行符</td></tr><tr><td style="text-align:center"><strong>inline</strong></td><td style="text-align:left">默认。内联元素，前后没有换行符</td></tr><tr><td style="text-align:center"><strong>inline-block</strong></td><td style="text-align:left">行内块元素</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="2-文本属性-部分属性无继承性"><a href="#2-文本属性-部分属性无继承性" class="headerlink" title="2. 文本属性[部分属性无继承性]"></a>2. 文本属性[部分属性无继承性]</h3><table><thead><tr><th style="text-align:center">文本属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">vertical-align</td><td style="text-align:left">垂直文本对齐</td></tr><tr><td style="text-align:center">text-decoration</td><td style="text-align:left">规定添加到文本的装饰</td></tr><tr><td style="text-align:center">text-shadow</td><td style="text-align:left">文本阴影效果</td></tr><tr><td style="text-align:center">white-space</td><td style="text-align:left">空白符的处理</td></tr><tr><td style="text-align:center">unicode-bidi</td><td style="text-align:left">设置文本的方向</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="3-Border-Outline属性"><a href="#3-Border-Outline属性" class="headerlink" title="3.Border/Outline属性"></a>3.Border/Outline属性</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"></td></tr></tbody></table><h3 id="3-盒子模型"><a href="#3-盒子模型" class="headerlink" title="3.盒子模型"></a>3.盒子模型</h3><table><thead><tr><th style="text-align:left">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">width/height</td><td style="text-align:left">宽/高</td></tr><tr><td style="text-align:left">margin: top right bottom left</td><td style="text-align:left">[上右下左]外边距</td></tr><tr><td style="text-align:left">padding: top right bottom left</td><td style="text-align:left">[上右下左]内边距</td></tr><tr><td style="text-align:left">border: top right bottom left</td><td style="text-align:left">[上右下左]边框</td></tr><tr><td style="text-align:left">border-[top`</td><td style="text-align:left"><code>right</code></td><td><code>bottom</code></td><td>`left]-style</td><td>边框[上右下左]样式</td></tr><tr><td style="text-align:left">border-[top`</td><td style="text-align:left"><code>right</code></td><td><code>bottom</code></td><td>`left]-width</td><td>边框[上右下左]宽度</td></tr><tr><td style="text-align:left">border-[top`</td><td style="text-align:left"><code>right</code></td><td><code>bottom</code></td><td>`left]-color</td><td>边框[上右下左]颜色</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="4-背景属性-均无继承性"><a href="#4-背景属性-均无继承性" class="headerlink" title="4.背景属性[均无继承性]"></a>4.背景属性[均无继承性]</h3><table><thead><tr><th style="text-align:left">背景属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">background</td><td style="text-align:left">[颜色`</td><td><code>图片</code></td><td><code>位置</code></td><td><code>大小</code></td><td><code>重复</code></td><td><code>原点</code></td><td><code>素材</code></td><td>`附件]</td></tr><tr><td style="text-align:left">background-color</td><td style="text-align:left">颜色</td></tr><tr><td style="text-align:left">background-image</td><td style="text-align:left">图片</td></tr><tr><td style="text-align:left">background-position</td><td style="text-align:left">位置</td></tr><tr><td style="text-align:left">background-size</td><td style="text-align:left">大小</td></tr><tr><td style="text-align:left">background-repeat</td><td style="text-align:left">重复</td></tr><tr><td style="text-align:left">background-origin</td><td style="text-align:left">指定原点位置</td></tr><tr><td style="text-align:left">background-clip</td><td style="text-align:left">背景(颜色或图像)应在元素内延伸的距离</td></tr><tr><td style="text-align:left">background-attachment</td><td style="text-align:left">背景图像是否与页面的其余部分一起滚动,或者是否已修复。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="5-定位属性"><a href="#5-定位属性" class="headerlink" title="5.定位属性"></a>5.定位属性</h3><table><thead><tr><th style="text-align:left">定位属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">float</td><td style="text-align:left">指定元素应该如何浮动</td></tr><tr><td style="text-align:left">clear</td><td style="text-align:left">指定元素浮动元素的哪些边不允许浮动</td></tr><tr><td style="text-align:left">position</td><td style="text-align:left">指定用于元素的定位方法的类型(static/relative/absolute/fixed/sticky)</td></tr><tr><td style="text-align:left">top`</td><td style="text-align:left">`bottom</td><td>影响定位元素的垂直位置</td></tr><tr><td style="text-align:left">left`</td><td style="text-align:left">`right</td><td>影响定位元素的水平位置</td></tr><tr><td style="text-align:left">min-[width`</td><td style="text-align:left">`height]</td><td>定义了元素的最小宽度/高度</td></tr><tr><td style="text-align:left">max-[width`</td><td style="text-align:left">`height]</td><td>定义了元素的最大宽度/高度</td></tr><tr><td style="text-align:left">overflow</td><td style="text-align:left">溢出</td></tr><tr><td style="text-align:left">clip</td><td style="text-align:left">指定一个矩形来剪切绝对定位的元素</td></tr><tr><td style="text-align:left">z-index</td><td style="text-align:left">指定元素的堆栈顺序。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="6-生成内容属性"><a href="#6-生成内容属性" class="headerlink" title="6.生成内容属性"></a>6.生成内容属性</h3><table><thead><tr><th style="text-align:left">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">content</td><td style="text-align:left">::before和::after伪元素一起使用,以插入生成的内容</td></tr><tr><td style="text-align:left">counter-reset</td><td style="text-align:left">创建或重置一个或多个CSS计数器</td></tr><tr><td style="text-align:left">counter-increment</td><td style="text-align:left">增加或减少一个或多个CSS计数器的值</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="7-轮廓属性"><a href="#7-轮廓属性" class="headerlink" title="7.轮廓属性"></a>7.轮廓属性</h3><table><thead><tr><th style="text-align:left">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">outline</td><td style="text-align:left">轮廓[宽度/*样式/颜色]</td></tr><tr><td style="text-align:left">outline-style</td><td style="text-align:left">样式</td></tr><tr><td style="text-align:left">outline-width</td><td style="text-align:left">宽度</td></tr><tr><td style="text-align:left">outline-color</td><td style="text-align:left">颜色</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="8-打印属性"><a href="#8-打印属性" class="headerlink" title="8.打印属性"></a>8.打印属性</h3><table><thead><tr><th style="text-align:left">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">size</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">page-break-before</td><td style="text-align:left">元素之前添加分页符</td></tr><tr><td style="text-align:left">page-break-after</td><td style="text-align:left">元素后添加分页符</td></tr><tr><td style="text-align:left">page-break-inside</td><td style="text-align:left">指定元素内避免分页符</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="9-声音样式属性"><a href="#9-声音样式属性" class="headerlink" title="9.声音样式属性"></a>9.声音样式属性</h3><table><thead><tr><th style="text-align:left">内容属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pause-before</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">pause-after</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">pause</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">cue-before</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">cue-after</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">cue</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">play-during</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="二、有继承性的属性"><a href="#二、有继承性的属性" class="headerlink" title="二、有继承性的属性"></a>二、<strong>有继承性</strong>的属性</h2><h3 id="1-字体系列属性-均继承"><a href="#1-字体系列属性-均继承" class="headerlink" title="1.字体系列属性[均继承]"></a>1.字体系列属性[均继承]</h3><table><thead><tr><th style="text-align:left">字体属性</th><th style="text-align:left"> 描述</th></tr></thead><tbody><tr><td style="text-align:left">font</td><td style="text-align:left">[*size`</td><td><code>*family</code></td><td><code>weight</code></td><td>`style]</td></tr><tr><td style="text-align:left">font-style</td><td style="text-align:left">样式</td></tr><tr><td style="text-align:left">font-variant</td><td style="text-align:left">变形</td></tr><tr><td style="text-align:left">font-weight</td><td style="text-align:left">粗细</td></tr><tr><td style="text-align:left">font-size/line-height</td><td style="text-align:left">尺寸</td></tr><tr><td style="text-align:left">font-family</td><td style="text-align:left">字体系列</td></tr><tr><td style="text-align:left">font-stretch</td><td style="text-align:left">对字体进行伸缩变形</td></tr><tr><td style="text-align:left">font-size-adjust</td><td style="text-align:left">更好地控制字体大小。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="2-文本属性-部分继承"><a href="#2-文本属性-部分继承" class="headerlink" title="2. 文本属性[部分继承]"></a>2. 文本属性[部分继承]</h3><table><thead><tr><th style="text-align:center">文本属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">text-indent</td><td style="text-align:left">文本缩进</td></tr><tr><td style="text-align:center">text-align</td><td style="text-align:left">文本水平对齐</td></tr><tr><td style="text-align:center">line-height</td><td style="text-align:left">行高</td></tr><tr><td style="text-align:center">word-spacing</td><td style="text-align:left">增加或减少<strong>单词间</strong>的空白（即字间隔）</td></tr><tr><td style="text-align:center">letter-spacing</td><td style="text-align:left">增加或减少<strong>字符间</strong>的空白（字符间距）</td></tr><tr><td style="text-align:center">text-transform</td><td style="text-align:left">控制文本大小写</td></tr><tr><td style="text-align:center">direction</td><td style="text-align:left">规定文本的书写方向</td></tr><tr><td style="text-align:center">color</td><td style="text-align:left">文本颜色</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="3-visibility"><a href="#3-visibility" class="headerlink" title="3.visibility"></a>3.visibility</h3><h3 id="4-表格布局属性"><a href="#4-表格布局属性" class="headerlink" title="4.表格布局属性"></a>4.表格布局属性</h3><table><thead><tr><th style="text-align:left">表格布局属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">aption-side</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">border-collapse</td><td style="text-align:left">表格边框是应折叠为单个边框还是按标准HTML分隔</td></tr><tr><td style="text-align:left">border-spacing</td><td style="text-align:left">相邻单元格边界之间的距离</td></tr><tr><td style="text-align:left">empty-cells</td><td style="text-align:left">是否在表格中的空单元格上显示边框</td></tr><tr><td style="text-align:left">table-layout</td><td style="text-align:left">布置表格单元格，行和列的算法</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="5-列表布局属性-均继承"><a href="#5-列表布局属性-均继承" class="headerlink" title="5.列表布局属性[均继承]"></a>5.列表布局属性[均继承]</h3><table><thead><tr><th style="text-align:left">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">list-style</td><td style="text-align:left">[type`</td><td><code>image</code></td><td>`position]</td></tr><tr><td style="text-align:left">list-style-type</td><td style="text-align:left">类型</td></tr><tr><td style="text-align:left">list-style-image</td><td style="text-align:left">图像</td></tr><tr><td style="text-align:left">list-style-position</td><td style="text-align:left">位置inside`</td><td><code>outside</code></td><td><code>initial</code></td><td>`inherit;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="6-引用属性-quotes"><a href="#6-引用属性-quotes" class="headerlink" title="6.引用属性:quotes"></a>6.引用属性:quotes</h3><p>引用的引号类型:none|string|initial|inherit;</p><h3 id="7-鼠标光标-cursor"><a href="#7-鼠标光标-cursor" class="headerlink" title="7.鼠标光标:cursor"></a>7.鼠标光标:cursor</h3><h3 id="8-打印属性-1"><a href="#8-打印属性-1" class="headerlink" title="8.打印属性"></a>8.打印属性</h3><table><thead><tr><th style="text-align:left">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">page</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">windows</td><td style="text-align:left">发生分页时必须在页面<strong>顶部</strong>保留的最少行数</td></tr><tr><td style="text-align:left">orphans</td><td style="text-align:left">生分页时必须在页面<strong>底部</strong>保留的最少行数</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="9-声音样式属性-1"><a href="#9-声音样式属性-1" class="headerlink" title="9.声音样式属性"></a>9.声音样式属性</h3><table><thead><tr><th style="text-align:left">盒子模型属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">speak</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">speak-punctuation</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">speak-numeral</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">speak-header</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">speech-rate</td><td style="text-align:left"></td></tr></tbody></table><p>volume|<br>voice-family|<br>pitch|<br>pitch-range|<br>stress|<br>richness|<br>azimuth|<br>elevation</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS-属性继承-待完善&quot;&gt;&lt;a href=&quot;#CSS-属性继承-待完善&quot; class=&quot;headerlink&quot; title=&quot;CSS_属性继承 [待完善]&quot;&gt;&lt;/a&gt;CSS_属性继承 &lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;哪些属性可继承？？呃。。。往下看。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="CSS" scheme="https://hotkang.cn/tags/CSS/"/>
    
      <category term="属性继承" scheme="https://hotkang.cn/tags/%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统四</title>
    <link href="https://hotkang.cn/2018/06/19/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%9B%9B/"/>
    <id>https://hotkang.cn/2018/06/19/图书管理系统四/</id>
    <published>2018-06-19T15:49:33.000Z</published>
    <updated>2018-07-11T16:40:01.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现具体功能-完结"><a href="#实现具体功能-完结" class="headerlink" title="实现具体功能 [完结]"></a>实现具体功能 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>所有的功能实现都在写在这里了。</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://www.alloyteam.com/2015/03/sexpressmysql/" target="_blank" rel="noopener">参考教程1</a></li><li><a href="https://www.xiabingbao.com/node/2017/02/20/node-express-forum.html" target="_blank" rel="noopener">参考教程2</a>(划重点!) </li></ul></blockquote><p>【注意】虽然前期看了教程1之后，功能没有实现，但是给教程2奠定一定的知识储备,建议都看看。  </p><hr><h2 id="一、你可能必须先看一下以下教程"><a href="#一、你可能必须先看一下以下教程" class="headerlink" title="一、你可能必须先看一下以下教程"></a>一、你可能必须先看一下以下教程</h2><p>仔细看看<a href="http://blog.fens.me/nodejs-express4/" target="_blank" rel="noopener">Node.js开发框架Express4.x</a> 下的以下部分</p><pre><code>2. 目录结构3. package.json项目配置4. app.js核心文件5.Bootstrap界面框架(选看,里面涉及到的重复代码前面讲过)6. 路由功能</code></pre><h2 id="二、跟着参考教程2完成注册-登录"><a href="#二、跟着参考教程2完成注册-登录" class="headerlink" title="二、跟着参考教程2完成注册/登录"></a>二、跟着<a href="https://www.xiabingbao.com/node/2017/02/20/node-express-forum.html" target="_blank" rel="noopener">参考教程2</a>完成注册/登录</h2><pre><code>看了很多网上的教程吧,只有教程2让我成功了,作者写的也非常用心超级仔细！！！！我只跟着敲了用户注册登录,其他就无师自通啦~</code></pre><h2 id="三、写在后面"><a href="#三、写在后面" class="headerlink" title="三、写在后面"></a>三、写在后面</h2><pre><code>看了所有推荐的链接,基本上就没有什么问题啦。知识本身不难,难得是我们要在网上找到靠谱的教程。</code></pre><h2 id="四、根据项目记录下一些具体的细节"><a href="#四、根据项目记录下一些具体的细节" class="headerlink" title="四、根据项目记录下一些具体的细节"></a>四、根据项目记录下一些具体的细节</h2><blockquote><h3 id="保持用户登录状态-app-js"><a href="#保持用户登录状态-app-js" class="headerlink" title="保持用户登录状态(app.js)"></a>保持用户登录状态(app.js)</h3></blockquote><ul><li><p>加载依赖库  </p><pre><code>var cookieParser = require(&apos;cookie-parser&apos;);  var session = require(&apos;express-session&apos;);</code></pre></li><li><p>定义cookie解析器</p><pre><code>app.use(cookieParser());app.use(session({    secret: &apos;hotyan&apos;,  // 用来对session id相关的cookie进行签名    saveUninitialized: true,  // 是否自动保存未初始化的会话，建议false    resave: false,  // 是否每次都重新保存会话，建议false    cookie: {maxAge:  60*60 * 1000 } // 有效期，单位是毫秒}))</code></pre></li></ul><ul><li><p>在app.js文件下添加自定义中间件,实现保持用户登录状态</p><pre><code>app.use(function(req, res, next){    // 如果session中存在，则说明已经登录    if( req.session.hotyan ){        res.locals.hotyan = {            UserId : req.session.hotyan.UserId,            UserName : req.session.hotyan.UserName        }    }else{        res.locals.hotyan = {};    }    next();//此处必须有})</code></pre></li></ul><blockquote><h3 id="数据库连接-models-db-js"><a href="#数据库连接-models-db-js" class="headerlink" title="数据库连接(models/db.js)"></a>数据库连接(models/db.js)</h3></blockquote><pre><code>var mysql = require(&apos;mysql&apos;);var pool = mysql.createPool({    host: &apos;localhost&apos;,    user: &apos;root&apos;,    password: &apos;XXXXXX&apos;,    database: &apos;XXXXXX&apos;});module.exports = pool;  </code></pre><blockquote><h3 id="Mysql语句-方法总结于教程2"><a href="#Mysql语句-方法总结于教程2" class="headerlink" title="Mysql语句(方法总结于教程2)"></a>Mysql语句(方法总结于教程2)</h3></blockquote><p>以对图书管理员进行增删改查为例,新建(SQL/adminSql.js)文件,将需要的Mysql语句全部独立出来。</p><pre><code>//对bookadmin进行增删改查var admin = {    /**添加图书管理员 */    insert :&apos;INSERT INTO `bookadmin` SET `BAId`=?, `BAName`=? ,`BAPassword`=?,`BAPhone`=?,`BAEmail`=?&apos;,    /**修改图书管理员信息 */    update : &apos;UPDATE `bookadmin` SET `BAName`=? ,`BAPhone`=?,`BAEmail`=? WHERE `BAId`=?&apos;,    /**删除图书管理员 */    delete: &apos;DELETE FROM `bookadmin` WHERE `BAId`=?&apos;,    /**精确查看图书管理员信息 */    queryById : &apos;SELECT * FROM `bookadmin` WHERE `BAId`=?&apos;,    /**查看全部图书管理员信息 */    queryAll : &apos;SELECT * FROM `bookadmin` &apos;};module.exports = admin;</code></pre><blockquote><h3 id="实现功能的函数放置在-models-users-js"><a href="#实现功能的函数放置在-models-users-js" class="headerlink" title="实现功能的函数放置在(models/users.js)"></a>实现功能的函数放置在(models/users.js)</h3></blockquote><ul><li><p>1、加载依赖文件</p><pre><code>var pool = require(&apos;./db&apos;), // 连接数据库    admin = require(&apos;../SQL/adminSql&apos;),//图书管理员的Mysql语句    crypto = require(&apos;crypto&apos;); // 对密码进行加密</code></pre></li></ul><ul><li><p>2、以添加图书管理员为例学习如何使用封装的函数</p><pre><code>adminadd: function (BAId, BAName, BAPassword, BAPhone, BAEmail, cb) {        pool.getConnection(function (err, connection) {            if (err) throw err;            connection.query(admin.insert, [BAId, BAName, BAPassword, BAPhone, BAEmail], function (err, result) {                if (err) throw err;                cb(result);                connection.release();            })        })    }</code></pre><p>  注意:建议了解一下query()方法,参数可2可3,query(mysql语句,内容数组,回调函数）;我把Mysql语句独立了出去,看了教程2就知道。  </p></li></ul><blockquote><h3 id="表单提交POST请求"><a href="#表单提交POST请求" class="headerlink" title="表单提交POST请求"></a>表单提交POST请求</h3></blockquote><p> 以添加图书管理员为例</p><pre><code>&lt;form action=&quot;/badAddAdmin&quot; method=&quot;POST&quot; class=&quot;ad_data&quot;&gt;//注意1    &lt;div class=&quot;data&quot;&gt;        &lt;label&gt;管理号&lt;/label&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;输入图书管理员编号&quot; name=&quot;BAId&quot; /&gt;//注意2    &lt;/div&gt;       ...         &lt;div class=&quot;data&quot;&gt;        &lt;label&gt;邮箱&lt;/label&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;输入图书管理员邮箱&quot; name=&quot;BAEmail&quot; /&gt;    &lt;/div&gt;    &lt;input class=&quot;add_btn&quot; type=&quot;submit&quot; value=&quot;确认添加&quot; /&gt;//注意3    &lt;/form&gt;</code></pre><p>注意三个地方: </p><pre><code>1.action=&quot;/badAddAdmin&quot; method=&quot;POST&quot;  2.name=&quot;BAId&quot;3.type=&quot;submit&quot;</code></pre><blockquote><h3 id="在-routes-index-js-中添加POST代码"><a href="#在-routes-index-js-中添加POST代码" class="headerlink" title="在(routes/index.js)中添加POST代码"></a>在(routes/index.js)中添加POST代码</h3></blockquote><p>以添加图书管理员界面为例:</p><pre><code>router.post(&apos;/badAddAdmin&apos;, function (req, res, next) {    /*获取表单传来的数据*/    var BAId = req.body.BAId || &apos;&apos;,        BAName = req.body.BAName || &apos;&apos;,        BAPassword = req.body.BAPassword || &apos;&apos;,        BAPhone = req.body.BAPhone || &apos;&apos;,        BAEmail = req.body.BAEmail || &apos;&apos;;    /*调用密码加密函数*/    var password_hash = user_m.hash(BAPassword);    /*调用添加图书管理员函数*/    user_m.adminadd(BAId, BAName, password_hash, BAPhone, BAEmail, function (result) {        console.log(&quot;添加成功&quot;);        res.redirect(&apos;/badAddAdmin&apos;);    })})</code></pre><blockquote><h3 id="ejs循环渲染-查看界面需要"><a href="#ejs循环渲染-查看界面需要" class="headerlink" title="ejs循环渲染(查看界面需要)"></a>ejs循环渲染(查看界面需要)</h3></blockquote><pre><code>/*(routes/index.js)中代码*/router.post(&apos;/badCheckAdmin&apos;, function (req, res, next) {    console.log(req.body);    var BAId = req.body.BAId;    user_m.adminId(BAId, function (result) {        console.log(&quot;精确查看成功&quot;);        res.render(&apos;badCheckAdmin&apos;, {            title: &apos;查看图书管理员信息&apos;,            datas: result     //返回json数据,        })    })});</code></pre><p>【注意】返回json数据,需要依赖模块body-parser,此处建议了解一下res.render()  </p><pre><code>/*(views/badCheckAdmin.ejs)中渲染代码*/&lt;tbody&gt;    &lt;% for(var i=0;i&lt; datas.length;i++){ %&gt;    &lt;tr&gt;        &lt;td &gt;        &lt;%= datas[i].BAId %&gt;        &lt;/td&gt;        &lt;td&gt;        &lt;%= datas[i].BAName %&gt;        &lt;/td&gt;        &lt;td&gt;        &lt;%= datas[i].BAPhone %&gt;        &lt;/td&gt;        &lt;td&gt;        &lt;%= datas[i].BAEmail %&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;% }%&gt;&lt;/tbody&gt;</code></pre><blockquote><h3 id="日期格式YYYY-MM-DD"><a href="#日期格式YYYY-MM-DD" class="headerlink" title="日期格式YYYY-MM-DD"></a>日期格式YYYY-MM-DD</h3><p>在(routes/index.js)文件中</p></blockquote><pre><code>/*加载依赖模块*/var time = require(&apos;silly-datetime&apos;)/*在需要的地方使用,以注册时间为例*/RegTime = time.format(new Date(), &apos;YYYY-MM-DD&apos;);</code></pre><blockquote><h3 id="图书应该归还日期-30天后"><a href="#图书应该归还日期-30天后" class="headerlink" title="图书应该归还日期(30天后)"></a>图书应该归还日期(30天后)</h3></blockquote><pre><code>/******在(models/users.js)中添加date方法*******/date: function (AddDay) {    var date = new Date();        /*****获取AddDay天后的日期 ********/        date.setDate(date.getDate() + AddDay);    var Y = date.getFullYear(),            /***** 获取当前月份的日期，不足10补0 *****/        M = (date.getMonth() + 1) &lt; 10 ? &quot;0&quot; + (date.getMonth() + 1) : (date.getMonth() + 1),            /****获取当前几号，不足10补0  ****/        D = date.getDate() &lt; 10 ? &quot;0&quot; + date.getDate() : date.getDate();    return Y + &quot;-&quot; + M + &quot;-&quot; + D;}/*******在(routes/index.js)借书界面调用date方法********/var ShouldTime = user_m.date(30);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实现具体功能-完结&quot;&gt;&lt;a href=&quot;#实现具体功能-完结&quot; class=&quot;headerlink&quot; title=&quot;实现具体功能 [完结]&quot;&gt;&lt;/a&gt;实现具体功能 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;所有的功能实现都在写在这里了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql命令小结</title>
    <link href="https://hotkang.cn/2018/06/19/Mysql%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>https://hotkang.cn/2018/06/19/Mysql命令小结/</id>
    <published>2018-06-19T14:04:20.000Z</published>
    <updated>2018-07-11T16:41:18.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql语句-持续完善"><a href="#Mysql语句-持续完善" class="headerlink" title="Mysql语句 [持续完善]"></a>Mysql语句 <span style="font-size:.5em">[持续完善]</span></h2><blockquote><p>常用命令小结</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://juejin.im/post/5ae55861f265da0ba062ec71" target="_blank" rel="noopener">参考链接</a></li></ul></blockquote><hr><h2 id="一、DATABASE"><a href="#一、DATABASE" class="headerlink" title="一、DATABASE"></a>一、DATABASE</h2><p>新建数据库：</p><pre><code>CREATE DATABASE database_name;</code></pre><p>删除数据库：</p><pre><code>DROP DATABASE database_name;</code></pre><p>查看所有可用的数据库：</p><pre><code>SHOW DATABASES;  </code></pre><p>选择数据库：</p><pre><code>USE database_name;</code></pre><p>显示数据库服务器的状态信息：</p><pre><code>SHOW STATUS;  </code></pre><p>获取当前所选的数据库中所有可用的表：</p><pre><code>SHOW TABLES; </code></pre><p>获取表中所有列的信息：</p><pre><code>SHOW COLUMNS FROM table_name; </code></pre><h2 id="二、TABLE"><a href="#二、TABLE" class="headerlink" title="二、TABLE"></a>二、TABLE</h2><p>新建表:</p><pre><code>CREATE TABLE table_name;</code></pre><p>删除表,使用DROP TABLE子句:</p><pre><code>DROP TABLE table_name。</code></pre><p>清空表中记录:</p><pre><code>delete from table_name;</code></pre><p>显示表中的记录:</p><pre><code>select * from table_name;</code></pre><h2 id="三、导入导出"><a href="#三、导入导出" class="headerlink" title="三、导入导出"></a>三、导入导出</h2><p>导入.sql</p><pre><code>source .sql文件路径</code></pre><p>备份数据,导出.sql文件</p><pre><code>cd 存放目录mysqldump -u root_name -p database_name&gt;file_name.sql例如:mysqldump -u root -p hotyan&gt;db.sql</code></pre><p>退出MYSQL命令:</p><pre><code>exit(回车)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mysql语句-持续完善&quot;&gt;&lt;a href=&quot;#Mysql语句-持续完善&quot; class=&quot;headerlink&quot; title=&quot;Mysql语句 [持续完善]&quot;&gt;&lt;/a&gt;Mysql语句 &lt;span style=&quot;font-size:.5em&quot;&gt;[持续完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;常用命令小结&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://hotkang.cn/categories/Mysql/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Express" scheme="https://hotkang.cn/tags/Express/"/>
    
      <category term="ejs" scheme="https://hotkang.cn/tags/ejs/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统三</title>
    <link href="https://hotkang.cn/2018/06/11/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%89/"/>
    <id>https://hotkang.cn/2018/06/11/图书管理系统三/</id>
    <published>2018-06-11T15:24:23.000Z</published>
    <updated>2018-07-11T16:39:46.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql-完结"><a href="#Mysql-完结" class="headerlink" title="Mysql [完结]"></a>Mysql <span style="font-size:.5em">[完结]</span></h2><blockquote><p>安装Mysql,你可能会进入Mysql官网,下载安装适合你自己电脑的版本,我用的Mac,所以我继续看了一下在【macOS上安装MySQL】,然后就跟着操作,结果不成功,解决不了？？？卸载试试？？？重新安装,依旧失败~</p></blockquote><a id="more"></a><h2 id="本文记录如何用homebrew-install-mysql"><a href="#本文记录如何用homebrew-install-mysql" class="headerlink" title="本文记录如何用homebrew install mysql"></a>本文记录如何用homebrew install mysql</h2><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/installing.html" target="_blank" rel="noopener">Mysql官网</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/osx-installation.html" target="_blank" rel="noopener">在macOS上安装MySQL</a></li><li><a href="https://brew.sh/" target="_blank" rel="noopener">homebrew官网</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html" target="_blank" rel="noopener">本文参考链接</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/MySql/index.html" target="_blank" rel="noopener">YouTube视频教程</a>(划重点,是这个视频让我成功的！！！)    </li></ul></blockquote><hr><h2 id="一、安装homebrew"><a href="#一、安装homebrew" class="headerlink" title="一、安装homebrew"></a>一、安装homebrew</h2><p>请参考<a href="https://hotyan.github.io/2018/05/29/use%20homebrew%20install%20mongodb/" target="_blank" rel="noopener">Mac Use Homebrew Install Mongodb</a>,那里有详细记录,这边不再赘述</p><h2 id="二、安装Mysql"><a href="#二、安装Mysql" class="headerlink" title="二、安装Mysql"></a>二、安装Mysql</h2><blockquote><p>1.终端下运行以下命令</p></blockquote><pre><code>$ brew install mysql</code></pre><p>【注意】暂时忽略你看到的一些提示！！！</p><blockquote><p>2.启动Mysql服务器  </p></blockquote><p>先把服务器start再说</p><pre><code>$ brew services start mysql</code></pre><p>【注意】现在可以跟着你看到的提示一步一步来！！！</p><blockquote><p>3.先安全登录Mysql  </p></blockquote><p>运行提示一:  </p><pre><code>$ mysql_secure_installation  </code></pre><ul><li><p>根据提示设置user root密码  </p><pre><code>Enter password for user root：（此处输入你的密码）</code></pre></li><li><p>根据提示进行设置  </p><pre><code>可一路yes</code></pre></li><li><p>设置完后，你会看到提示  </p><pre><code>All done！</code></pre><blockquote><p>4、连接Mysql  </p></blockquote></li></ul><p>运行提示二:</p><pre><code>$ mysql -uroot</code></pre><p>或者</p><pre><code>$ mysql -u root -p    </code></pre><p>回车后,输入刚刚设置的密码：  </p><pre><code>Enter password：</code></pre><blockquote><p>5、success！  </p></blockquote><p>成功之后,就可以对Mysql进行操作啦</p><blockquote><p>6、退出mysql</p></blockquote><pre><code>mysql&gt; exitBye</code></pre><blockquote><p>7、关闭mysql服务器</p></blockquote><pre><code>$ brew services start mysql</code></pre><blockquote><p>8、配置.bash_profile  </p></blockquote><p>先查看你的mysql安装在哪</p><pre><code>$ which mysql</code></pre><p>比如我返回的是  </p><pre><code>/usr/local/Cellar/mysql/5.7.22/bin/mysql</code></pre><p>打开.bash_profile文件</p><pre><code>$ open ~/.bash_profile</code></pre><p>将下面这行代码加入.bash_profile</p><pre><code>export PATH=&quot;/usr/local/Cellar/mysql/5.7.22/bin:$PATH&quot;</code></pre><p>保存,退出后,保存新配置</p><pre><code>$ source ~/.bash_profile</code></pre><blockquote><p>9、运行流程  </p></blockquote><p>开启服务器:</p><pre><code>$ brew services start mysql</code></pre><p>登录Mysql:</p><pre><code>$ mysql -u root -p</code></pre><p>操作Mysql:  </p><ul><li>可参考<a href="https://hotyan.github.io/2018/06/19/Mysql%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">Mysql指令小结</a>  </li></ul><p>退出Mysql:</p><pre><code>mysql&gt;exitBye</code></pre><p>关闭服务器</p><pre><code>$ brew services stop mysql</code></pre><blockquote><p>10、基本完成啦  </p></blockquote><p>其实我遇到过很多问题，也尝试解决，Google了很多，并没有很成功的解决问题，课设期间时间也比较有限，所以在尝试解决不成功后，出现问题我选择卸载，重新安装~ </p><p>根据上面打开流程，基本不会再出差啦 </p><h2 id="三、卸载Mysql"><a href="#三、卸载Mysql" class="headerlink" title="三、卸载Mysql"></a>三、卸载Mysql</h2><p>1.打开终端,依次输入</p><pre><code>$ brew remove mysql$ brew cleanup$ sudo rm /usr/local/mysql$ sudo rm -rf /usr/local/var/mysql$ sudo rm -rf /usr/local/mysql*$ sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ sudo rm -rf /Library/StartupItems/MySQLCOM$ sudo rm -rf /Library/PreferencePanes/My*</code></pre><p>2.查看是否成功</p><pre><code>$ mysql</code></pre><p>提示mysql 没有发现，多半就可以了。（其实我也不确定哈，只是我这样就可以~）</p><p>3.最后重启电脑重新安装即可</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mysql-完结&quot;&gt;&lt;a href=&quot;#Mysql-完结&quot; class=&quot;headerlink&quot; title=&quot;Mysql [完结]&quot;&gt;&lt;/a&gt;Mysql &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;安装Mysql,你可能会进入Mysql官网,下载安装适合你自己电脑的版本,我用的Mac,所以我继续看了一下在【macOS上安装MySQL】,然后就跟着操作,结果不成功,解决不了？？？卸载试试？？？重新安装,依旧失败~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://hotkang.cn/categories/Mysql/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
      <category term="Homebrew" scheme="https://hotkang.cn/tags/Homebrew/"/>
    
      <category term="node.js" scheme="https://hotkang.cn/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统二</title>
    <link href="https://hotkang.cn/2018/06/11/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BA%8C/"/>
    <id>https://hotkang.cn/2018/06/11/图书管理系统二/</id>
    <published>2018-06-11T15:24:16.000Z</published>
    <updated>2018-07-11T16:39:34.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EJS模板引擎-完结"><a href="#EJS模板引擎-完结" class="headerlink" title="EJS模板引擎 [完结]"></a>EJS模板引擎 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>接下来，我们可以来初步渲染页面啦</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">EJS官网</a>  </li></ul></blockquote><hr><h2 id="一、首先来了解一下项目结构"><a href="#一、首先来了解一下项目结构" class="headerlink" title="一、首先来了解一下项目结构"></a>一、首先来了解一下项目结构</h2><pre><code>.├── app.js  //程序启动文件├── bin│   └── www├── package.json  //项目依赖配置及开发者信息├── public        //静态文件(存css,js,img)│   ├── images│   ├── javascripts│   └── stylesheets│       └── style.css├── routes          //路由文件│   ├── index.js│   └── users.js└── views           //页面文件(ejs模板)    ├── error.ejs    ├── index.ejs    └── layout.ejs</code></pre><h2 id="二、渲染界面"><a href="#二、渲染界面" class="headerlink" title="二、渲染界面"></a>二、渲染界面</h2><blockquote><p>对views文件夹进行操作:    </p></blockquote><pre><code>在现有的首页index.ejs里面加入你的首页界面代码新建注册界面reg.ejs,并加入该界面代码新建登录界面login.ejs,并加入该界面代码...</code></pre><blockquote><p>对routes文件夹进行操作    </p></blockquote><p>在index.js文件里面分别渲染index.ejs、reg.ejs 、login.ejs</p><pre><code>router.get(&apos;/&apos;, function (req, res, next) {    res.render(&apos;index&apos;, {        title: &apos;index&apos;    }) })router.get(&apos;/reg&apos;, function (req, res, next) {    res.render(&apos;reg&apos;, {        title: &apos;reg&apos;    }) })router.get(&apos;/login&apos;, function (req, res, next) {    res.render(&apos;login&apos;, {        title: &apos;login&apos;    }) })...</code></pre><blockquote><p>将相同代码独立出来  </p></blockquote><p>比如我的(基本资料/修改资料/借书/还书/借阅记录)这5个界面,上半部分是重复代码。<br>新建TopBar.ejs,放置重复代码,在其他五个界面添加</p><pre><code>&lt;%- include TopBar %&gt;</code></pre><p>所有重复代码以此类推  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;EJS模板引擎-完结&quot;&gt;&lt;a href=&quot;#EJS模板引擎-完结&quot; class=&quot;headerlink&quot; title=&quot;EJS模板引擎 [完结]&quot;&gt;&lt;/a&gt;EJS模板引擎 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;接下来，我们可以来初步渲染页面啦&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Express" scheme="https://hotkang.cn/tags/Express/"/>
    
      <category term="ejs" scheme="https://hotkang.cn/tags/ejs/"/>
    
      <category term="Mysql" scheme="https://hotkang.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>图书管理系统一</title>
    <link href="https://hotkang.cn/2018/06/11/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%80/"/>
    <id>https://hotkang.cn/2018/06/11/图书管理系统一/</id>
    <published>2018-06-11T15:24:02.000Z</published>
    <updated>2018-07-11T16:39:23.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express-完结"><a href="#Express-完结" class="headerlink" title="Express [完结]"></a>Express <span style="font-size:.5em">[完结]</span></h2><blockquote><p>图书管理系统大家应该都不陌生~<br>老师对大一的说：写一个图书管理系统吧？！！！<br>老师对大二的说：写一个图书管理系统！！！！<br>老师对大三的说：写一个图书管理系统！<br>大一的图书管理系统VS大三的图书管理系统？？</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><h3 id="个人比较喜欢先甩参考链接-可以选择直接去看参考链接。"><a href="#个人比较喜欢先甩参考链接-可以选择直接去看参考链接。" class="headerlink" title="个人比较喜欢先甩参考链接,可以选择直接去看参考链接。"></a>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</h3><ul><li><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">Express官网</a>  </li></ul></blockquote><hr><p>首先默认你已经安装了 Node.js,<br>没有装的可以参考<a href="https://hotyan.github.io/2018/05/30/%E7%94%A8nvm%E8%A3%85node-js/" target="_blank" rel="noopener">用nvm装node.js</a>    </p><h2 id="一、为你的应用创建一个目录（-hotyan）"><a href="#一、为你的应用创建一个目录（-hotyan）" class="headerlink" title="一、为你的应用创建一个目录（/hotyan）"></a>一、为你的应用创建一个目录（/hotyan）</h2><pre><code>$ mkdir hotyan</code></pre><h2 id="二、进入此目录并将其作为当前工作目录"><a href="#二、进入此目录并将其作为当前工作目录" class="headerlink" title="二、进入此目录并将其作为当前工作目录"></a>二、进入此目录并将其作为当前工作目录</h2><pre><code>$ cd hotyan</code></pre><h2 id="三、install-Express应用生成器"><a href="#三、install-Express应用生成器" class="headerlink" title="三、install Express应用生成器"></a>三、install Express应用生成器</h2><p>通过应用生成器工具 express 可以快速创建一个应用的骨架。<br>通过如下命令安装：  </p><pre><code>$ npm install express-generator -g</code></pre><h2 id="四、创建工作项目"><a href="#四、创建工作项目" class="headerlink" title="四、创建工作项目"></a>四、创建工作项目</h2><p>当前工作目录下（/hotyan）创建一个命名为 Librarys 的工作项目。</p><pre><code>$ express --view=ejs  Libraryscreate : Librarys/create : Librarys/public/create : Librarys/public/javascripts/create : Librarys/public/images/create : Librarys/public/stylesheets/create : Librarys/public/stylesheets/style.csscreate : Librarys/routes/create : Librarys/routes/index.jscreate : Librarys/routes/users.jscreate : Librarys/views/create : Librarys/views/error.ejscreate : Librarys/views/index.ejscreate : Librarys/app.jscreate : Librarys/package.jsoncreate : Librarys/bin/create : Librarys/bin/wwwchange directory:    $ cd Librarysinstall dependencies:    $ npm installrun the app:    $ DEBUG=librarys:* npm start</code></pre><h2 id="五、进入Library并安装依赖包"><a href="#五、进入Library并安装依赖包" class="headerlink" title="五、进入Library并安装依赖包"></a>五、进入Library并安装依赖包</h2><pre><code>$ cd Librarys$ npm install</code></pre><h2 id="六、启动这个项目（MacOS-或-Linux-平台）"><a href="#六、启动这个项目（MacOS-或-Linux-平台）" class="headerlink" title="六、启动这个项目（MacOS 或 Linux 平台）"></a>六、启动这个项目（MacOS 或 Linux 平台）</h2><pre><code>$ DEBUG=librarys:* npm start</code></pre><h2 id="七、在浏览器打开-http-localhost-3000"><a href="#七、在浏览器打开-http-localhost-3000" class="headerlink" title="七、在浏览器打开 http://localhost:3000/"></a>七、在浏览器打开 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Express-完结&quot;&gt;&lt;a href=&quot;#Express-完结&quot; class=&quot;headerlink&quot; title=&quot;Express [完结]&quot;&gt;&lt;/a&gt;Express &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;图书管理系统大家应该都不陌生~&lt;br&gt;老师对大一的说：写一个图书管理系统吧？！！！&lt;br&gt;老师对大二的说：写一个图书管理系统！！！！&lt;br&gt;老师对大三的说：写一个图书管理系统！&lt;br&gt;大一的图书管理系统VS大三的图书管理系统？？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Express+ejs+Mysql图书管理系统" scheme="https://hotkang.cn/categories/Express-ejs-Mysql%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="图书管理系统" scheme="https://hotkang.cn/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Express" scheme="https://hotkang.cn/tags/Express/"/>
    
      <category term="ejs" scheme="https://hotkang.cn/tags/ejs/"/>
    
      <category term="node.js" scheme="https://hotkang.cn/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>烂笔头之JS</title>
    <link href="https://hotkang.cn/2018/05/31/%E7%83%82%E7%AC%94%E5%A4%B4%E4%B9%8BJS/"/>
    <id>https://hotkang.cn/2018/05/31/烂笔头之JS/</id>
    <published>2018-05-31T11:13:13.000Z</published>
    <updated>2018-07-17T18:03:08.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于JS-持续更新"><a href="#关于JS-持续更新" class="headerlink" title="关于JS [持续更新]"></a>关于JS <span style="font-size:.5em">[持续更新]</span></h2><p><img src="/img/JS.jpg" alt=""></p><a id="more"></a><h3 id="JS定义"><a href="#JS定义" class="headerlink" title="JS定义"></a>JS定义</h3><ul><li><p>JavaScript是一种弱类型、动态的、解释型的脚本语言</p></li><li><p>JavaScript是客户端和服务器端脚本语言</p></li><li>JavaScript也是面向对象编程语言<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3></li><li><p>ECMAScript</p></li><li><p>DOM:文档对象模型</p></li><li>BOM:浏览器对象模型</li></ul><h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><ul><li><p>基本类型:string、number、boolean、nudefined、null</p></li><li><p>复杂数据类型（引用数据类型）:Object、Function、Array、Data、RegExp…</p></li><li><p>typeof:判断基本数据类型</p></li><li><p>Object.prototype.toString.call():判断对象属于哪种内置对象类型</p></li><li><p>instanceof:判断构造函数原型</p></li></ul><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><ul><li><p>JavaScript是一种弱类型、动态的、解释型的脚本语言</p><ul><li><p>强|弱类型:类型检查 严格|不严格，偏向于 不容忍|容忍 隐式转换</p></li><li><p>动态类型：运行的时候执行类型检查</p></li><li><p>静态类型：编译的时候就知道每个变量的类型</p></li><li><p>解释型：不需要编译，在运行的时候才翻译成机器语言，执行一次翻译一次，故效率低，跨平台性好；</p></li><li>编译型：需编译为机器语言的文件，运行时直接使用编译的结果；</li><li>标记语言：被动，不具备与访问者互动的能力；</li><li>脚本语言：</li><li>编程语言：</li></ul></li><li><p>js代码解析原则</p><ul><li><p>第一个步骤是解释，先通篇扫描所有的Js代码，然后把所有变量声明提升到该作用域顶端</p></li><li><p>第二个步骤是执行</p></li></ul></li><li><p>函数提升在变量提升之上</p></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title=" 闭包 "></a><span id="inline-blue"> 闭包 </span></h3><ul><li><p>可以访问其他函数内部作用域的函数 </p></li><li><p>在有函数嵌套的情况下，子函数用到了父函数的参数或者局部变量</p></li><li><p>作用：具有封闭性，保护变量；避免污染全局变量</p></li><li><p>缺点：内存泄漏</p></li></ul><h3 id="typeof返回哪些数据类型"><a href="#typeof返回哪些数据类型" class="headerlink" title="typeof返回哪些数据类型"></a>typeof返回哪些数据类型</h3><ul><li>Object</li><li>number</li><li>function</li><li>boolean</li><li>undefind</li></ul><h3 id="3种强制类型转换"><a href="#3种强制类型转换" class="headerlink" title="3种强制类型转换"></a>3种强制类型转换</h3><ul><li>parseInt</li><li>parseFloat</li><li>number</li></ul><h3 id="2种隐式转换"><a href="#2种隐式转换" class="headerlink" title="2种隐式转换"></a>2种隐式转换</h3><ul><li>== </li><li>===<h3 id="split-）"><a href="#split-）" class="headerlink" title="split(）"></a>split(）</h3></li><li>切割成数组的形式</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul><li>将数组转换成字符串<h3 id="IE和DOM事件流的区别"><a href="#IE和DOM事件流的区别" class="headerlink" title="IE和DOM事件流的区别"></a>IE和DOM事件流的区别</h3></li><li>执行顺序不一样、</li><li>参数不一样</li><li>事件加不加on</li><li>this指向问题<h3 id="call、apply、bind的区别"><a href="#call、apply、bind的区别" class="headerlink" title="call、apply、bind的区别"></a>call、apply、bind的区别</h3><h4 id="call、apply"><a href="#call、apply" class="headerlink" title="call、apply"></a>call、apply</h4></li><li>改变函数体内部 this 的指向。</li><li>作用完全一样，接受参数的方式不太一样</li><li>call:把参数按顺序传递进去</li><li>apply:把参数放在数组里。　　<h4 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h4></li><li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li><li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li><li>apply 、 call 、bind 三者都可以利用后续参数传参；</li><li><p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p></li><li><p><a href="http://www.cnblogs.com/coco1s/p/4833199.html" target="_blank" rel="noopener">查看更多&gt;</a></p></li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol><li><p>对象的<strong>属性和方法</strong>，定义在<strong>自身</strong>或定义在<strong>它的原型对象上</strong>。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。</p></li><li><p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。而Object.prototype对象的原型就是没有任何属性和方法的null对象，而null对象没有自己的原型。</p></li><li><p>读取对象的某个属性时:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 引擎先寻找对象本身的属性,</span><br><span class="line"></span><br><span class="line">找不到?就到它的原型去找,</span><br><span class="line"></span><br><span class="line">还是找不到?就到原型的原型去找。</span><br><span class="line"></span><br><span class="line">直到最顶层的Object.prototype还是找不到?则返回undefined。</span><br></pre></td></tr></table></figure></li><li><p>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p></li><li><p>需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。  </p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">查看更多&gt;</a></p></li></ol><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="理解面向对象"><a href="#理解面向对象" class="headerlink" title="理解面向对象"></a>理解面向对象</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">重新介绍JavaScript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于JS-持续更新&quot;&gt;&lt;a href=&quot;#关于JS-持续更新&quot; class=&quot;headerlink&quot; title=&quot;关于JS [持续更新]&quot;&gt;&lt;/a&gt;关于JS &lt;span style=&quot;font-size:.5em&quot;&gt;[持续更新]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/JS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="notes" scheme="https://hotkang.cn/tags/notes/"/>
    
      <category term="JS" scheme="https://hotkang.cn/tags/JS/"/>
    
      <category term="面试" scheme="https://hotkang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>烂笔头之CSS</title>
    <link href="https://hotkang.cn/2018/05/31/%E7%83%82%E7%AC%94%E5%A4%B4%E4%B9%8BCSS/"/>
    <id>https://hotkang.cn/2018/05/31/烂笔头之CSS/</id>
    <published>2018-05-31T11:12:32.000Z</published>
    <updated>2018-07-10T11:03:47.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-CSS-持续更新"><a href="#关于-CSS-持续更新" class="headerlink" title="关于 CSS  [持续更新]"></a>关于 CSS  <span style="font-size:.5em">[持续更新]</span></h2><p><img src="/img/CSS.jpg" alt=""></p><a id="more"></a><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><pre><code>content、padding、border、margin</code></pre><ul><li><p>标准盒模型: </p><pre><code>content.width = content </code></pre></li><li><p>IE盒模型:  </p><pre><code>content.width = content + padding + border </code></pre></li><li><p>设置盒模型：  </p><pre><code>box-sizing:content-box | border-box</code></pre></li></ul><h2 id="边距重叠"><a href="#边距重叠" class="headerlink" title="边距重叠"></a>边距重叠</h2><ul><li>兄弟元素，外边距取绝对值大的</li></ul><h2 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC - 块级格式化上下文"></a>BFC - 块级格式化上下文</h2><p>1、原理：</p><ul><li>页面上的一个独立容器，容器里面的子元素与外面的元素互不影响；</li><li><p>BFC内部的盒子，会在垂直方向，一个接一个地放置。垂直方向上也会发生边距重叠。</p></li><li><p>BFC的区域不会与float box重叠。</p></li><li>计算BFC的高度时，浮动元素也被计算在内。</li></ul><p>2、如何产生：</p><pre><code>- overflow:auto | hidden  - position: absolute | fixed  - float: left | right  - display: inline-block | table-cell |table-caption | flex | inline-flex  - clear: both</code></pre><p>3、作用：</p><ul><li><p>自适应布局：两栏布局，左边固定，右边自适应</p></li><li><p>清除浮动</p></li><li>解决垂直边距重叠</li><li>float 坍塌问题</li><li>文字浮动问题</li></ul><h2 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h2><ul><li><p>内联样式： 1000</p></li><li><p>ID： 100</p></li><li>类、属性、伪类：10</li><li>标签、伪元素： 1</li></ul><h2 id="引入CSS样式及优先级"><a href="#引入CSS样式及优先级" class="headerlink" title="引入CSS样式及优先级"></a>引入CSS样式及优先级</h2><ul><li>内联/行内 样式 &gt; 内部/内嵌 样式 &gt; 外部样式 &gt; 导入样式  </li></ul><h2 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h2><ul><li>绝对单位： cm mm in pt pc</li><li>相对单位：<ul><li>px ：不考虑分辨率，当做绝对单位对待</li><li>% ：</li><li>em ：相对当前元素（首行缩进用text-indent：2em；） </li><li>rem ：相对于根元素(常用于移动端)</li></ul></li><li><p>视窗单位： </p><ul><li>vh :视窗高度的百分比</li><li>vw </li><li>vmin ：vw vh中较小的一个</li><li>vmax ：vw vh中较大的一个</li></ul></li><li><p>% 相对于谁：</p><ul><li>以父元素容器 <strong>宽</strong> 为基准：padding、margin、width</li><li>以父元素容器 <strong>高</strong> 为基准：height 、定位元素</li><li>以自身：translate</li></ul></li></ul><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ul><li><p>行级元素:   </p><pre><code>父级 {    text-align: center ;  }   </code></pre></li><li><p>块级元素: </p><pre><code>当前元素 {    margin: 0 auto ;  }</code></pre></li><li><p>子元素浮动:  </p><pre><code>父级 {  width:fit-content;    margin:0 auto;}  </code></pre></li><li><p>flex 2012:  </p><pre><code>子元素 {    display:flex;    justify-content:center; }  </code></pre></li><li><p>绝对定位 + transform:  </p><pre><code>子元素 {    position:absolute;    left:50%;    transform:translate（-50% ,0）;  }  </code></pre></li><li><p>定宽 + 绝对定位 + 负值：  </p><pre><code>子元素 {    left:50%;    margin-left:-0.5*宽度;  }   </code></pre></li><li><p>定宽 + 绝对定位 ：  </p><pre><code>子元素 {    left:0;    right:0;    margin:0 auto;  }</code></pre></li></ul><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ul><li><p>单行文本  </p><pre><code>当前元素 {     line-height:父级元素高度 ; }</code></pre></li><li><p>行内块级元素  </p><pre><code>父级元素:after 当前元素{    display: inline-block;    vertical-align: middle;  }  </code></pre></li><li><p>元素高度不定  </p><pre><code>父元素: {    display:table;  }  当前元素 {    display: table-cell;  vertical-align:middle;  }  </code></pre><p>  元素内容不会被截断 </p></li><li><p>元素高度固定 </p><pre><code>父级{    position:relative;  }  当前元素{    height:固定;    position:absolute;    top:50%;    margin-top:-0.5*高度；  }|{    height:固定;   position:absolute;     top:0;    bottom:0;    margin: auto 0;  }</code></pre><ul><li><p>Flex 2012 </p><pre><code>父级元素{    display:flex;    algin-items:center;  } </code></pre></li><li><p>transform</p><pre><code>父级{    position:relative;  }   当前元素{    position:absolute;    top:50%;    transform:translate(-50% , -50%);  }</code></pre></li></ul></li></ul><h2 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h2><p>[待完善]</p><h2 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h2><ul><li><p>伪类：效果可以通过添加实际类实现，只要不是互斥可以叠加使用，优先级与类相同</p></li><li><p>伪元素：效果可以通过添加实际元素来实现，在一个选择器中只能出现一次，且只能出现在末尾，优先级与标签相同  </p></li><li><p>本质区别：是否抽象创造了新元素</p></li></ul><hr><p><a href="http://www.bslxx.com/m/view.php?aid=1217" target="_blank" rel="noopener">参考链接》</a></p><h2 id="html5为什么只需要写-lt-doctype-html-gt"><a href="#html5为什么只需要写-lt-doctype-html-gt" class="headerlink" title="html5为什么只需要写&lt;!doctype html&gt;"></a>html5为什么只需要写&lt;!doctype html&gt;</h2><ul><li>html5不是基于sgml（标准通用标记语言），不需要对dtd文件进行引用，但是需要doctype来规范浏览器的行为，否则浏览器将开启怪异模式。</li><li>而html4.01基于sgml，需要引入dtd，才能告知浏览器文档使用的文档类型</li></ul><h2 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h2><h3 id="同"><a href="#同" class="headerlink" title="同"></a>同</h3><ul><li>都是外部引用CSS的方式<h3 id="异"><a href="#异" class="headerlink" title="异"></a>异</h3></li></ul><hr><table><thead><tr><th style="text-align:center">link</th><th style="text-align:left">@import</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>XHTML标签,除加载CSS,还可以定义RSS等其他事务 | 属于CSS范畴，只能加载CSS<br>引用CSS时，在页面载入时同时加载 | 需要页面网页完全载入以后加载<br>XHTML标签，无兼容问题 | CSS2.1提出,低版本的浏览器不支持<br>支持使用Javascript控制DOM去改变样式 | 不支持Javascript控制DOM去改变样式</p><hr><h2 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h2><table><thead><tr><th style="text-align:center">内核</th><th style="text-align:left">浏览器</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>Trident| <strong>IE</strong>、Maxthon、TT、The World等<br>Gecko | Netcape6及以上版本、<strong>FireFox</strong>、MozillaSuite/SeaMonkey<br>Presto  | <strong>Opera7及以上版本</strong><br>Webkit | Safari、<strong>Chrome</strong></p><hr><h2 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h2><blockquote><p>NULL </p></blockquote><ul><li>null是一个表示”无”的对象，转为数值时为0;</li><li>null表示”没有对象”，即该处不应该有值;<ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul></li></ul><blockquote><p>undefined</p><ul><li>undefined是一个表示”无”的原始值，转为数值时为NaN。</li><li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义<ul><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ul></li></ul></blockquote><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ul><li>进入”严格模式”的标志，老版本的浏览器会把它当作一行普通字符串，加以忽略</li><li>引用<ul><li>将”use strict”放在<strong>脚本文件的第一行</strong>，则整个脚本都将以”严格模式”运行。</li><li>将”use strict”放在<strong>函数体的第一行</strong>，则整个函数以”严格模式”运行<blockquote><p>因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将<strong>整个脚本文件放在一个立即执行的匿名函数之中</strong></p></blockquote></li></ul></li><li>作用<ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。<h2 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h2></li></ul></li><li>执行对象查找时，永远不会去查找原型</li><li>用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。</li><li>该方法属于Object对象，由于所有的对象都”继承”了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。</li></ul><h2 id="时间格式化YYY-MM-DD"><a href="#时间格式化YYY-MM-DD" class="headerlink" title="时间格式化YYY-MM-DD"></a>时间格式化YYY-MM-DD</h2><pre><code>now: function () {  var time = new Date(),      Y = time.getFullYear(),      M = time.getMonth()+1,         D = time.getDate();      M = M &lt; 10? &apos;0&apos;+M : M;      D = D &lt; 10? &apos;0&apos;+D :D;  return Y +&apos;-&apos;+ M +&apos;-&apos;+ D;}</code></pre><h2 id="任意时间"><a href="#任意时间" class="headerlink" title="任意时间"></a>任意时间</h2><pre><code>date: function (Day) {    var time = new Date();        time.setDate(time.getDate() + Day);    var Y = time.getFullYear(),        M = (time.getMonth()+1) &lt; 10 ? &quot;0&quot;+ (time.getMonth() + 1) : (time.getMonth() + 1),            D = time.getDate() &lt; 10 ? &quot;0&quot; + time.getDate() : time.getDate();    return Y + &quot;-&quot; + M + &quot;-&quot; + D;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于-CSS-持续更新&quot;&gt;&lt;a href=&quot;#关于-CSS-持续更新&quot; class=&quot;headerlink&quot; title=&quot;关于 CSS  [持续更新]&quot;&gt;&lt;/a&gt;关于 CSS  &lt;span style=&quot;font-size:.5em&quot;&gt;[持续更新]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/CSS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="好记性不如烂笔头" scheme="https://hotkang.cn/categories/%E5%A5%BD%E8%AE%B0%E6%80%A7%E4%B8%8D%E5%A6%82%E7%83%82%E7%AC%94%E5%A4%B4/"/>
    
    
      <category term="notes" scheme="https://hotkang.cn/tags/notes/"/>
    
      <category term="面试" scheme="https://hotkang.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="CSS" scheme="https://hotkang.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>用nvm装node.js</title>
    <link href="https://hotkang.cn/2018/05/30/%E7%94%A8nvm%E8%A3%85node-js/"/>
    <id>https://hotkang.cn/2018/05/30/用nvm装node-js/</id>
    <published>2018-05-30T14:23:44.000Z</published>
    <updated>2018-07-11T16:40:14.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于node安装-完结"><a href="#关于node安装-完结" class="headerlink" title="关于node安装  [完结]"></a>关于node安装  <span style="font-size:.5em">[完结]</span></h2><blockquote><p>本地安装？全局安装？nvm安装？傻傻分不清楚？<br>使用 nvm 管理不同版本的 node 与 npm</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。 </p><ul><li>了解<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">NVM</a>  </li><li>了解<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>  </li><li>了解<a href="https://nodejs.org/en/download/package-manager/" target="_blank" rel="noopener">通过包管理器安装Node.js</a>NVM部分  </li><li>了解<a href="https://www.npmjs.com/get-npm" target="_blank" rel="noopener">NPM</a>  </li><li><a href="https://www.runoob.com/w3cnote/nvm-manager-node-versions.html" target="_blank" rel="noopener">本文参考链接</a> </li></ul></blockquote><hr><h2 id="一、卸载全局安装的-node"><a href="#一、卸载全局安装的-node" class="headerlink" title="一、卸载全局安装的 node"></a>一、卸载全局安装的 node</h2><p>在官网下载的 node 安装包,运行后会自动安装在全局目录,使用过程中经常会遇到一些权限问题,用以下方法卸载全局安装的 node。(不需要卸载则跳过此步骤)</p><blockquote><p>删除 node 和 node_modules 相关的文件和文件夹  </p></blockquote><p>打开Finder,按 shift+command+G 来打开前往文件夹的窗口,分别进入下列目录,删除 node 和 node_modules 相关的文件和文件夹</p><pre><code>/usr/local/lib/usr/local/include</code></pre><blockquote><p>如果你是使用的 brew install node 安装的,还需要在终端中执行以下命令来卸载</p></blockquote><pre><code>$ brew uninstall node </code></pre><blockquote><p>检查 node 和 node_modules 相关文件/文件夹是否删除成功    </p></blockquote><p>检查个人主文件夹下面的所有的 local、lib 以及 include 文件夹，并且删除所有与 node 和 node_modules 相关的文件以及文件夹</p><blockquote><p>进入 /usr/local/bin 并删除 node 可执行文件  </p></blockquote><blockquote><p>你可能还需要在终端中输入一些额外的指令  </p></blockquote><pre><code>$ sudo rm /usr/local/bin/npm$ sudo rm /usr/local/share/man/man1/node.1$ sudo rm /usr/local/lib/dtrace/node.d$ sudo rm -rf ~/.npm$ sudo rm -rf ~/.node-gyp$ sudo rm /opt/local/bin/node$ sudo rm /opt/local/include/node$ sudo rm -rf /opt/local/lib/node_modules</code></pre><h2 id="二、OSX-安装-NVM"><a href="#二、OSX-安装-NVM" class="headerlink" title="二、OSX 安装 NVM"></a>二、OSX 安装 NVM</h2><blockquote><p>用 X-Code 的命令行工具  </p></blockquote><p>运行以下命令</p><pre><code>$ xcode-select --install$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</code></pre><h2 id="三、安装多版本-node"><a href="#三、安装多版本-node" class="headerlink" title="三、安装多版本 node"></a>三、安装多版本 node</h2><p>查看远程服务器上所有的可用版本  </p><pre><code>$ nvm ls-remote</code></pre><p>安装最新版 Node    </p><pre><code>$ nvm install node </code></pre><p>安装某一版本(4.2.2)   </p><pre><code>$ nvm install 4.2.2</code></pre><p>安装4.2 系列的最新的一个版本   </p><pre><code>$ nvm install 4.2</code></pre><p>nvm 遵守语义化版本命名规则,nvm 会寻找 4.2.x 中最高的版本来安装。</p><h2 id="四、在不同版本间切换"><a href="#四、在不同版本间切换" class="headerlink" title="四、在不同版本间切换"></a>四、在不同版本间切换</h2><p>每当安装了一个新版本 Node 后,全局环境会自动把这个新版本设置为默认。</p><blockquote><p>nvm 提供 nvm use 命令用于版本切换  </p></blockquote><p>切换到最新版：</p><pre><code>$ nvm use node</code></pre><p>切换到 4.2.2：</p><pre><code>$ nvm use 4.2.2</code></pre><p>切换到最新的 4.2.x：</p><pre><code>$ nvm use 4.2</code></pre><p>每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。</p><h2 id="五、用-nvm-给不同的版本号设置别名"><a href="#五、用-nvm-给不同的版本号设置别名" class="headerlink" title="五、用 nvm 给不同的版本号设置别名"></a>五、用 nvm 给不同的版本号设置别名</h2><p>给4.2.2 版本号起个别名hotyan-version  </p><pre><code>$ nvm alias hotyan-version 4.2.2</code></pre><p>运行:</p><pre><code>$ nvm use hotyan-version</code></pre><p>取消别名：</p><pre><code>$ nvm unalias hotyan-version  </code></pre><h2 id="六、列出已安装实例"><a href="#六、列出已安装实例" class="headerlink" title="六、列出已安装实例"></a>六、列出已安装实例</h2><pre><code>$ nvm ls</code></pre><h2 id="七、确认某个版本Node的路径"><a href="#七、确认某个版本Node的路径" class="headerlink" title="七、确认某个版本Node的路径"></a>七、确认某个版本Node的路径</h2><pre><code>$ nvm which 4.2.2</code></pre><h2 id="八、检查是否成功安装node和npm"><a href="#八、检查是否成功安装node和npm" class="headerlink" title="八、检查是否成功安装node和npm"></a>八、检查是否成功安装node和npm</h2><p>当成功下载Node.js时,会自动安装npm。<br>检查Node</p><pre><code>$ node -v</code></pre><p>确认npm</p><pre><code>$ npm -v</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于node安装-完结&quot;&gt;&lt;a href=&quot;#关于node安装-完结&quot; class=&quot;headerlink&quot; title=&quot;关于node安装  [完结]&quot;&gt;&lt;/a&gt;关于node安装  &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本地安装？全局安装？nvm安装？傻傻分不清楚？&lt;br&gt;使用 nvm 管理不同版本的 node 与 npm&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Install" scheme="https://hotkang.cn/categories/Install/"/>
    
    
      <category term="node.js" scheme="https://hotkang.cn/tags/node-js/"/>
    
      <category term="nvm" scheme="https://hotkang.cn/tags/nvm/"/>
    
      <category term="npm" scheme="https://hotkang.cn/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>用hexo搭建github博客二</title>
    <link href="https://hotkang.cn/2018/05/29/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E4%BA%8C/"/>
    <id>https://hotkang.cn/2018/05/29/用hexo搭建github博客二/</id>
    <published>2018-05-29T07:39:01.000Z</published>
    <updated>2018-07-18T10:44:43.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优化博客-持续完善"><a href="#优化博客-持续完善" class="headerlink" title="优化博客 [持续完善]"></a>优化博客 <span style="font-size:.5em">[持续完善]</span></h2><blockquote><p>搜索了很多Next主题的效果，总结了下常用的效果~  </p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">参考链接1</a></li><li><a href="https://www.jianshu.com/p/efbeddc5eb19" target="_blank" rel="noopener">参考链接2</a></li><li><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">参考链接3</a></li><li><a href="https://www.jianshu.com/p/1f8107a8778c" target="_blank" rel="noopener">参考链接4</a></li><li><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题</a>  </li></ul></blockquote><hr><h2 id="一、修改Next主题模式"><a href="#一、修改Next主题模式" class="headerlink" title="一、修改Next主题模式"></a>一、修改Next主题模式</h2><blockquote><p>修改themes/next/_config.yml文件Schemes属性  </p></blockquote><p>注意不要跟根目录下的_config.yml混淆</p><pre><code># Schemes    #scheme: Muse       #scheme: Mist    scheme: Pisces    #scheme: Gemini</code></pre><p>NexT主题默认使用Muse模式,根据自己的喜好选择。<br><del>我比较喜欢Pisces ,并看了源码做了些样式修改。</del> </p><p>后来我喜欢上了Gemini。<br>Gemini跟Pisce相似,而且Gemini的源码样式是在Pisce的基础上重写的。</p><blockquote><p>更新Hexo部署  </p></blockquote><p>每次修改后都可以更新部署,也可最后再一次性部署。后面不再赘述。</p><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo clean    // 清理缓存$ hexo generate // 生成文件$ hexo deploy   // 线上部署/*简写如下*/$ hexo clean$ hexo g$ hexo d</code></pre><h2 id="二、设置首页预览摘要"><a href="#二、设置首页预览摘要" class="headerlink" title="二、设置首页预览摘要"></a>二、设置首页预览摘要</h2><p>了解一下<a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95" target="_blank" rel="noopener">Next官网介绍的三种方法</a></p><p>我使用的是用<code>&lt;!-- more --&gt;</code>进行手动截断</p><h2 id="三、侧边栏显示效果"><a href="#三、侧边栏显示效果" class="headerlink" title="三、侧边栏显示效果"></a>三、侧边栏显示效果</h2><blockquote><p>修改themes/next/_config.yml文件sidebar属性 </p></blockquote><pre><code>sidebar:    # Sidebar Position, available value: left | right (only for Pisces | Gemini).    position: left    #position: right //修改侧边栏位置    # Sidebar Display, available value (only for Muse | Mist):    #  - post    expand on posts automatically. Default.    #  - always  expand for all pages automatically    #  - hide    expand only when click on the sidebar toggle icon.    #  - remove  Totally remove sidebar including sidebar toggle.    #display: post      //默认    display: always     //一直显示    #display: hide      //初始隐藏    #display: remove    //移除侧边栏</code></pre><p>根据提示,设置自己喜欢的样式,我是Pisces主题,设置侧边栏在左边,且一直显示。</p><blockquote><p>更新Hexo部署(同上)</p></blockquote><h2 id="四、侧边栏社交链接"><a href="#四、侧边栏社交链接" class="headerlink" title="四、侧边栏社交链接"></a>四、侧边栏社交链接</h2><blockquote><p>修改themes/next/_config.yml文件social属性</p></blockquote><pre><code>/*文字链接*/social:    GitHub: https://github.com/hotYan || github    E-Mail: mailto:15823566422@163.com || envelope/*链接前图标*/social_icons:    enable: true    GitHub: github </code></pre><p>我只添加了GitHub、E-Mail。</p><blockquote><p>更新Hexo部署(同上)</p></blockquote><h2 id="五、设置RSS"><a href="#五、设置RSS" class="headerlink" title="五、设置RSS"></a>五、设置RSS</h2><blockquote><p>安装 hexo-generator-feed 插件  </p></blockquote><p>RSS需要有一个Feed链接，而这个链接需要靠hexo-generator-feed插件来生成</p><pre><code>$ cd HotYan_Blog$ npm install hexo-generator-feed --save</code></pre><blockquote><p>修改/_config.yml文件  </p></blockquote><pre><code>#type: RSS的类型(atom/rss2)#path: 文件路径,默认是atom.xml/rss2.xml#limit:展示文章的数量,使用0或则false代表展示全部# RSS订阅插件feed:     type: atom    path: atom.xml    limit: 0#RSS订阅支持plugins: hexo-generate-feed</code></pre><blockquote><p>修改themes/next/_config.yml文件rss属性   </p></blockquote><pre><code>rss: /atom.xml </code></pre><blockquote><p>更新Hexo部署(同上)</p></blockquote><h2 id="六、添加菜单选项"><a href="#六、添加菜单选项" class="headerlink" title="六、添加菜单选项"></a>六、添加菜单选项</h2><p>默认情况下，菜单导航栏有首页、归档、关于三个选项，我们可以自行添加</p><blockquote><p>修改themes/next/_config.yml文件menu属性</p></blockquote><pre><code>menu:    home: / || home                //默认有    about: /about/ || user         // 默认有    tags: /tags/ || tags            //自行添加    categories: /categories/ || th  //自行添加    archives: /archives/ || archive   //默认有</code></pre><p>比如我添加了tags、categories</p><blockquote><p>创建文件夹  </p></blockquote><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo new page &quot;tags&quot;$ hexo new page &quot;categories&quot;</code></pre><blockquote><p>修改index.md  </p></blockquote><p>在/source/目录下创建了categories、tags文件夹,在这些文件夹中分别会创建一个index.md文件,对内容type进行修改，使之分别为:</p><pre><code>---title: categoriesdate: 2018-05-29 00:02:39type: &quot;categories&quot;---</code></pre><hr><pre><code>---title: tagsdate: 2018-05-29 00:02:54type: &quot;tags&quot;---</code></pre><blockquote><p>更新Hexo部署(同上)</p></blockquote><h2 id="七、修改文章底部标签样式"><a href="#七、修改文章底部标签样式" class="headerlink" title="七、修改文章底部标签样式"></a>七、修改文章底部标签样式</h2><blockquote><p>修改/themes/next/layout/_macro/post.swig文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;post-tags&quot;&gt;  </span><br><span class="line">  &#123;% for tag in post.tags %&#125;</span><br><span class="line">     &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><blockquote><p>更新Hexo部署(同上)</p></blockquote><h2 id="八、文章末尾添加结束标记"><a href="#八、文章末尾添加结束标记" class="headerlink" title="八、文章末尾添加结束标记"></a>八、文章末尾添加结束标记</h2><blockquote><p>在/themes/next/layout/_macro新建passage-end-tag.swig  </p></blockquote><p>添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">    &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt; - END - &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>修改/themes/next/layout/_macro/post.swig文件  </p></blockquote><p>在下面相应的位置添加添加相应的代码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/*插入代码如下*/</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include&apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*插入到此处结束*/</span><br><span class="line"></span><br><span class="line">&lt;footer class=&quot;post-footer&quot;&gt;</span><br><span class="line">&#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><del>看参考文档的时候觉得代码插入的地方描述的不是很清楚</del><br><del>觉得自己描述的很清楚了</del></p><blockquote><p>修改themes/next/_config.yml文件  </p></blockquote><p>在任意地方添加下面代码</p><pre><code># 文章末尾添加结束标记passage_end_tag:    enabled: true</code></pre><blockquote><p>更新Hexo部署(同上)</p></blockquote><h2 id="九、访问量统计"><a href="#九、访问量统计" class="headerlink" title="九、访问量统计"></a>九、访问量统计</h2><blockquote><p>修改themes/next/_config.yml文件busuanzi_count属性  </p></blockquote><pre><code>busuanzi_count:    # count values only if the other configs are false    enable: true     # 站点UV配置 总访问人次(一个人访问多篇文章记录一次)    site_uv: false    site_uv_header: 总访问量    site_uv_footer:    # 站点PV配置 总访问量(一个人访问多篇文章记录多次)    site_pv: false    site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;    site_pv_footer: 次    # 文章PV配置 访问量    page_pv: true    page_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;    page_pv_footer: </code></pre><p>我只设置了文章访问量</p><blockquote><p>更新Hexo部署(同上)</p></blockquote><h2 id="十、修改头像"><a href="#十、修改头像" class="headerlink" title="十、修改头像"></a>十、修改头像</h2><p>在themes/next/source/images下放置头像</p><blockquote><p>修改themes/next/_config.yml文件avatar属性  </p></blockquote><pre><code>avatar: ../images/avata.gif</code></pre><p>路径为头像目录</p><blockquote><p>更新Hexo部署(同上)</p></blockquote><h2 id="十一、添加背景图"><a href="#十一、添加背景图" class="headerlink" title="十一、添加背景图"></a>十一、添加背景图</h2><blockquote><p>修改themes/next/source/css _custom/custom.styl  </p></blockquote><p>添加如下代码:</p><pre><code>body{    background:url(../images/xx.jpg);    background-size:cover;    background-repeat:no-repeat;    background-attachment:fixed;    background-position:center;}</code></pre><h2 id="十二、修改各版块透明度"><a href="#十二、修改各版块透明度" class="headerlink" title="十二、修改各版块透明度"></a>十二、修改各版块透明度</h2><blockquote><p>内容板块    </p></blockquote><ul><li><p>修改在对应主题的对应.yml文件中,ID为【.content-wrap】标签下的background属性</p><pre><code>background: rgba(255,255,255,0.7); </code></pre></li><li><p>以主题Pisces为例,对应内容板块文件路径为:</p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre><blockquote><p>菜单栏</p></blockquote></li><li>修改在对应主题的对应.yml文件中,ID为【.header-inner】标签下的background属性。  </li><li><p>以主题Pisces为例,对应菜单栏文件路径为: </p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre><blockquote><p>站点概况</p></blockquote></li><li>修改在对应主题的对应.yml文件中,ID为【.sidebar-inner】标签下的background属性</li><li><p>以主题Pisces为例,对应站点概况文件路径为: </p><pre><code>themes/next/source/css/_schemes/Pisces/_sidebar.styl</code></pre></li><li>修改在对应主题的对应.yml文件中,ID为【.sidebar】标签下的background属性</li><li><p>以主题Pisces为例,对应站点概况文件路径为: </p><pre><code>themes/next/source/css/_schemes/Pisces/_layout.styl</code></pre><blockquote><p>按钮背景  </p></blockquote></li></ul><p>主题共享的文件,文件位置:</p><pre><code>themes/next/source/css _custom/components/post/post-button.styl</code></pre><h2 id="十三、点击出现桃心"><a href="#十三、点击出现桃心" class="headerlink" title="十三、点击出现桃心"></a>十三、点击出现桃心</h2><ol><li>copy<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="noopener">网页</a>代码</li><li>在<code>/themes/next/source/js/src</code>目录下新建love.js文件,把copy的代码粘贴到此文件。</li><li><p>在\themes\next\layout_layout.swig 文件引入love.js</p><pre><code>在&lt;/body&gt;标签前引入love.js&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</code></pre></li></ol><p>【我发现在文章详情界面,没有效果,理论上应该是有效果的吧？？可能源码被我改砸了？？】</p><h2 id="十四、取消文章目录自动编号"><a href="#十四、取消文章目录自动编号" class="headerlink" title="十四、取消文章目录自动编号"></a>十四、取消文章目录自动编号</h2><blockquote><p>修改themes/next/_config.yml文件toc属性  </p></blockquote><pre><code># Table Of Contents in the Sidebartoc:  enable: true# Automatically add list number to toc.  number: false      /*修改这里*/# If true, all words will placed on next lines if header width longer then sidebar width.  wrap: false</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优化博客-持续完善&quot;&gt;&lt;a href=&quot;#优化博客-持续完善&quot; class=&quot;headerlink&quot; title=&quot;优化博客 [持续完善]&quot;&gt;&lt;/a&gt;优化博客 &lt;span style=&quot;font-size:.5em&quot;&gt;[持续完善]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;搜索了很多Next主题的效果，总结了下常用的效果~  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="hexo" scheme="https://hotkang.cn/tags/hexo/"/>
    
      <category term="博客" scheme="https://hotkang.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Mac Use Homebrew Install Mongodb</title>
    <link href="https://hotkang.cn/2018/05/29/use%20homebrew%20install%20mongodb/"/>
    <id>https://hotkang.cn/2018/05/29/use homebrew install mongodb/</id>
    <published>2018-05-29T07:38:51.000Z</published>
    <updated>2018-07-11T16:40:50.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac-Use-Homebrew-Install-Mongodb-完结"><a href="#Mac-Use-Homebrew-Install-Mongodb-完结" class="headerlink" title="Mac Use Homebrew Install Mongodb [完结]"></a>Mac Use Homebrew Install Mongodb <span style="font-size:.5em">[完结]</span></h2><blockquote><p>图书管理系统,一开始是打算用Express+ejs+Mongodb,但是后期,使用mongoose出现了问题,尝试解决,没有成功后,就放弃了,转而使用Mysql。将安装过程记录一下。</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接,以下内容作为我的个人记录,以我的角度去记录,总结。</p><ul><li><a href="https://brew.sh/" target="_blank" rel="noopener">homebrew官网</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html" target="_blank" rel="noopener">参考链接</a>  </li></ul></blockquote><hr><h2 id="一、安装Homebrew"><a href="#一、安装Homebrew" class="headerlink" title="一、安装Homebrew"></a>一、安装Homebrew</h2><p>打开Terminal并运行以下命令 </p><pre><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>【注意】 Homebrew将作为安装过程的一部分下载并安装Xcode 8.0的命令行工具。</p><h2 id="二、安装MongoDB"><a href="#二、安装MongoDB" class="headerlink" title="二、安装MongoDB"></a>二、安装MongoDB</h2><p>1.运行以下命令进行安装mongodb  </p><pre><code>$ brew install mongodb</code></pre><p>2.将mongodb升级，确保版本最新  </p><pre><code>$ brew upgrade mongodb</code></pre><p>3.创建一个目录，用来保存mongo默认的数据</p><pre><code>$ mkdir -p /data/db</code></pre><p>4.给目录以可读可写的权限 </p><pre><code>$ chown `id -u` /data/db</code></pre><p>5.启动 </p><pre><code>$ brew services start mongodb</code></pre><h2 id="三、未正常关闭导致数据库突然启动不了"><a href="#三、未正常关闭导致数据库突然启动不了" class="headerlink" title="三、未正常关闭导致数据库突然启动不了"></a>三、未正常关闭导致数据库突然启动不了</h2><p>1.删除掉mongod.lock文件，然后重新启动</p><p>2.如果还是不可以，先查看一下进程</p><pre><code>$ ps -aef | grep mongo</code></pre><p>3.然后根据进程ID杀掉进程</p><pre><code>$ sudo kill 6955</code></pre><p>4.重新启动mongodb服务</p><pre><code>$ brew services start mongodb</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mac-Use-Homebrew-Install-Mongodb-完结&quot;&gt;&lt;a href=&quot;#Mac-Use-Homebrew-Install-Mongodb-完结&quot; class=&quot;headerlink&quot; title=&quot;Mac Use Homebrew Install Mongodb [完结]&quot;&gt;&lt;/a&gt;Mac Use Homebrew Install Mongodb &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;图书管理系统,一开始是打算用Express+ejs+Mongodb,但是后期,使用mongoose出现了问题,尝试解决,没有成功后,就放弃了,转而使用Mysql。将安装过程记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Install" scheme="https://hotkang.cn/categories/Install/"/>
    
    
      <category term="Homebrew" scheme="https://hotkang.cn/tags/Homebrew/"/>
    
      <category term="Mongodb" scheme="https://hotkang.cn/tags/Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>用hexo搭建github博客一</title>
    <link href="https://hotkang.cn/2018/05/29/%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E4%B8%80/"/>
    <id>https://hotkang.cn/2018/05/29/用hexo搭建github博客一/</id>
    <published>2018-05-29T07:38:51.000Z</published>
    <updated>2018-07-11T16:38:38.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建博客-完结"><a href="#搭建博客-完结" class="headerlink" title="搭建博客 [完结]"></a>搭建博客 <span style="font-size:.5em">[完结]</span></h2><blockquote><p>一直想搭个人博客,却无从下手？？</p></blockquote><a id="more"></a><h2 id="链接自取"><a href="#链接自取" class="headerlink" title="链接自取"></a>链接自取</h2><blockquote><p>个人比较喜欢先甩参考链接,可以选择直接去看参考链接。</p><ul><li><a href="http://dmkf.xyz/2017/03/12/6272440/" target="_blank" rel="noopener">参考教程1</a>  </li><li><a href="https://sunny73.github.io/2018/02/10/Build-my-first-blog/" target="_blank" rel="noopener">参考教程2</a>  </li><li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官网文档</a></li></ul></blockquote><p>【注意】第二个链接也是参考第一个写的,第一个链接加载超级慢,可以选择看第二个</p><hr><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><blockquote><p>1.默认已有GitHub账号  </p></blockquote><ul><li>没有GitHub账号？？<a href="https://github.com/" target="_blank" rel="noopener">点击注册</a>  </li></ul><blockquote><p>2.默认已安装Git  </p></blockquote><ul><li>没有安装Git？？<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git" target="_blank" rel="noopener">了解如何安装</a></li></ul><blockquote><p>3.默认已安装 Node.js  </p></blockquote><ul><li>没有安装Node.js??<a href="https://hotyan.github.io/2018/05/30/%E7%94%A8nvm%E8%A3%85node-js/" target="_blank" rel="noopener">了解如何安装</a></li></ul><blockquote><p>4.Install Hexo    </p></blockquote><ul><li><p>全局下载hexo</p><pre><code>$ npm install -g hexo-cli</code></pre></li><li><p>查看是否成功  </p><pre><code>$ hexo</code></pre></li></ul><p>进入<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官网文档</a>了解更多</p><h2 id="二、初始化博客"><a href="#二、初始化博客" class="headerlink" title="二、初始化博客"></a>二、初始化博客</h2><pre><code>$ hexo init HotYan_Bolg //创建一个放在博客项目的文件$ cd HotYan_Bolg       //进入该文件$ npm install       //安装依赖包</code></pre><p><br>进入HotYan_Bolg,已自动生成以下文件</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><h2 id="三、本地搭建"><a href="#三、本地搭建" class="headerlink" title="三、本地搭建"></a>三、本地搭建</h2><blockquote><p>1.修改_config.yml文件  </p></blockquote><p>根据个人情况修改以下部分:</p><pre><code>/*修改前*/# Sitetitle: # The title of your websitesubtitle: # The subtitle of your websitedescription: # The description of your websiteauthor: # Your namelanguage: # The language of your websitetimezone:/*修改后*/# Sitetitle: hotYan&apos;s Blog subtitle: 爱美的程序媛description: 毒鸡汤Yankeywords:author: hotYanlanguage: zh-CNtimezone: Asia/Shanghai</code></pre><p>【每一项的填写,其 <strong>:</strong> 后面都要保留一个空格,下同。】</p><blockquote><p>2.本地运行  </p></blockquote><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo generate // 生成文件$ hexo server   //本地部署/*简写如下*/$ hexo g$ hexo s</code></pre><p>可在浏览器输入地址 <a href="http://host:4000" target="_blank" rel="noopener">http://host:4000</a> 进行查看</p><h2 id="四、配置远程环境-线上运行"><a href="#四、配置远程环境-线上运行" class="headerlink" title="四、配置远程环境,线上运行"></a>四、配置远程环境,线上运行</h2><p>【不一定要线上运行可跳过此步骤】</p><blockquote><p>1.github新建一个库</p></blockquote><pre><code>库名格式为: username.github.io //非常重要！！！</code></pre><p>你可能想了解一下<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a></p><blockquote><p>2.配置_config.yml文件</p><ul><li>配置统一资源定位符（个人域名）  </li></ul></blockquote><pre><code>/*配置前*/# URL## If your site is put in a subdirectory, .....url: http://yoursite.com/child/*配置后*/  # URL## If your site is put in a subdirectory,......url: http://github.com</code></pre><ul><li><p>配置部署  </p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:    type: git     /*repo项是之前Github上创建好的仓库地址*/    repo: https://github.com/hotYan/hotYan.github.io.git    branch: master</code></pre></li></ul><blockquote><p>3.线上运行  </p></blockquote><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo generate // 生成文件$ hexo deploy   // 线上部署/*简写如下*/$ hexo g$ hexo d</code></pre><p>可在浏览器输入博客地址 <a href="https://hotyan.github.io/" target="_blank" rel="noopener">https://hotyan.github.io/</a> 进行查看</p><h2 id="五、修改主题"><a href="#五、修改主题" class="headerlink" title="五、修改主题"></a>五、修改主题</h2><p>1.<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">下载Next主题</a>  </p><p>2.下载后,将压缩包解压缩,复制其中名称为next的文件夹到你博客文件的themes下  </p><p>3.修改博客文件根目录下的_config.yml,将主题改为next</p><pre><code># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# theme: landscape    theme: next   </code></pre><h2 id="六、更新Hexo部署"><a href="#六、更新Hexo部署" class="headerlink" title="六、更新Hexo部署"></a>六、更新Hexo部署</h2><pre><code>$ cd  HotYan_Blog //进入博客文件夹目录$ hexo clean    // 清理缓存$ hexo generate // 生成文件$ hexo deploy   // 线上部署/*简写如下*/$ hexo clean$ hexo g$ hexo d</code></pre><h2 id="七、创建新文章"><a href="#七、创建新文章" class="headerlink" title="七、创建新文章"></a>七、创建新文章</h2><blockquote><p>1.创建  </p></blockquote><pre><code>$ cd  HotYan_Blog   //进入博客文件夹目录$ hexo new &quot;用hexo搭建github博客一&quot;  // 新建一篇文章</code></pre><p>可在博客文件夹下的source/_post查看你新建的markdown文件  </p><blockquote><p>2.编写内容</p></blockquote><p>如果不清楚如何编写markdown文件,你可能需要先了解一下。</p><ul><li><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">参考链接1</a></li><li><a href="http://xianbai.me/learn-md/article/syntax/blockquotes.html" target="_blank" rel="noopener">参考链接2</a></li></ul><blockquote><p>3.更新Hexo部署(同上六)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;搭建博客-完结&quot;&gt;&lt;a href=&quot;#搭建博客-完结&quot; class=&quot;headerlink&quot; title=&quot;搭建博客 [完结]&quot;&gt;&lt;/a&gt;搭建博客 &lt;span style=&quot;font-size:.5em&quot;&gt;[完结]&lt;/span&gt;&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一直想搭个人博客,却无从下手？？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="hotYan_博客之路" scheme="https://hotkang.cn/categories/hotYan-%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="hexo" scheme="https://hotkang.cn/tags/hexo/"/>
    
      <category term="博客" scheme="https://hotkang.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>高性能网站建设指南14条规则</title>
    <link href="https://hotkang.cn/2018/05/29/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%9714%E6%9D%A1%E8%A7%84%E5%88%99/"/>
    <id>https://hotkang.cn/2018/05/29/高性能网站建设指南14条规则/</id>
    <published>2018-05-29T00:54:54.000Z</published>
    <updated>2018-07-10T11:03:36.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14条常用性能规则-待完善"><a href="#14条常用性能规则-待完善" class="headerlink" title="14条常用性能规则[待完善]"></a>14条常用性能规则<span style="font-size:.5em">[待完善]</span></h2><p><img src="/img/XN.png" alt=""></p><a id="more"></a>  <h1 id="高性能网站建设指南"><a href="#高性能网站建设指南" class="headerlink" title="高性能网站建设指南"></a>高性能网站建设指南</h1><p>按照优先级顺序依次介绍14个性能规则  </p><p><a href="#减少http请求"><code>1. 减少HTTP请求</code> </a><br><a href="#使用内容分发网络cdn"><code>2. 使用内容分发网络CDN</code>  </a><br><a href="#添加Expires头"><code>3. 添加Expires头</code>  </a><br><a href="#压缩组件"><code>4. 压缩组件</code>  </a><br><a href="#将样式表放在顶部"><code>5. 将样式表放在顶部</code>  </a><br><a href="#将脚本放在底部"><code>6. 将脚本放在底部</code>  </a><br><a href="#避免使用css表达式"><code>7. 避免使用CSS表达式</code>  </a><br><a href="#使用外部JavaScript和CSS"><code>8. 使用外部JavaScript和CSS</code></a><br><a href="#减少dns查找"><code>9. 减少DNS查找</code></a><br><a href="#精简javascript"><code>10. 精简JavaScript</code></a><br><a href="#避免重定向"><code>11. 避免重定向</code>  </a><br><a href="#删除重复的脚本"><code>12. 删除重复的脚本</code>  </a><br><a href="#配置etags"><code>13. 配置ETags</code>  </a><br><a href="#使ajax可缓存"><code>14. 使Ajax可缓存</code></a>  </p><hr><p>终端用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像、样式表、脚本、Flash等。    </p><h2 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h2><ul><li><p>图片地图</p><ul><li><p>假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。    </p><p>  <img src="/img/JL.png" alt=""></p></li><li>服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应</li><li>客户端图片地图：直接将点击映射到操作</li></ul></li><li><p>CSS Sprites ：将背景图像组合成单个图像 </p><ul><li><p>优点 ：    </p><pre><code>1.减少HTTP请求，响应时间短  2.图片数量变少，降低下载量</code></pre></li><li><p>方法：</p><pre><code>使用  CSSbackground-image  background-position  属性显示所需的图像片段。      </code></pre></li></ul></li></ul><ul><li><p>内内联图片</p><ul><li><p>使用 data:URL 模式，允许将小块数据内联为“立即数”，数据就在URL自身中。</p><pre><code>格式：data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></pre><ul><li>合并脚本和样式表</li></ul></li><li>通过将所有脚本合并为一个脚本来减少HTTP请求数量的方法，同样也可以将所有CSS合并到一个样式表中，能够缩短响应时间。</li></ul></li></ul><h3 id="使用内容分发网络CDN"><a href="#使用内容分发网络CDN" class="headerlink" title="使用内容分发网络CDN"></a>使用内容分发网络CDN</h3><ul><li>用户与Web服务器的距离对响应时间有影响。在多个地理位置分散的服务器上部署您的内容将使您的网页从用户的角度更快加载。但是你应该从哪里开始？</li></ul><p>作为实现地理上分散的内容的第一步，不要尝试重新设计您的Web应用程序以在分布式架构中工作。根据应用程序的不同，更改体系结构可能包括艰巨的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与内容之间的距离可能会延迟或不能通过此应用程序体系结构步骤。</p><p>请记住，80-90％的最终用户响应时间用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是性能黄金法则。  </p><p>不要从重新设计应用程序体系结构的艰巨任务开始，最好先分散您的静态内容。这不仅实现了响应时间的更大缩短，而且由于内容交付网络，这更容易实现。</p><p><code>内容传送网络（CDN）</code>是分布在多个位置的网络服务器的集合，以更高效地向用户传送内容。选择用于将内容递送给特定用户的服务器通常基于网络邻近度的度量。例如，选择网络跳数最少的服务器或响应时间最快的服务器。</p><p>一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如Akamai Technologies，EdgeCast或level3）具有成本效益。对于创业公司和私人网站来说，CDN服务的成本可能会很高，但随着您的目标受众不断扩大并变得更加全球化，CDN是实现快速响应所必需的。</p><h3 id="添加Expires头"><a href="#添加Expires头" class="headerlink" title="添加Expires头"></a>添加Expires头</h3><p>这条规则有两个方面：</p><ul><li>对于静态组件：通过设置远期<code>Expires</code>标题实现“永不过期”策略</li><li>对于动态组件：使用适当的<code>Cache-Control</code>头文件来帮助浏览器提供有条件的请求</li></ul><p>网页设计越来越丰富，这意味着更多的脚本，样式表，图像和Flash在页面中。  </p><p>首次访问您的页面可能需要发出多个HTTP请求，但通过使用Expires标头，可以使这些组件可缓存。这避免了后续页面浏览中不必要的HTTP请求。  </p><p>过期标头最常用于图像，但它们应该用于所有组件，包括脚本，样式表和Flash组件。</p><p>浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，使网页加载速度更快。<br>Web服务器使用HTTP响应中的Expires标头告诉客户端可以缓存组件的时间。  </p><p>请记住，如果您使用远期未来的Expires头文件，则只要组件更改，就必须更改组件的文件名。</p><p>只有在用户已经访问过您的网站后，使用远期未来的Expires标题才会影响页面浏览。  </p><p>当用户第一次访问您的网站并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。  </p><p>因此，这种性能改进的影响取决于用户多久访问一次带有缓冲区的页面。（一个“准备好的缓存”已经包含了页面中的所有组件。）我们在Yahoo!上测试了这一点。并发现带有引导缓存的页面浏览量为75-85％。通过使用远期未来的Expires标题，您可以增加浏览器缓存的组件数量，并在后续页面浏览中重新使用，而无需在用户的Internet连接上发送单个字节。</p><h3 id="Gzip压缩传输文件"><a href="#Gzip压缩传输文件" class="headerlink" title="Gzip压缩传输文件"></a>Gzip压缩传输文件</h3><p>通过网络传输HTTP请求和响应所需的时间可以通过前端工程师做出的决策大大减少。  </p><p>确实，最终用户的带宽速度，互联网服务提供商，邻近对等交换点等是超出了开发团队的控制范围。  </p><p>但还有其他一些影响响应时间的因素。  </p><p>压缩通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP / 1.1开始，Web客户端通过HTTP请求中的Accept-Encoding标头指示对压缩的支持。  </p><pre><code>Accept-Encoding：gzip，deflate</code></pre><p>如果Web服务器在请求中看到该头部，则可能使用客户端列出的方法之一压缩响应。  </p><p>Web服务器通过响应中的Content-Encoding标头通知Web客户端。</p><pre><code>内容编码：gzip</code></pre><blockquote><p>Gzip是目前最流行和最有效的压缩方法。它由GNU项目开发并由RFC 1952标准化。您可能会看到的唯一的其他压缩格式是压缩，但效果不太好，不太受欢迎。Gzipping通常将响应大小减少约70％。目前大约90％的互联网流量都通过声称支持gzip的浏览器。</p></blockquote><blockquote><p>浏览器和代理存在已知的问题，这些问题可能会导致浏览器期望的不匹配和接收到的有关压缩内容的不匹配。幸运的是，随着旧版浏览器的使用下降，这些边缘案例正在减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。</p></blockquote><p>服务器根据文件类型选择要压缩的内容，但在决定压缩的内容时通常太有限。  </p><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。  </p><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p><p>尽可能多地缩放文件类型是减少页面重量和加速用户体验的简单方法。</p><h3 id="将样式表放在顶部"><a href="#将样式表放在顶部" class="headerlink" title="将样式表放在顶部"></a>将样式表放在顶部</h3><p>将样式表移动到文档HEAD中,页面显示加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。这改善了整体用户体验。</p><p>将样式表放在文档底部附近的问题:它禁止在许多浏览器（包括Internet Explorer）中进行渐进式呈现。这些浏览器会阻止渲染，以避免在样式更改时重新绘制页面元素。用户停留在查看空白页面。</p><p>没有任何替代方案，空白屏幕或无风格内容的闪光都值得冒这个风险。最佳解决方案是遵循HTML规范，并将样式表加载到文档HEAD中。</p><h3 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h3><p>脚本导致的问题是它们会阻止并行下载。  </p><p>在HTTP / 1.1规范建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以同时发生两个以上的下载。然而，当脚本正在下载时，浏览器将不会启动任何其他下载，即使是在不同的主机名上。</p><p>在某些情况下，将脚本移动到底部并不容易。例如，如果脚本用于document.write插入页面内容的一部分，则不能在页面中移动较小的内容。也可能存在范围问题。在很多情况下，有办法解决这些情况。</p><p>经常出现的另一个建议是使用延迟脚本。<br>该DEFER属性指示该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该DEFER属性。在Internet Explorer中，该脚本可能会延迟，但不如预期的那么多。如果脚本可以被延期，它也可以被移动到页面的底部。这会让你的网页加载速度更快。</p><h3 id="避免使用CSS表达式"><a href="#避免使用CSS表达式" class="headerlink" title="避免使用CSS表达式"></a>避免使用CSS表达式</h3><p>CSS表达式是动态设置CSS属性的强大（也是危险的）方法。<br>从版本5开始，它们在Internet Explorer中受支持，但从IE8开始已弃用。  </p><p>表达式的问题在于它们比大多数人期望的更频繁地进行评估。</p><p>减少CSS表达式评估次数的一种方法是使用一次性表达式，第一次评估表达式时，它将style属性设置为一个显式值，该值将替换CSS表达式。  </p><p>如果样式属性必须在页面的整个生命周期中动态设置，则使用事件处理程序而不是CSS表达式是一种替代方法。  </p><p>如果您必须使用CSS表达式，请记住它们可能会被评估数千次，并且可能会影响页面的性能。</p><h3 id="使用外部JavaScript和CSS"><a href="#使用外部JavaScript和CSS" class="headerlink" title="使用外部JavaScript和CSS"></a>使用外部JavaScript和CSS</h3><p>许多这些性能规则涉及如何管理外部组件。但是，在出现这些问题之前，您应该提出一个更基本的问题：JavaScript和CSS应该包含在外部文件中还是包含在页面本身中？</p><p>在现实世界中<code>使用外部文件通常会产生更快的页面</code>，因为浏览器会缓存JavaScript和CSS文件。</p><ul><li>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</li><li>JavaScript和CSS位于浏览器缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><p>许多网站都处于这些指标的中间。对于这些网站，最好的解决方案通常是将JavaScript和CSS作为外部文件进行部署。首选内联的唯一例外是主页，例如雅虎的首页和My Yahoo! 。每个会话只有很少（可能只有一个）页面视图的主页可能会发现内嵌JavaScript和CSS可以缩短最终用户的响应时间。</p><p>对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少以及通过使用外部文件实现的缓存优点。其中一种方法是在首页内嵌JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已经在浏览器缓存中的外部文件。</p><h3 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h3><p><code>域名系统（DNS）</code>将主机名映射到IP地址，就像电话本将人名映射到他们的电话号码一样。<br>当您在浏览器中输入<a href="http://www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。" target="_blank" rel="noopener">www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。</a><br>DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。直到DNS查找完成后，浏览器才能从此主机名下载任何内容。</p><p>DNS查找缓存以获得更好的性能。这种高速缓存可以发生在用户的ISP或局域网维护的特殊高速缓存服务器上，但也可以在个人用户的计算机上进行高速缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器在自己的缓存中保存了一条DNS记录，它就不会打扰操作系统请求记录。</p><p>按照DnsCacheTimeout注册表设置的指定，Internet Explorer默认缓存DNS查找30分钟 。Firefox缓存DNS查找1分钟，由network.dnsCacheExpiration配置设置控制。（Fasterfox将此更改为1小时。）</p><p>当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。</p><p>减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间取得了很好的折衷。</p><h3 id="精简JavaScript"><a href="#精简JavaScript" class="headerlink" title="精简JavaScript"></a>精简JavaScript</h3><ul><li>在JavaScript的情况下，由于下载文件的大小减小，这提高了响应时间性能。</li><li>从代码中移除不必要的字符以减少其大小，减少加载时间。  </li><li><p>减少JavaScript 文件大小的有几种手段:  </p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。 </li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。  </li></ul></li></ul><h3 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h3><p>重定向是使用301和302状态码完成的。</p><p>浏览器会自动将用户转到该Location字段中指定的URL 。重定向所需的所有信息都在标题中,响应的主体通常是空的。    </p><p>尽管名称不同，301和302响应在实践中都不会被缓存，除非额外的标头（例如Expires或Cache-Control）指示它应该是。  </p><p>元刷新标记和JavaScript是将用户引导到不同URL的其他方式，但是如果您必须执行重定向，首选方法是使用标准的3xx HTTP状态代码，主要是为了确保后退按钮正常工作。</p><p>要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。</p><p>将旧网站连接到新网站是重定向的另一个常见用途。</p><p>其他包括连接网站的不同部分，并根据特定条件（浏览器类型，用户帐户类型等）指导用户。  </p><p>使用重定向来连接两个网站很简单，只需要很少的附加编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。  </p><p>这种重定向的替代方案包括使用Alias和mod_rewrite如果两个代码路径托管在同一台服务器上。  </p><p>如果域名更改是使用重定向的原因，另一种方法是创建一个CNAME（一个DNS记录，用于创建一个别名从一个域名指向另一个域名）与Alias或mod_rewrite。</p><h3 id="删除重复的脚本"><a href="#删除重复的脚本" class="headerlink" title="删除重复的脚本"></a>删除重复的脚本</h3><p>在一个页面中包含两次相同的JavaScript文件会使性能受损。</p><p>当它发生时，通过创建不必要的HTTP请求和浪费JavaScript执行，重复脚本会损害性能。</p><p>不必要的HTTP请求发生在Internet Explorer中，但不在Firefox中。  </p><p>在Internet Explorer中，如果外部脚本包含两次并且不可缓存，则会在加载页面期间生成两个HTTP请求。如果脚本可缓存，当用户重新加载页面时也会发生额外的HTTP请求。</p><p>除了生成浪费的HTTP请求之外，还会浪费多次时间评估脚本。无论脚本是否可缓存，此冗余JavaScript执行都会在Firefox和Internet Explorer中发生。</p><h3 id="配置ETags"><a href="#配置ETags" class="headerlink" title="配置ETags"></a>配置ETags</h3><p>实体标签（ETags）是Web服务器和浏览器用来确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（一个“实体”是另一个词“组件”：图像，脚本，样式表等）  </p><p>ETag被添加来提供一种机制来验证比上一次修改日期更灵活的实体。  </p><p>ETag是唯一标识组件特定版本的字符串。唯一的格式约束是字符串被引用。原始服务器使用ETag响应头指定组件的ETag 。</p><pre><code>HTTP / 1.1 200 OKLast-Modified：Tue，2006年12月12日03:03:59 GMTETag：“10c24bc-4ab-457e1c1f”内容长度：12195</code></pre><p>之后，如果浏览器必须验证组件，它将使用If-None-Match标头将ETag传递回原始服务器。如果ETags匹配，则返回一个304状态码，在此示例中将响应减少12195字节。</p><pre><code>GET /i/yahoo.gif HTTP / 1.1主持人：us.yimg.comIf-Modified-Since：星期二，2006年12月12日03:03:59 GMTIf-None-Match：“10c24bc-4ab-457e1c1f”HTTP / 1.1 304未修改</code></pre><p>ETags的问题在于，它们通常使用属性来构建，这些属性使它们对托管站点的特定服务器是唯一的。  </p><p>当浏览器从一台服务器获取原始组件并稍后尝试在另一台服务器上验证该组件时，ETags将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。</p><p>虽然给定的文件可能位于多个服务器的相同目录中，并且具有相同的文件大小，权限，时间戳等，但其inode不同于一台服务器。</p><p>IIS 5.0和6.0与ETags有类似的问题。IIS上ETags的格式是Filetimestamp:ChangeNumber。A ChangeNumber是用于跟踪IIS配置更改的计数器。ChangeNumber在网站后面的所有IIS服务器上都不可能是相同的。</p><p>最终结果是由Apache和IIS生成的ETags完全相同的组件不会从一台服务器到另一台服务器进行匹配。如果ETags不匹配，用户不会收到ETags设计的小而快的304响应; 相反，他们会得到一个正常的200响应以及组件的所有数据。  </p><p>如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多台服务器托管您的网站，并且您使用的是默认的ETag配置的Apache或IIS，那么您的用户的页面速度会变慢，您的服务器的负载会更高，消耗的带宽也会更大，高效地缓存您的内容。即使你的组件有一个遥远的将来Expires头，当用户点击重新加载或刷新时，仍然会发出条件GET请求。</p><p>如果您没有充分利用ETags提供的灵活验证模型，最好完全删除ETag。  </p><p>该Last-Modified头验证基于对组件的时间戳。  </p><p>删除ETag可以减少响应和后续请求中HTTP头的大小。</p><h3 id="使Ajax可缓存"><a href="#使Ajax可缓存" class="headerlink" title="使Ajax可缓存"></a>使Ajax可缓存</h3><p>Ajax引用的好处之一是，它向用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待这些异步JavaScript和XML响应返回时扭动拇指。  </p><p>在许多应用程序中，用户是否在等待取决于如何使用Ajax。例如，在基于Web的电子邮件客户端中，用户将不断等待Ajax请求的结果，以查找与其搜索条件匹配的所有电子邮件。记住“异步”并不意味着“即时”。</p><p>为了提高性能，优化这些Ajax响应非常重要。  </p><p>提高Ajax性能的最重要方法是使响应可缓存，如<code>添加过期或缓存控制头</code>中所述。  </p><ul><li>其他一些规则也适用于Ajax：<br>Gzip组件<br>减少DNS查找<br>缩小JavaScript<br>避免重定向<br>配置ETags</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;14条常用性能规则-待完善&quot;&gt;&lt;a href=&quot;#14条常用性能规则-待完善&quot; class=&quot;headerlink&quot; title=&quot;14条常用性能规则[待完善]&quot;&gt;&lt;/a&gt;14条常用性能规则&lt;span style=&quot;font-size:.5em&quot;&gt;[待完善]&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/XN.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>7类35条网页性能优化</title>
    <link href="https://hotkang.cn/2018/05/29/7%E7%B1%BB35%E6%9D%A1%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://hotkang.cn/2018/05/29/7类35条网页性能优化/</id>
    <published>2018-05-29T00:52:55.000Z</published>
    <updated>2018-06-19T13:51:19.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小结于"><a href="#小结于" class="headerlink" title="小结于"></a>小结于</h2><blockquote><p> <a href="https://developer.yahoo.com/performance/rules.html?guccounter=1#menu" target="_blank" rel="noopener">参考链接</a></p></blockquote><a id="more"></a><h1 id="7类35项网页性能优化"><a href="#7类35项网页性能优化" class="headerlink" title="7类35项网页性能优化"></a>7类35项网页性能优化</h1><h3 id="一、内容"><a href="#一、内容" class="headerlink" title="一、内容"></a><a href="#内容">一、内容</a></h3><p><a href="#减少http请求次数"><code>1. 减少HTTP请求次数</code> </a><br><a href="#减少dns查询次数"><code>2. 减少DNS查询次数</code></a><br><a href="#避免重定向"><code>3. 避免重定向</code>  </a><br><a href="#使ajax可缓存"><code>4. 使Ajax可缓存</code></a><br><a href="#延迟加载组件"><code>5. 延迟加载组件</code></a><br><a href="#预加载组件"><code>6. 预加载组件</code>  </a><br><a href="#减少dom元素的数量"><code>7. 减少DOM元素的数量</code></a><br><a href="#拆分组件跨域"><code>8. 拆分组件跨域</code>  </a><br><a href="#尽量减少iframe的数量"><code>9. 尽量减少iframe的数量</code></a><br><a href="#避免404"><code>10. 避免404</code></a></p><h3 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a><a href="#css">二、CSS</a></h3><p><a href="#将样式表放置在顶部"><code>11. 将样式表放置在顶部</code>  </a><br><a href="#避免使用css表达式"><code>12. 避免使用CSS表达式</code>  </a><br><a href="#用link替代import"><code>13. 用&lt;link&gt;替代@import</code></a><br><a href="#避免过滤器filters"><code>14. 避免过滤器Filters</code></a></p><h3 id="三、JavaScript"><a href="#三、JavaScript" class="headerlink" title="三、JavaScript"></a><a href="#javascript">三、JavaScript</a></h3><p><a href="#将脚本放在底部"><code>15. 将脚本放在底部</code>  </a><br><a href="#使javascript和css在外部"><code>16. 使JavaScript和CSS在外部</code></a><br><a href="#精简javascript和css"><code>17. 精简JavaScript和CSS</code></a><br><a href="#删除重复的脚本"><code>18. 删除重复的脚本</code>  </a><br><a href="#最小化dom访问"><code>19. 最小化DOM访问</code>  </a><br><a href="#开发智能事件处理程序"><code>20. 开发智能事件处理程序</code></a>  </p><h3 id="四、图片"><a href="#四、图片" class="headerlink" title="四、图片"></a><a href="#图片">四、图片</a></h3><p><a href="#优化图像"><code>21. 优化图像</code>  </a><br><a href="#优化css精灵"><code>22. 优化CSS精灵</code>  </a><br><a href="#不要在html中缩放图像"><code>23. 不要在HTML中缩放图像</code>  </a><br><a href="#制作faviconicosmall和cacheable"><code>24. 制作favicon.ico Small和Cacheable</code></a> </p><h3 id="五、Cookie"><a href="#五、Cookie" class="headerlink" title="五、Cookie"></a><a href="#cookie">五、Cookie</a></h3><p><a href="#减小cookie大小"><code>25. 减小Cookie大小</code>  </a><br><a href="#页面内容使用无cookie域"><code>26. 页面内容使用无Cookie域</code></a>  </p><h3 id="六、服务器"><a href="#六、服务器" class="headerlink" title="六、服务器"></a><a href="#服务器">六、服务器</a></h3><p><a href="#使用内容分发网络cdn"><code>27. 使用内容分发网络CDN</code>  </a><br><a href="#添加expires或cache-control标题"><code>28. 添加Expires或Cache-Control标题</code></a><br><a href="#gzip压缩传输文件"><code>29. Gzip压缩传输文件</code></a><br><a href="#配置etags"><code>30. 配置ETags</code>  </a><br><a href="#尽早flush输出"><code>31. 尽早flush输出</code>  </a><br><a href="#使用get获取ajax请求"><code>32. 使用GET获取AJAX请求</code></a><br><a href="#避免空图像src"><code>33. 避免空图像src</code>  </a></p><h3 id="七、手机"><a href="#七、手机" class="headerlink" title="七、手机"></a><a href="#手机">七、手机</a></h3><p><a href="#保持组件低于25k"><code>34. 保持组件低于25K</code>  </a><br><a href="#将组件打包成多部分文档"><code>35. 将组件打包成多部分文档</code></a></p><hr><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h3><p>终端用户响应时间的80％用于前端。大部分时间都在下载页面中的所有组件：图像、样式表、脚本、Flash等。<br>减少组件数量又会减少呈现页面所需的HTTP请求数量。这是更快页面的关键。</p><p>减少页面中组件数量的一种方法是简化页面的设计。但是，有没有办法构建更丰富的内容，同时实现快速响应时间？  </p><p>以下是一些减少HTTP请求数量的技术，同时还支持丰富的页面设计。</p><ul><li><p><code>组合文件</code>是一种通过将所有脚本合并为一个脚本来减少HTTP请求数量的方法，同样也可以将所有CSS合并到一个样式表中。当脚本和样式表因页面而异时，将文件组合起来更具挑战性，但使发布过程的这一部分能够缩短响应时间。</p></li><li><p><code>CSS Sprites</code>是减少图片请求数量的首选方法。将背景图像组合成单个图像，并使用CSSbackground-image和background-position属性显示所需的图像片段。</p></li><li><p><code>图像映射</code>将多个图像组合成单个图像。整体大小大致相同，但减少HTTP请求的数量会加快页面的速度。仅当图像在页面中连续存在时（例如导航栏），图像映射才起作用。定义图像映射的坐标可能很乏味且容易出错。使用图像地图进行导航也无法访问，因此不推荐。</p></li><li><p><code>内联图像</code>使用data:URL方案将图像数据嵌入到实际页面中。这可以增加HTML文档的大小。将内嵌图像合并到缓存的样式表中是减少HTTP请求并避免增加页面大小的一种方法。所有主流浏览器都不支持内嵌图像。</p></li></ul><p>减少页面中的HTTP请求数量是开始的地方。这是提高初次访问者性能的最重要指导方针。  </p><h3 id="减少DNS查询次数"><a href="#减少DNS查询次数" class="headerlink" title="减少DNS查询次数"></a>减少DNS查询次数</h3><p><code>域名系统（DNS）</code>将主机名映射到IP地址，就像电话本将人名映射到他们的电话号码一样。<br>当您在浏览器中输入<a href="http://www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。" target="_blank" rel="noopener">www.yahoo.com时，浏览器联系的DNS解析器会返回该服务器的IP地址。</a><br>DNS有成本。DNS通常需要20-120毫秒才能查找给定主机名的IP地址。直到DNS查找完成后，浏览器才能从此主机名下载任何内容。</p><p>DNS查找缓存以获得更好的性能。这种高速缓存可以发生在用户的ISP或局域网维护的特殊高速缓存服务器上，但也可以在个人用户的计算机上进行高速缓存。DNS信息保留在操作系统的DNS缓存中（Microsoft Windows上的“DNS客户端服务”）。大多数浏览器都有自己的缓存，与操作系统的缓存分开。只要浏览器在自己的缓存中保存了一条DNS记录，它就不会打扰操作系统请求记录。</p><p>按照DnsCacheTimeout注册表设置的指定，Internet Explorer默认缓存DNS查找30分钟 。Firefox缓存DNS查找1分钟，由network.dnsCacheExpiration配置设置控制。（Fasterfox将此更改为1小时。）</p><p>当客户端的DNS缓存为空（对于浏览器和操作系统）时，DNS查找的数量等于网页中唯一主机名的数量。这包括页面URL，图像，脚本文件，样式表，Flash对象等中使用的主机名。减少唯一主机名的数量可减少DNS查找的数量。</p><p>减少唯一主机名的数量有可能减少页面中发生的并行下载量。避免DNS查找会缩短响应时间，但减少并行下载可能会增加响应时间。我的准则是将这些组件分成至少两个但不超过四个主机名。这在减少DNS查找和允许高度并行下载之间取得了很好的折衷。</p><h3 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h3><p>重定向是使用301和302状态码完成的。</p><p>浏览器会自动将用户转到该Location字段中指定的URL 。重定向所需的所有信息都在标题中,响应的主体通常是空的。    </p><p>尽管名称不同，301和302响应在实践中都不会被缓存，除非额外的标头（例如Expires或Cache-Control）指示它应该是。  </p><p>元刷新标记和JavaScript是将用户引导到不同URL的其他方式，但是如果您必须执行重定向，首选方法是使用标准的3xx HTTP状态代码，主要是为了确保后退按钮正常工作。</p><p>要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。</p><p>将旧网站连接到新网站是重定向的另一个常见用途。</p><p>其他包括连接网站的不同部分，并根据特定条件（浏览器类型，用户帐户类型等）指导用户。  </p><p>使用重定向来连接两个网站很简单，只需要很少的附加编码。虽然在这些情况下使用重定向会降低开发人员的复杂性，但会降低用户体验。  </p><p>这种重定向的替代方案包括使用Alias和mod_rewrite如果两个代码路径托管在同一台服务器上。  </p><p>如果域名更改是使用重定向的原因，另一种方法是创建一个CNAME（一个DNS记录，用于创建一个别名从一个域名指向另一个域名）与Alias或mod_rewrite。</p><h3 id="使Ajax可缓存"><a href="#使Ajax可缓存" class="headerlink" title="使Ajax可缓存"></a>使Ajax可缓存</h3><p>Ajax引用的好处之一是，它向用户提供即时反馈，因为它从后端Web服务器异步请求信息。但是，使用Ajax并不能保证用户不会在等待这些异步JavaScript和XML响应返回时扭动拇指。  </p><p>在许多应用程序中，用户是否在等待取决于如何使用Ajax。例如，在基于Web的电子邮件客户端中，用户将不断等待Ajax请求的结果，以查找与其搜索条件匹配的所有电子邮件。记住“异步”并不意味着“即时”。</p><p>为了提高性能，优化这些Ajax响应非常重要。  </p><p>提高Ajax性能的最重要方法是使响应可缓存，如<code>添加过期或缓存控制头</code>中所述。  </p><ul><li>其他一些规则也适用于Ajax：<br>Gzip组件<br>减少DNS查找<br>缩小JavaScript<br>避免重定向<br>配置ETags</li></ul><h3 id="延迟加载组件"><a href="#延迟加载组件" class="headerlink" title="延迟加载组件"></a>延迟加载组件</h3><p>你可以仔细看看你的页面，并问自己：“为了最初呈现页面，绝对需要什么？”。其余的内容和组件可以等待。</p><p>JavaScript是在onload事件之前和之后进行分割的理想人选。  </p><p>例如，如果您有JavaScript代码和用于拖放和动画的库，则可以等待，因为在初始渲染之后拖动页面上的元素。其他要查找候选人进行后加载的地方包括隐藏内容（用户操作后显示的内容）和低于该对象的图像。</p><p>性能目标与其他Web开发最佳实践保持一致是很好的。在这种情况下，逐步增强的想法告诉我们，JavaScript在受支持的情况下可以改善用户体验，但是即使没有JavaScript，您也必须确保页面能够正常工作。  </p><p>因此，在确保页面正常工作后，您可以使用一些后期加载的脚本来增强它，从而为您提供更多的细节和哨音，例如拖放和动画。</p><h3 id="预加载组件"><a href="#预加载组件" class="headerlink" title="预加载组件"></a>预加载组件</h3><p>预加载看起来可能与后加载相反，但它实际上有一个不同的目标。通过预加载组件，您可以利用浏览器闲置的时间以及将来需要的组件（如图像，样式和脚本）。通过这种方式，当用户访问下一页时，您可以将大部分组件都存储在缓存中，并且您的页面将为用户加载得更快。</p><p>实际上有几种类型的预加载：</p><ul><li><p>无条件预加载:只要onload激活，您就可以继续并获取一些额外的组件。</p></li><li><p>有条件预加载:根据用户操作，您可以根据用户的行为猜测下一个用户前进的位置并相应地进行预加载。</p></li><li>预期的预加载:在启动重新设计之前提前预加载。它经常发生在重新设计之后，您会听到：“新网站很酷，但速度比以前慢”。部分问题可能在于用户使用完全缓存访问旧网站，但新网站总是空的缓存体验。您甚至可以在启动重新设计之前通过预加载某些组件来减轻这种副作用。您的旧网站可以使用浏览器闲置的时间，并请求将由新网站使用的图像和脚本</li></ul><h3 id="减少DOM元素的数量"><a href="#减少DOM元素的数量" class="headerlink" title="减少DOM元素的数量"></a>减少DOM元素的数量</h3><p>复杂的页面意味着需要下载更多的字节，这也意味着JavaScript中的DOM访问速度较慢。例如，当您想要添加事件处理程序时，如果在页面上循环遍历500或5000个DOM元素，则会有所不同。</p><p>大量的DOM元素可能是一种症状，应该通过页面的标记来改善某些内容，而不必删除内容。</p><p>DOM元素的数量很容易测试，只需输入Firebug的控制台：<br>      document.getElementsByTagName(‘*’).length</p><h3 id="拆分组件跨域"><a href="#拆分组件跨域" class="headerlink" title="拆分组件跨域"></a>拆分组件跨域</h3><p>拆分组件可让您最大限度地平行下载。由于DNS查找惩罚，请确保您使用的域不超过2-4个。</p><h3 id="尽量减少iframe的数量"><a href="#尽量减少iframe的数量" class="headerlink" title="尽量减少iframe的数量"></a>尽量减少iframe的数量</h3><p>Iframe允许将HTML文档插入到父文档中。了解iframe如何工作以便可以有效使用非常重要。</p><ul><li><p><code>&lt;iframe&gt;</code>优点：</p><ul><li>像徽章和广告等缓慢的第三方内容</li><li>安全沙箱</li><li>并行下载脚本</li></ul></li><li><p><code>&lt;iframe&gt;</code>缺点：</p><ul><li>即使空白也很昂贵</li><li>阻止页面载入</li><li>非语义</li></ul></li></ul><h3 id="避免404"><a href="#避免404" class="headerlink" title="避免404"></a>避免404</h3><p>HTTP请求很昂贵，因此提出HTTP请求并获得无用的响应（即404 Not Found）是完全没有必要的，并且会减慢用户体验而没有任何好处。</p><p>有些网站有帮助的404s“你的意思是X？”，这对用户体验很好，但也浪费了服务器资源（如数据库等）。特别糟糕的是，当到外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应正文，就好像它是JavaScript代码一样，试图找到可用的东西。</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="将样式表放置在顶部"><a href="#将样式表放置在顶部" class="headerlink" title="将样式表放置在顶部"></a>将样式表放置在顶部</h3><p>将样式表移动到文档HEAD中,页面显示加载速度更快。这是因为将样式表放在HEAD中允许页面逐步呈现。这改善了整体用户体验。</p><p>将样式表放在文档底部附近的问题:它禁止在许多浏览器（包括Internet Explorer）中进行渐进式呈现。这些浏览器会阻止渲染，以避免在样式更改时重新绘制页面元素。用户停留在查看空白页面。</p><p>没有任何替代方案，空白屏幕或无风格内容的闪光都值得冒这个风险。最佳解决方案是遵循HTML规范，并将样式表加载到文档HEAD中。</p><h3 id="避免使用CSS表达式"><a href="#避免使用CSS表达式" class="headerlink" title="避免使用CSS表达式"></a>避免使用CSS表达式</h3><p>CSS表达式是动态设置CSS属性的强大（也是危险的）方法。<br>从版本5开始，它们在Internet Explorer中受支持，但从IE8开始已弃用。  </p><p>表达式的问题在于它们比大多数人期望的更频繁地进行评估。</p><p>减少CSS表达式评估次数的一种方法是使用一次性表达式，第一次评估表达式时，它将style属性设置为一个显式值，该值将替换CSS表达式。  </p><p>如果样式属性必须在页面的整个生命周期中动态设置，则使用事件处理程序而不是CSS表达式是一种替代方法。  </p><p>如果您必须使用CSS表达式，请记住它们可能会被评估数千次，并且可能会影响页面的性能。</p><h3 id="用-lt-link-gt-替代-import"><a href="#用-lt-link-gt-替代-import" class="headerlink" title="用&lt;link&gt;替代@import"></a>用<code>&lt;link&gt;</code>替代@import</h3><p>以前的最佳实践之一指出，为了允许渐进式渲染，CSS应该处于顶端。</p><p>在IE中的@import行为与<link>在页面底部使用的行为相同，因此最好不要使用它。</p><h3 id="避免过滤器Filters"><a href="#避免过滤器Filters" class="headerlink" title="避免过滤器Filters"></a>避免过滤器Filters</h3><p>IE专有AlphaImageLoader过滤器旨在解决IE版本&lt;7中的半透明真彩色PNG问题。该过滤器的问题在于，它会在图像下载时阻止渲染并冻结浏览器。它也增加了内存消耗，并且每个元素应用，而不是每个图像，因此问题倍增。</p><p>最好的方法是AlphaImageLoader完全避免使用PNG8而不是降级，这在IE中是很好的。如果您绝对需要AlphaImageLoader，请使用下划线黑客_filter来惩罚您的IE7 +用户。</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h3 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h3><p>脚本导致的问题是它们会阻止并行下载。  </p><p>在HTTP / 1.1规范建议的浏览器下载不超过两种组分在每主机名平行。如果您从多个主机名提供图像，则可以同时发生两个以上的下载。然而，当脚本正在下载时，浏览器将不会启动任何其他下载，即使是在不同的主机名上。</p><p>在某些情况下，将脚本移动到底部并不容易。例如，如果脚本用于document.write插入页面内容的一部分，则不能在页面中移动较小的内容。也可能存在范围问题。在很多情况下，有办法解决这些情况。</p><p>经常出现的另一个建议是使用延迟脚本。<br>该DEFER属性指示该脚本不包含document.write，并且是浏览器可以继续呈现的线索。不幸的是，Firefox不支持该DEFER属性。在Internet Explorer中，该脚本可能会延迟，但不如预期的那么多。如果脚本可以被延期，它也可以被移动到页面的底部。这会让你的网页加载速度更快。</p><h3 id="使JavaScript和CSS在外部"><a href="#使JavaScript和CSS在外部" class="headerlink" title="使JavaScript和CSS在外部"></a>使JavaScript和CSS在外部</h3><p>许多这些性能规则涉及如何管理外部组件。但是，在出现这些问题之前，您应该提出一个更基本的问题：JavaScript和CSS应该包含在外部文件中还是包含在页面本身中？</p><p>在现实世界中<code>使用外部文件通常会产生更快的页面</code>，因为浏览器会缓存JavaScript和CSS文件。</p><ul><li>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</li><li>JavaScript和CSS位于浏览器缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><p>许多网站都处于这些指标的中间。对于这些网站，最好的解决方案通常是将JavaScript和CSS作为外部文件进行部署。首选内联的唯一例外是主页，例如雅虎的首页和My Yahoo! 。每个会话只有很少（可能只有一个）页面视图的主页可能会发现内嵌JavaScript和CSS可以缩短最终用户的响应时间。</p><p>对于通常是许多页面视图中的第一个的首页，有一些技术可以利用内联提供的HTTP请求的减少以及通过使用外部文件实现的缓存优点。其中一种方法是在首页内嵌JavaScript和CSS，但在页面加载完成后动态下载外部文件。后续页面将引用应该已经在浏览器缓存中的外部文件。</p><h3 id="精简JavaScript和CSS"><a href="#精简JavaScript和CSS" class="headerlink" title="精简JavaScript和CSS"></a>精简JavaScript和CSS</h3><ul><li>在JavaScript的情况下，由于下载文件的大小减小，这提高了响应时间性能。</li><li>从代码中移除不必要的字符以减少其大小，减少加载时间。  </li><li><p>减少JavaScript 文件大小的有几种手段:  </p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。 </li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。  </li></ul></li></ul><h3 id="删除重复的脚本"><a href="#删除重复的脚本" class="headerlink" title="删除重复的脚本"></a>删除重复的脚本</h3><p>在一个页面中包含两次相同的JavaScript文件会使性能受损。</p><p>当它发生时，通过创建不必要的HTTP请求和浪费JavaScript执行，重复脚本会损害性能。</p><p>不必要的HTTP请求发生在Internet Explorer中，但不在Firefox中。  </p><p>在Internet Explorer中，如果外部脚本包含两次并且不可缓存，则会在加载页面期间生成两个HTTP请求。如果脚本可缓存，当用户重新加载页面时也会发生额外的HTTP请求。</p><p>除了生成浪费的HTTP请求之外，还会浪费多次时间评估脚本。无论脚本是否可缓存，此冗余JavaScript执行都会在Firefox和Internet Explorer中发生。</p><h3 id="最小化DOM访问"><a href="#最小化DOM访问" class="headerlink" title="最小化DOM访问"></a>最小化DOM访问</h3><p>使用JavaScript访问DOM元素很慢，所以为了获得更响应的页面，您应该：</p><ul><li>缓存对访问元素的引用</li><li>更新节点“脱机”，然后将它们添加到树中</li><li>避免使用JavaScript修复布局</li></ul><h3 id="开发智能事件处理程序"><a href="#开发智能事件处理程序" class="headerlink" title="开发智能事件处理程序"></a>开发智能事件处理程序</h3><p>有时由于过多的事件处理程序附加到DOM树的不同元素上，而这些事件处理程序过于频繁地执行，有时页面的响应速度会降低 这就是为什么使用事件授权是一个好方法。  </p><p>如果在a中有10个按钮div，则只将一个事件处理程序附加到div包装器，而不是每个按钮的一个处理程序。事件冒泡，所以你可以捕捉事件并找出它起源于哪个按钮。</p><p>您也不需要等待onload事件才能开始使用DOM树进行操作。通常你需要的是你想访问的元素在树中可用。您不必等待下载所有图像。   </p><p>DOMContentLoaded是您可能考虑使用而不是onload的事件.</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h3 id="优化图像"><a href="#优化图像" class="headerlink" title="优化图像"></a>优化图像</h3><ul><li><p>减少图像周围的空白。 一些开发人员使用空白的填充这是万万要不得的。裁剪图像，删除图像周围任何空白，并使用CSS来填充。</p></li><li><p>使用正确的文件格式。如果你有图标，或者没有太多颜色的图形，可以保存为GIF这种较少颜色的图形。如果你有更详细的图形，可以使用JPG文件格式，降低质量保存图像。</p></li><li>以适当的尺寸保存图像。如果您正在使用HTML和CSS来调整您的图像，那么不要这样。以期望的大小保存你的图像，从而减少文件大小。  </li></ul><blockquote><p>恰当的图片格式：</p><ul><li>PNG格式几乎一直优于GIF格式，尽管某些旧版浏览器只能为PNG格式提供部分支持。</li><li>为较小或简单的图形（例如，小于10x10像素的图形或调色板小于3色的图形）以及包含动画的图片使用GIF格式。</li><li>为所有摄影风格的图片使用JPG格式。</li><li>请勿使用BMP格式或TIFF格式。</li></ul></blockquote><h3 id="优化CSS精灵"><a href="#优化CSS精灵" class="headerlink" title="优化CSS精灵"></a>优化CSS精灵</h3><p>一种网页图片应用处理方式。允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，再利用CSS的以下属性精确的定位出背景图片的位置。</p><blockquote><p>background-image<br>background- repeat<br>background-position </p></blockquote><h3 id="不要在HTML中缩放图像"><a href="#不要在HTML中缩放图像" class="headerlink" title="不要在HTML中缩放图像"></a>不要在HTML中缩放图像</h3><p>指定所有图片的宽度和高度可以加速渲染，因为省去了不必要的回流和重绘。</p><h3 id="制作favicon-icoSmall和Cacheable"><a href="#制作favicon-icoSmall和Cacheable" class="headerlink" title="制作favicon.icoSmall和Cacheable"></a>制作<code>favicon.icoSmall</code>和Cacheable</h3><p>favicon.ico是保留在服务器根目录中的映像。这是一个必要的罪恶，因为即使你不关心它，浏览器仍然会请求它，所以最好不要回应404 Not Found。  </p><p>另外，由于它位于同一台服务器上，每次请求时都会发送Cookie。此图片还会干扰下载顺序，例如在IE中，当您在onload中请求额外的组件时，favicon会在这些额外的组件之前下载。</p><p>因此，要减轻拥有favicon.ico的缺点，请确保：</p><ul><li>它很小，最好在1K以下。</li><li>设置过期标题与你感觉舒适（因为你不能重命名，如果你决定改变它）。您几乎可以在将来几个月安全地设置Expires标题。您可以查看您当前的favicon.ico的最后修改日期，以做出明智的决定。</li><li>Imagemagick可以帮助您创建小型图标</li></ul><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h3 id="减小Cookie大小"><a href="#减小Cookie大小" class="headerlink" title="减小Cookie大小"></a>减小Cookie大小</h3><p>HTTP cookie由于各种原因（如身份验证和个性化）而被使用。有关cookie的信息在Web服务器和浏览器之间的HTTP标头中交换。尽可能降低cookies的大小以尽量减少对用户响应时间的影响，这一点很重要。</p><ul><li>消除不必要的cookie</li><li>尽可能降低Cookie大小，以尽量减少对用户响应时间的影响</li><li>请注意在适当的域级别设置cookie，以便其他子域不受影响</li><li>适当设置过期日期。更早的过期日期或不更早删除cookie，提高用户响应时间</li></ul><h3 id="页面内容使用无Cookie域"><a href="#页面内容使用无Cookie域" class="headerlink" title="页面内容使用无Cookie域"></a>页面内容使用无Cookie域</h3><p>当浏览器发出静态图像请求并将cookie与请求一起发送时，服务器对这些cookie没有任何用处。所以他们只是没有理由地创建网络流量。您应该确保使用无cookie请求来请求静态组件。创建一个子域，并在其中托管所有静态组件。</p><p>在无Cookie域上托管静态组件的另一个好处是，某些代理可能会拒绝缓存使用cookie请求的组件。</p><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h3 id="使用内容分发网络CDN"><a href="#使用内容分发网络CDN" class="headerlink" title="使用内容分发网络CDN"></a>使用内容分发网络CDN</h3><ul><li>用户与Web服务器的距离对响应时间有影响。在多个地理位置分散的服务器上部署您的内容将使您的网页从用户的角度更快加载。但是你应该从哪里开始？</li></ul><p>作为实现地理上分散的内容的第一步，不要尝试重新设计您的Web应用程序以在分布式架构中工作。根据应用程序的不同，更改体系结构可能包括艰巨的任务，例如同步会话状态和跨服务器位置复制数据库事务。尝试缩短用户与内容之间的距离可能会延迟或不能通过此应用程序体系结构步骤。</p><p>请记住，80-90％的最终用户响应时间用于下载页面中的所有组件：图像，样式表，脚本，Flash等。这是性能黄金法则。  </p><p>不要从重新设计应用程序体系结构的艰巨任务开始，最好先分散您的静态内容。这不仅实现了响应时间的更大缩短，而且由于内容交付网络，这更容易实现。</p><p><code>内容传送网络（CDN）</code>是分布在多个位置的网络服务器的集合，以更高效地向用户传送内容。选择用于将内容递送给特定用户的服务器通常基于网络邻近度的度量。例如，选择网络跳数最少的服务器或响应时间最快的服务器。</p><p>一些大型互联网公司拥有自己的CDN，但使用CDN服务提供商（如Akamai Technologies，EdgeCast或level3）具有成本效益。对于创业公司和私人网站来说，CDN服务的成本可能会很高，但随着您的目标受众不断扩大并变得更加全球化，CDN是实现快速响应所必需的。</p><h3 id="添加Expires或Cache-Control标题"><a href="#添加Expires或Cache-Control标题" class="headerlink" title="添加Expires或Cache-Control标题"></a>添加Expires或<code>Cache-Control</code>标题</h3><p>这条规则有两个方面：</p><ul><li>对于静态组件：通过设置远期<code>Expires</code>标题实现“永不过期”策略</li><li>对于动态组件：使用适当的<code>Cache-Control</code>头文件来帮助浏览器提供有条件的请求</li></ul><p>网页设计越来越丰富，这意味着更多的脚本，样式表，图像和Flash在页面中。  </p><p>首次访问您的页面可能需要发出多个HTTP请求，但通过使用Expires标头，可以使这些组件可缓存。这避免了后续页面浏览中不必要的HTTP请求。  </p><p>过期标头最常用于图像，但它们应该用于所有组件，包括脚本，样式表和Flash组件。</p><p>浏览器（和代理）使用缓存来减少HTTP请求的数量和大小，使网页加载速度更快。<br>Web服务器使用HTTP响应中的Expires标头告诉客户端可以缓存组件的时间。  </p><p>请记住，如果您使用远期未来的Expires头文件，则只要组件更改，就必须更改组件的文件名。</p><p>只有在用户已经访问过您的网站后，使用远期未来的Expires标题才会影响页面浏览。  </p><p>当用户第一次访问您的网站并且浏览器的缓存为空时，它对HTTP请求的数量没有影响。  </p><p>因此，这种性能改进的影响取决于用户多久访问一次带有缓冲区的页面。（一个“准备好的缓存”已经包含了页面中的所有组件。）我们在Yahoo!上测试了这一点。并发现带有引导缓存的页面浏览量为75-85％。通过使用远期未来的Expires标题，您可以增加浏览器缓存的组件数量，并在后续页面浏览中重新使用，而无需在用户的Internet连接上发送单个字节。</p><h3 id="Gzip压缩传输文件"><a href="#Gzip压缩传输文件" class="headerlink" title="Gzip压缩传输文件"></a>Gzip压缩传输文件</h3><p>通过网络传输HTTP请求和响应所需的时间可以通过前端工程师做出的决策大大减少。  </p><p>确实，最终用户的带宽速度，互联网服务提供商，邻近对等交换点等是超出了开发团队的控制范围。  </p><p>但还有其他一些影响响应时间的因素。  </p><p>压缩通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP / 1.1开始，Web客户端通过HTTP请求中的Accept-Encoding标头指示对压缩的支持。  </p><pre><code>Accept-Encoding：gzip，deflate</code></pre><p>如果Web服务器在请求中看到该头部，则可能使用客户端列出的方法之一压缩响应。  </p><p>Web服务器通过响应中的Content-Encoding标头通知Web客户端。</p><pre><code>内容编码：gzip</code></pre><blockquote><p>Gzip是目前最流行和最有效的压缩方法。它由GNU项目开发并由RFC 1952标准化。您可能会看到的唯一的其他压缩格式是压缩，但效果不太好，不太受欢迎。Gzipping通常将响应大小减少约70％。目前大约90％的互联网流量都通过声称支持gzip的浏览器。</p></blockquote><blockquote><p>浏览器和代理存在已知的问题，这些问题可能会导致浏览器期望的不匹配和接收到的有关压缩内容的不匹配。幸运的是，随着旧版浏览器的使用下降，这些边缘案例正在减少。Apache模块通过自动添加适当的Vary响应头来提供帮助。</p></blockquote><p>服务器根据文件类型选择要压缩的内容，但在决定压缩的内容时通常太有限。  </p><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。  </p><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p><p>尽可能多地缩放文件类型是减少页面重量和加速用户体验的简单方法。</p><h3 id="配置ETags"><a href="#配置ETags" class="headerlink" title="配置ETags"></a>配置ETags</h3><p>实体标签（ETags）是Web服务器和浏览器用来确定浏览器缓存中的组件是否与源服务器上的组件匹配的机制。（一个“实体”是另一个词“组件”：图像，脚本，样式表等）  </p><p>ETag被添加来提供一种机制来验证比上一次修改日期更灵活的实体。  </p><p>ETag是唯一标识组件特定版本的字符串。唯一的格式约束是字符串被引用。原始服务器使用ETag响应头指定组件的ETag 。</p><pre><code>HTTP / 1.1 200 OKLast-Modified：Tue，2006年12月12日03:03:59 GMTETag：“10c24bc-4ab-457e1c1f”内容长度：12195</code></pre><p>之后，如果浏览器必须验证组件，它将使用If-None-Match标头将ETag传递回原始服务器。如果ETags匹配，则返回一个304状态码，在此示例中将响应减少12195字节。</p><pre><code>GET /i/yahoo.gif HTTP / 1.1主持人：us.yimg.comIf-Modified-Since：星期二，2006年12月12日03:03:59 GMTIf-None-Match：“10c24bc-4ab-457e1c1f”HTTP / 1.1 304未修改</code></pre><p>ETags的问题在于，它们通常使用属性来构建，这些属性使它们对托管站点的特定服务器是唯一的。  </p><p>当浏览器从一台服务器获取原始组件并稍后尝试在另一台服务器上验证该组件时，ETags将不匹配，这种情况在使用服务器集群处理请求的网站上非常常见。</p><p>虽然给定的文件可能位于多个服务器的相同目录中，并且具有相同的文件大小，权限，时间戳等，但其inode不同于一台服务器。</p><p>IIS 5.0和6.0与ETags有类似的问题。IIS上ETags的格式是Filetimestamp:ChangeNumber。A ChangeNumber是用于跟踪IIS配置更改的计数器。ChangeNumber在网站后面的所有IIS服务器上都不可能是相同的。</p><p>最终结果是由Apache和IIS生成的ETags完全相同的组件不会从一台服务器到另一台服务器进行匹配。如果ETags不匹配，用户不会收到ETags设计的小而快的304响应; 相反，他们会得到一个正常的200响应以及组件的所有数据。  </p><p>如果您只在一台服务器上托管您的网站，这不是问题。但是，如果您有多台服务器托管您的网站，并且您使用的是默认的ETag配置的Apache或IIS，那么您的用户的页面速度会变慢，您的服务器的负载会更高，消耗的带宽也会更大，高效地缓存您的内容。即使你的组件有一个遥远的将来Expires头，当用户点击重新加载或刷新时，仍然会发出条件GET请求。</p><p>如果您没有充分利用ETags提供的灵活验证模型，最好完全删除ETag。  </p><p>该Last-Modified头验证基于对组件的时间戳。  </p><p>删除ETag可以减少响应和后续请求中HTTP头的大小。</p><h3 id="尽早flush输出"><a href="#尽早flush输出" class="headerlink" title="尽早flush输出"></a>尽早flush输出</h3><p>当用户请求页面时，后端服务器可能需要200到500毫秒才能将HTML页面拼接在一起。在此期间，浏览器在等待数据到达时处于空闲状态。  </p><p>在PHP中，你有函数flush（）。  </p><p>它允许您将部分就绪的HTML响应发送到浏览器，以便浏览器可以在您的后端忙于HTML页面的其余部分时开始获取组件。好处主要出现在繁忙的后端或前端。<br>考虑刷新的好地方就在HEAD之后，因为头部的HTML通常更容易生成，并且允许您在浏览器中包含任何CSS和JavaScript文件，以便在后端仍在处理的同时开始并行读取。</p><h3 id="使用GET获取AJAX请求"><a href="#使用GET获取AJAX请求" class="headerlink" title="使用GET获取AJAX请求"></a>使用GET获取AJAX请求</h3><p>在使用时XMLHttpRequest，POST在浏览器中实现为两步：首先发送标题，然后发送数据。所以最好使用GET，它只需要一个TCP数据包发送（除非你有很多的cookie）。  </p><p>IE中最大的URL长度是2K，所以如果你发送的数据超过2K，你可能无法使用GET。</p><p>一个有趣的副作用是POST没有实际发布任何数据就像GET一样。  </p><p>基于HTTP规范，GET旨在用于检索信息，所以在您仅请求数据时使用GET（在语义上）是合理的，而不是将数据发送到服务器端存储。</p><h3 id="避免空图像src"><a href="#避免空图像src" class="headerlink" title="避免空图像src"></a>避免空图像src</h3><p>具有空字符串src属性的图像会发生超过一个人的预期。它以两种形式出现：</p><ul><li><code>&lt;img src =“”&gt;</code>  </li><li><code>var img = new Image（）;</code><br><code>img.src =“”;</code></li></ul><p>两种形式都会产生相同的效果：浏览器向您的服务器发出另一个请求</p><blockquote><p>Internet Explorer向该页面所在的目录发出请求。<br>Safari和Chrome向实际页面本身发出请求。<br>Firefox 3和更早版本的行为与Safari和Chrome相同，但版本3.5解决了此问题[错误444931]，不再发送请求。<br>当遇到空图像src时，Opera不会执行任何操作。</p></blockquote><p>为什么这种行为不好？</p><ul><li>通过发送大量意外流量来瘫痪您的服务器，特别是对于每天获得数百万页面浏览量的页面。</li><li>浪费服务器计算周期生成一个永远不会被查看的页面。</li><li>可能损坏的用户数据。如果您通过Cookie或以其他方式跟踪请求中的状态，则可能会销毁数据。即使图像请求没有返回图像，浏览器也会读取并接受所有标题，包括所有的Cookie。虽然其余的反应被抛弃，但损害可能已经完成。</li></ul><h1 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h1><h3 id="保持组件低于25K"><a href="#保持组件低于25K" class="headerlink" title="保持组件低于25K"></a>保持组件低于25K</h3><p>此限制与iPhone不会缓存大于25K的组件有关。请注意，这是未压缩的大小。这是缩小比例很重要的地方，因为gzip本身可能不够。</p><h3 id="将组件打包成多部分文档"><a href="#将组件打包成多部分文档" class="headerlink" title="将组件打包成多部分文档"></a>将组件打包成多部分文档</h3><p>将组件打包成多部分文档就像带有附件的电子邮件一样，它可以帮助您用一个HTTP请求获取多个组件（记住：HTTP请求很贵）。当你使用这种技术时，首先检查用户代理是否支持它（iPhone不支持）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小结于&quot;&gt;&lt;a href=&quot;#小结于&quot; class=&quot;headerlink&quot; title=&quot;小结于&quot;&gt;&lt;/a&gt;小结于&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; &lt;a href=&quot;https://developer.yahoo.com/performance/rules.html?guccounter=1#menu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器请求和响应过程来谈性能优化</title>
    <link href="https://hotkang.cn/2018/05/29/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B%E6%9D%A5%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://hotkang.cn/2018/05/29/从浏览器请求和响应过程来谈性能优化/</id>
    <published>2018-05-29T00:52:08.000Z</published>
    <updated>2018-07-10T11:03:22.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小结于"><a href="#小结于" class="headerlink" title="小结于"></a>小结于</h2><p><img src="/img/XNGC.png" alt=""></p><a id="more"></a><ul><li><p>为什么前端性能如此重要？数据显示：</p><ul><li>只有10%~20%的最终用户响应时间用来下载HTML文档，其余80%~90%时间用在下载页面中的所有组件</li><li>优化后台成本大，优化前端只需要适当遵循一些法则就会有较大的提升，低成本高收益</li></ul></li></ul><h2 id="浏览器预处理"><a href="#浏览器预处理" class="headerlink" title="浏览器预处理"></a>浏览器预处理</h2><ul><li>查询Cache：读取Cache或者发送304 请求</li></ul><h2 id="查询DNS"><a href="#查询DNS" class="headerlink" title="查询DNS"></a>查询DNS</h2><blockquote><p>DNS查找就是输入域名对服务器IP地址的查找过程。<br>DNS缓存: 浏览器DNS缓存、操作系统DNS缓存。<br>当你输入<a href="http://www.google.com的时候，浏览器会先去自身的" target="_blank" rel="noopener">www.google.com的时候，浏览器会先去自身的</a> <code>DNS缓存</code> 里面查找有没有google服务器的IP地址;如果找不到则继续到 <code>操作系统的DNS缓存</code> 查找;如果浏览器在这两个容器都没有找到google的IP地址记录，则会向广域域名体系查找。</p></blockquote><h3 id="1-优化规则-减少DNS查找"><a href="#1-优化规则-减少DNS查找" class="headerlink" title="1. 优化规则 - 减少DNS查找"></a><code>1. 优化规则 - 减少DNS查找</code></h3><ul><li>方法1：使用DNS缓存<br> 浏览器DNS缓存 | 计算机DNS缓存 | 服务器DNS缓存（TTL）</li></ul><ul><li><p>方法2：使用Keep-Alive特性<br>  当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。</p></li><li><p>方法3：较少的域名来减少DNS查找（2-4个主机）</p></li><li><p>方法4：使用第三方DNS域名解析加速服务<br>  国内的一款免费DNS加速服务DNSPOD；</p></li></ul><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><blockquote><p>CDN是一组分布在多个不同地理位置的Web服务器，由于距离用户 物理距离比较短，所以能够更加有利于用户获取到静态资源；这种服务通常需要购买，也有一些免费、通用的CDN可使用，国内的可以使用BootCDN。</p></blockquote><h3 id="2-优化规则-–-使用内容分发网络（CDN）"><a href="#2-优化规则-–-使用内容分发网络（CDN）" class="headerlink" title="2. 优化规则 – 使用内容分发网络（CDN）"></a><code>2. 优化规则 – 使用内容分发网络（CDN）</code></h3><ul><li><p>方法1：美国十大Internet网站和CDN服务提供商</p></li><li><p>方法2：页面静态化,取决于发布系统</p></li><li><p>方法3：Ctrip使用的China-Cache和网宿</p></li></ul><h3 id="3-优化规则-–-用域名划分页面内容"><a href="#3-优化规则-–-用域名划分页面内容" class="headerlink" title="3. 优化规则 – 用域名划分页面内容"></a><code>3. 优化规则 – 用域名划分页面内容</code></h3><p>  按页面内容划分域名，在合适的资源服务器上存放文件</p><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><blockquote><p>一般来说，使用外链的脚本和样式表更加有利。分别把外链脚本和样式表进行合并会减少HTTP请求，以节省客户端和服务器之间的通讯次数来加快页面打开速度。但是出于开发的便利，开发的时候一般会采取模块化的方式；这时候可以在部署前采用一些前端构建工具 <code>gulp</code> 、<code>grunt</code> 把这些模块文件合并起来再发布。</p></blockquote><h3 id="4-优化规则-–-减少HTTP请求"><a href="#4-优化规则-–-减少HTTP请求" class="headerlink" title="4. 优化规则 – 减少HTTP请求"></a><code>4. 优化规则 – 减少HTTP请求</code></h3><ul><li><p>图片地图 </p><ul><li>假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。    </li></ul><p><img src="/img/JL.png" alt=""></p><ul><li>服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应</li><li>客户端图片地图：直接将点击映射到操作</li></ul></li><li><p>内联图像    </p></li><li><p>合并文件: js文件不超过7个,css文件不超过4个,各频道首页和全站首页不超过3个;</p></li><li>目前无法解决的是allyes广告的请求数。 </li><li>大量的广告和产品图片可能会造成，图片请求数很大，可能造成总请求数指标吃紧，这个只能从设计上搞定，需要权衡 </li><li><p>目前老页面可能css和js文件请求数可能会超标  </p></li><li><p>合并样式和脚本</p></li></ul><h3 id="5-优化规则-–-优化CSS-Spirite-图片精灵"><a href="#5-优化规则-–-优化CSS-Spirite-图片精灵" class="headerlink" title="5. 优化规则 – 优化CSS Spirite(图片精灵)"></a><code>5. 优化规则 – 优化CSS Spirite(图片精灵)</code></h3><p>一种网页图片应用处理方式。允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，再利用CSS的以下属性精确的定位出背景图片的位置。</p><blockquote><p>background-image<br>background- repeat<br>background-position </p></blockquote><h3 id="6-优化规则-–-避免404错误"><a href="#6-优化规则-–-避免404错误" class="headerlink" title="6. 优化规则 – 避免404错误"></a><code>6. 优化规则 – 避免404错误</code></h3><p>  HTTP请求很昂贵，因此提出HTTP请求并获得无用的响应（即404 Not Found）是完全没有必要的，会减慢用户体验没有任何好处。  </p><p>  有些网站有帮助的404“你的意思是X？”，这对用户体验很好，但也浪费了服务器资源（如数据库等）。  </p><p>  特别糟糕的是，当到外部JavaScript的链接错误并且结果是404时。首先，此下载将阻止并行下载。接下来，浏览器可能会尝试解析404响应正文，就好像它是JavaScript代码一样，试图找到可用的东西。</p><h3 id="7-优化规则-–-不要使用frameset-少使用iframe"><a href="#7-优化规则-–-不要使用frameset-少使用iframe" class="headerlink" title="7. 优化规则 – 不要使用frameset,少使用iframe"></a><code>7. 优化规则 – 不要使用frameset,少使用iframe</code></h3><p>  搜索引擎不友好，即使内容为空，加载也需要时间、会阻止页面加载 </p><p>  Iframe允许将HTML文档插入到父文档中。了解iframe如何工作以便可以有效使用非常重要。</p><ul><li><p><code>&lt;iframe&gt;</code>优点：</p><ul><li>像徽章和广告等缓慢的第三方内容</li><li>安全沙箱</li><li>并行下载脚本</li></ul></li><li><p><code>&lt;iframe&gt;</code>缺点：</p><ul><li>即使空白也很昂贵</li><li>阻止页面载入</li><li>非语义  </li></ul></li></ul><p>禁止使用iframe引入外部资源，不包括allyes广告，不包括about:blank的空页面。</p><h2 id="等待响应"><a href="#等待响应" class="headerlink" title="等待响应"></a>等待响应</h2><h3 id="8-优化规则-–-避免重定向"><a href="#8-优化规则-–-避免重定向" class="headerlink" title="8. 优化规则 – 避免重定向"></a><code>8. 优化规则 – 避免重定向</code></h3><p>  以下是一个重定向的过程： </p><p>  浏览器发送请求——&gt;服务器返回302——&gt;浏览器发送第二次请求—–&gt;服务器返回200—&gt;浏览器开始呈现 </p><p>  就是说，在重定向完毕并且HTML下载完毕之前，是没有任何东西显示给用户  </p><p>  要记住的重点是<code>重定向会减慢用户体验</code>。在用户和HTML文档之间插入重定向会延迟页面中的所有内容，因为可以呈现页面中的任何内容，并且在HTML文档到达之前不会开始下载任何组件。  </p><p>  涉及服务器负载、数据查询、服务器端缓存等</p><h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><h3 id="9-优化规则-–-压缩组件Gzip"><a href="#9-优化规则-–-压缩组件Gzip" class="headerlink" title="9. 优化规则 – 压缩组件Gzip"></a><code>9. 优化规则 – 压缩组件Gzip</code></h3><ul><li><p>HTML文档、脚本和样式表、XML和JSON的文本响应,压缩通常能将响应的数据量减少将近70%  </p></li><li><p>大多数网站gzip他们的HTML文件。gzip脚本和样式表也是值得的，但很多网站都错过了这个机会。事实上，压缩包括XML和JSON的任何文本响应都是值得的。  </p></li><li><p>图像和PDF文件不应该被压缩，因为它们已经被压缩。试图压缩它们不仅浪费CPU，而且可能会增加文件大小。</p></li></ul><h3 id="10-优化规则-–-精简Javascript和CSS文件大小"><a href="#10-优化规则-–-精简Javascript和CSS文件大小" class="headerlink" title="10. 优化规则 – 精简Javascript和CSS文件大小"></a><code>10. 优化规则 – 精简Javascript和CSS文件大小</code></h3><ul><li><p>从代码中移除不必要的字符以减少其大小，减少加载时间。</p></li><li><p>减少JavaScript 文件大小的有几种手段:  </p><ul><li><p>精简:去除JavaScript代码中的空格、注释等多余的字符，这种方式基本上没有什么缺点。</p></li><li><p>混淆:在精简的基础上，把函数、变量名都用较短小的字符来替换，从而达到减少文件大小的效果。</p></li><li>但是混淆会产生不少麻烦，很有可能会引入错误，虽然有利于防止逆向工程，当同时也增加了自己在线上环境调试的难度。 </li><li>现在普遍的做法是发布前利用 Gulp、Grunt等自动化构建工具对资源进行压缩。  </li></ul></li></ul><h3 id="11-优化规则-–-尽量缩减页面大小"><a href="#11-优化规则-–-尽量缩减页面大小" class="headerlink" title="11. 优化规则 – 尽量缩减页面大小"></a><code>11. 优化规则 – 尽量缩减页面大小</code></h3><ul><li><p>页面必须小于150K(不含图片）</p></li><li><p>静态文件是否gzip</p></li><li>图片是否压缩优化过</li></ul><h2 id="读取Cache"><a href="#读取Cache" class="headerlink" title="读取Cache"></a>读取Cache</h2><h3 id="12-优化规则-–-添加-Expires-头或-Cache-Control"><a href="#12-优化规则-–-添加-Expires-头或-Cache-Control" class="headerlink" title="12. 优化规则 – 添加 Expires 头或 Cache-Control"></a><code>12. 优化规则 – 添加 Expires 头或 Cache-Control</code></h3><ul><li><p>Expires头是用来告诉浏览器该响应的有效期，可以理解为该资源的“保质期”，在期限内可以使用该资源的缓存不需要重新请求。</p></li><li><p>由于浏览器与服务器存在时钟同步问题，HTTP1.2.1还添加了Cache-Control和max-age来弥补Expires头的不足。</p></li><li>通常用于脚本、样式表、图片等静态资源。</li></ul><p>使用这种策略可能会遇到一个问题是，开发者可能想要在资源过期前这段时间更新它们。 </p><p>这时候，由于浏览器的缓存还没失效，这就需要通过更改文件名来令静态资源 强制失效。有很多种方式给静态资源打上版本号，可以一本正经地打上数字版本号，根据内容生成哈希码也行，甚至有人用π来给自己的资源打版本号.  </p><p>应用于不经常变化的组件，包括脚本、样式表、Flash组件、图片</p><h3 id="13-优化规则-–-使用外链JavaScript和CSS"><a href="#13-优化规则-–-使用外链JavaScript和CSS" class="headerlink" title="13. 优化规则 – 使用外链JavaScript和CSS"></a><code>13. 优化规则 – 使用外链JavaScript和CSS</code></h3><ul><li>尽可能 使用外链JavaScript和CSS，因为我们目前大部分avaScript和CSS都做了Gzip和缓存技术，可以充分利用。</li></ul><ul><li><p>使用外链样式和脚本优点有： </p><ul><li>可以被浏览器缓存起来；</li><li>组件可重用</li><li>可模块化；</li><li>能够被构建（合并压缩打版本）</li></ul></li><li><p>内联的JavaScript和CSS: 减少HTTP请求数量，增加了HTML文档的大小。</p></li><li>JavaScript和CSS位于浏览器：缓存的外部文件中：HTML文档的大小会减少，不会增加HTTP请求的数量。</li></ul><blockquote><p>关键因素是外部JavaScript和CSS组件相对于所请求HTML文档数量的缓存频率。这个因素尽管难以量化，但可以使用各种指标进行衡量。如果您的网站上的用户每个会话有多个页面浏览量，并且许多网页重复使用相同的脚本和样式表，则缓存的外部文件可能带来更大的潜在收益。</p></blockquote><h2 id="处理元素"><a href="#处理元素" class="headerlink" title="处理元素"></a>处理元素</h2><p>不要对image和pdf等二进制文件进行gzip压缩</p><h2 id="渲染元素"><a href="#渲染元素" class="headerlink" title="渲染元素"></a>渲染元素</h2><h3 id="14-优化规则-–-将样式表放在顶部"><a href="#14-优化规则-–-将样式表放在顶部" class="headerlink" title="14. 优化规则 – 将样式表放在顶部"></a><code>14. 优化规则 – 将样式表放在顶部</code></h3><ul><li><p>样式表放在底部时，浏览器会延迟显示任何可视化组件(使用 CSS 的@import 等同于把想要加载的样式放在底部，所以不建议使用。)  </p></li><li><p>对于浏览器的渲染机制，本书并没有过多提及，只是对现象做出了描述以及提供了解决办法.  </p></li><li><p>如果样式表仍然在加载，构建呈现树就是一种浪费，因为在所有样式表 加载并解析完毕 之前无需绘制任何东西。因为在样式表准备好之前显示内容会遇到 FOUC（无样式内容的闪烁，Flash of Unstyled Content）问题。  </p></li><li>样式表不在顶部中，当遇到样式时，浏览器就会阻止页面呈现，等待样式表下载完毕。如果把样式表放在底部，在 IE 中还会产生白屏现象。</li><li>总之，把样式表放进就能避免这些问题。</li></ul><h3 id="15-优化规则-–-建议将脚本放在底部"><a href="#15-优化规则-–-建议将脚本放在底部" class="headerlink" title="15. 优化规则 – 建议将脚本放在底部"></a><code>15. 优化规则 – 建议将脚本放在底部</code></h3><p>  一般浏览器可以允许并行下载，取决于主机个数、带宽等（默认情况下，IE是2个而FF是8个）下载脚本时并行下载实际上是被禁用的。</p><ul><li>脚本对页面的影响是：<ul><li>阻塞对其后面内容的呈现</li><li>阻塞后面组件的下载</li><li>浏览器会在下载脚本的时候阻塞并行下载，因为需要确保脚本能够顺序执行。<blockquote><p>但是，实际开发中有时候很难完全遵守这条准则，那只能把能够放在最后的都放在最后。</p></blockquote></li></ul></li></ul><h3 id="16-优化规则-–-移除重复脚本"><a href="#16-优化规则-–-移除重复脚本" class="headerlink" title="16. 优化规则 – 移除重复脚本"></a><code>16. 优化规则 – 移除重复脚本</code></h3><p>  必须为0，重复的脚本对增加HTTP 请求次数和脚本执行的时间。</p><h3 id="17-优化规则-–-避免CSS表达式"><a href="#17-优化规则-–-避免CSS表达式" class="headerlink" title="17. 优化规则 – 避免CSS表达式"></a><code>17. 优化规则 – 避免CSS表达式</code></h3><p>  使用CSS 的expression()通常会造成多次运算。影响浏览器渲染时间。实际上，需要用到CSS表达式的地方，通常能够找到其他替代方案，所以避免使用CSS表达式。</p><h3 id="18-优化规则-–-优化图像"><a href="#18-优化规则-–-优化图像" class="headerlink" title="18. 优化规则 – 优化图像"></a><code>18. 优化规则 – 优化图像</code></h3><ul><li><p>尽量使用GIF和PNG</p></li><li><p>尽量使用png/gif格式的图片，png的图片优先，但是必须注意如要兼容IE6，则png使用一定要注意透明问题。</p></li><li><p>图片在使用前一定要先用工具压缩优化（png、jpg）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小结于&quot;&gt;&lt;a href=&quot;#小结于&quot; class=&quot;headerlink&quot; title=&quot;小结于&quot;&gt;&lt;/a&gt;小结于&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/XNGC.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="换个角度看性能优化" scheme="https://hotkang.cn/categories/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="https://hotkang.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
